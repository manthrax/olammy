{
  "src": "vec4 Effect2(vec2 uv) {\n    // Create orbiting points parameters\n    const float pointCount = 8.0;\n    vec3[8] orbits = vec3[](\n        vec3(1.5, 0.5, 0.0),   // radius, speed, phase\n        vec3(2.0, 0.7, pi/4.0),\n        vec3(1.8, 0.6, pi/2.0),\n        vec3(2.2, 0.8, 3.0*pi/4.0),\n        vec3(1.6, 0.9, pi),\n        vec3(2.0, 0.5, 5.0*pi/4.0),\n        vec3(1.7, 0.8, 3.0*pi/2.0),\n        vec3(1.9, 0.7, 7.0*pi/4.0)\n    );\n    \n    // Create expanding rings parameters\n    const float ringCount = 6.0;\n    vec3[6] rings = vec3[](\n        vec3(0.2, 0.5, 0.0),   // start radius, speed, color phase\n        vec3(0.3, 0.4, pi/3.0),\n        vec3(0.4, 0.6, 2.0*pi/3.0),\n        vec3(0.5, 0.7, pi),\n        vec3(0.6, 0.8, 4.0*pi/3.0),\n        vec3(0.7, 0.9, 5.0*pi/3.0)\n    );\n    \n    vec3 finalColor = vec3(0.0);\n    \n    // Iterate through each orbiting point\n    for (int i = 0; i < 8; i++) {\n        vec3 orbitParams = orbits[i];\n        float radius = orbitParams.x;\n        float speed = orbitParams.y;\n        float phase = orbitParams.z;\n        \n        // Calculate current position of the orbiting point\n        float t = iTime * speed + phase;\n        vec2 pos = vec2(cos(t), sin(t)) * radius;\n        \n        // Iterate through each expanding ring\n        for (int j = 0; j < 6; j++) {\n            vec3 ringParams = rings[j];\n            float startRadius = ringParams.x;\n            float ringSpeed = ringParams.y;\n            float colorPhase = ringParams.z;\n            \n            // Calculate current radius of the ring\n            float timeSinceStart = iTime - (startRadius / ringSpeed);\n            float currentRadius = startRadius + ringSpeed * timeSinceStart;\n            \n            // Calculate distance from fragment to orbiting point\n            vec2 diff = uv - pos.xy;\n            float dist = length(diff);\n            \n            // Calculate ring influence\n            float ringInfluence = smoothstep(currentRadius - 0.1, currentRadius + 0.1, dist);\n            ringInfluence = 1.0 - ringInfluence;\n            \n            // Calculate color based on distance and time\n            vec3 color = hsl2rgb(vec3((colorPhase + t) / pi, 1.0, 0.5));\n            finalColor += color * ringInfluence;\n        }\n    }\n    \n    // Add noise for extra detail\n    float noiseValue = turbulent(uv * 4.0 + iTime);\n    finalColor *= 1.0 + noiseValue * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
}