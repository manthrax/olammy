{
  "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of triangles\n    vec2 pos = floor(uv * 10.0);\n    vec2 cell = fract(pos);\n    \n    // Add rotation based on time and position\n    float angle = iTime * 0.5 + noise(vec3(pos, iTime)) * 0.5;\n    \n    // Create three points for the triangle\n    vec2 p1 = vec2(0.5, 0.5) + vec2(cos(angle), sin(angle)) * 0.4;\n    vec2 p2 = vec2(0.5, 0.5) + vec2(cos(angle + 120.0 * pi/180.0), sin(angle + 120.0 * pi/180.0)) * 0.4;\n    vec2 p3 = vec2(0.5, 0.5) + vec2(cos(angle - 120.0 * pi/180.0), sin(angle - 120.0 * pi/180.0)) * 0.4;\n    \n    // Calculate barycentric coordinates to check if point is inside triangle\n    vec2 v = cell - p1;\n    vec2 w = p2 - p1;\n    vec2 u = p3 - p1;\n    \n    float dot00 = dot(w, w);\n    float dot01 = dot(w, u);\n    float dot02 = dot(w, v);\n    float dot11 = dot(u, u);\n    float dot12 = dot(u, v);\n    \n    float denom = dot00 * dot11 - dot01 * dot01;\n    float s = (dot11 * dot02 - dot01 * dot12) / denom;\n    float t = (dot00 * dot12 - dot01 * dot02) / denom;\n    \n    // Check if point is inside triangle\n    bool inside = s >= 0.0 && t >= 0.0 && s + t <= 1.0;\n    \n    // Calculate color based on position and time\n    vec3 color = hsl(\n        (pos.x + pos.y) * 0.1 + iTime,\n        0.7 + turbulent(vec2(cell)) * 0.3,\n        0.5 + min(s, t) * 0.5\n    );\n    \n    // Fade color based on proximity to center of triangle\n    float fade = smoothstep(0.0, 1.0, (1.0 - length(cell - vec2(0.5, 0.5))) * 4.0);\n    color *= fade;\n    \n    return vec4(color, 1.0);\n}"
}