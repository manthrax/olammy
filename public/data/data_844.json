{
  "src": "vec4 Effect2(vec2 uv) {\n    // Node grid parameters\n    int gridSize = 20;\n    float nodeRadius = 0.05;\n    \n    // Mouse position (assuming normalized coordinates)\n    vec2 mousePos = uv;\n    \n    // Initialize color\n    vec3 color = vec3(0.0);\n    \n    // Draw nodes and connections\n    for(int i = 0; i < gridSize; i++) {\n        for(int j = 0; j < gridSize; j++) {\n            // Node position\n            vec2 nodePos = vec2(float(i)/float(gridSize), float(j)/float(gridSize));\n            \n            // Distance to mouse\n            float distToMouse = length(nodePos - mousePos);\n            \n            // Brightness based on proximity to mouse\n            float brightness = smoothstep(0.5, 0.1, distToMouse);\n            \n            // Node color with pulsing effect\n            vec3 nodeColor = hsl2rgb(vec3(0.4 + sin(iTime * 0.5) * 0.1, 0.7, brightness * 0.8 + 0.2));\n            \n            // Draw node\n            float nodeDistance = length(uv - nodePos);\n            if(nodeDistance < nodeRadius) {\n                color += nodeColor;\n            }\n            \n            // Connect to adjacent nodes\n            for(int di = -1; di <= 1; di++) {\n                for(int dj = -1; dj <= 1; dj++) {\n                    if(abs(di) + abs(dj) != 1) continue;\n                    \n                    vec2 neighborPos = nodePos + vec2(float(di), float(dj)) * 0.5;\n                    if(neighborPos.x < 0.0 || neighborPos.x > 1.0 || neighborPos.y < 0.0 || neighborPos.y > 1.0) continue;\n                    \n                    // Draw connection line\n                    vec2 lineDir = normalize(neighborPos - nodePos);\n                    float lineDistance = length(uv - nodePos);\n                    \n                    if(lineDistance < 0.5 && abs(dot(uv - nodePos, lineDir)) < 0.03) {\n                        color += mix(vec3(0.1), nodeColor, smoothstep(0.4, 0.2, distToMouse));\n                    }\n                }\n            }\n        }\n    }\n    \n    // Add some noise for extra detail\n    vec2 noisePos = uv * 50.0;\n    float noiseValue = turbulent(noisePos) * 0.1;\n    color += noiseValue * 0.3;\n    \n    return vec4(color, 1.0);\n}"
}