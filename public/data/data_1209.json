{
  "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    // Create multiple ring centers with time-based offsets\n    const int numRings = 4;\n    float timeOffset = iTime * 0.5;\n    \n    vec3 colorSum = vec3(0.0);\n    \n    for (int i = 0; i < numRings; i++) {\n        // Calculate ring center with time-based movement\n        float angleOffset = PI * float(i) / float(numRings);\n        vec2 center = vec2(sin(angleOffset + timeOffset), cos(angleOffset + timeOffset)) * 0.5;\n        \n        // Calculate distance from current point to ring center\n        vec2 offsetSt = st - center;\n        float dist = length(offsetSt);\n        \n        // Create expanding rings using sine wave with increasing frequency over time\n        float ringSize = sin(iTime * 0.5 + float(i)) * 0.3 + 0.7;\n        float ringDistance = mod(dist, ringSize) / ringSize;\n        \n        // Use turbulence to add complexity to the pattern\n        vec2 noiseUV = (st + iTime) * 10.0;\n        float noiseValue = turbulent(noiseUV);\n        \n        // Create color variations using HSL\n        float hue = (angleOffset + timeOffset) * 3.0;\n        vec3 baseColor = hsl(hue, 0.7, 0.5);\n        vec3 ringColor = mix(baseColor, vec3(1.0), noiseValue * 0.5 + 0.5);\n        \n        // Additive blending for overlapping rings\n        colorSum += ringColor * (1.0 - abs(ringDistance - 0.5) * 2.0) * 0.4;\n    }\n    \n    // Convert to RGB and apply gamma correction\n    vec3 finalColor = hsl2rgb(colorSum);\n    finalColor = pow(finalColor, vec3(1.0 / 2.2));\n    \n    return vec4(finalColor, max(0.0, colorSum.r + colorSum.g + colorSum.b - 2.5));\n}"
}