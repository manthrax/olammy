{
  "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Particle count per dimension (total particles: PARTICLES * PARTICLES)\n    const int PARTICLES = 8;\n    \n    // Time-based animation\n    float time = iTime * 0.5;\n    \n    for(int x = -PARTICLES/2; x < PARTICLES/2; x++) {\n        for(int y = -PARTICLES/2; y < PARTICLES/2; y++) {\n            // Particle position offset\n            vec2 posOffset = vec2(float(x), float(y)) * 0.1;\n            \n            // Random seed based on position and time\n            vec3 randSeed = vec3(uv + posOffset, time);\n            float noiseVal = noise(randSeed) * 0.5 + 0.5;\n            \n            // Particle movement with gravitational influence\n            vec2 gravityCenter = vec2(0.5, 0.5);\n            vec2 toCenter = uv + posOffset - gravityCenter;\n            float distFromCenter = length(toCenter);\n            \n            // Calculate particle position with noise and time\n            vec2 particlePos = uv + posOffset +\n                sin(time + noiseVal * 10.0) * \n                (toCenter / max(distFromCenter, 0.01)) *\n                noiseVal * 0.05;\n            \n            // Color based on distance from center and time\n            vec3 color = hsl2rgb(vec3(\n                mod(time + distFromCenter * 2.0, 1.0),\n                0.7,\n                0.8\n            ));\n            \n            // Brightness based on distance from center\n            float brightness = noiseVal * \n                sin(distFromCenter * 5.0 + time) * 0.5 + 0.5;\n            \n            // Additive blending for trailing effect\n            finalColor += color * brightness *\n                turbulent(vec3(particlePos, time)) * 0.8;\n        }\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
}