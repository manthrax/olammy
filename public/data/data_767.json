{
  "src": "vec4 Effect2(vec2 uv) {\n    // Electric blue to neon pink gradient parameters\n    vec3 color1 = hsl2rgb(vec3(240.0, 1.0, 0.5)); // Electric blue\n    vec3 color2 = hsl2rgb(vec3(330.0, 1.0, 0.5)); // Neon pink\n    \n    // Pulsating alpha value using sine wave\n    float alphaPulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Sine wave distortion parameters\n    vec2 distortUV = uv + sin(uv * 4.0 + iTime) * 0.1;\n    \n    // Layered rotating hexagonal grids\n    float rotationSpeed = 0.5;\n    float gridScale = 8.0;\n    \n    // Create hexagonal pattern using polar coordinates\n    vec2 toPolar = vec2(length(distortUV), atan2(distortUV.y, distortUV.x));\n    toPolar.y += iTime * rotationSpeed;\n    \n    // Convert back to cartesian coordinates\n    vec2 rotatedUV = vec2(\n        cos(toPolar.y) * toPolar.x,\n        sin(toPolar.y) * toPolar.x\n    );\n    \n    // Create hexagonal grid pattern\n    float hexPattern = abs(sin(rotatedUV.x * gridScale + iTime)) +\n                      abs(sin(rotatedUV.y * gridScale + iTime));\n    \n    // Layered grids with different rotations and scales\n    vec2 uvLayer1 = rotatedUV * 0.5;\n    vec2 uvLayer2 = rotatedUV * 0.75;\n    \n    float pattern1 = turbulent(uvLayer1);\n    float pattern2 = turbulent(uvLayer2);\n    \n    // Combine patterns with mixing factor\n    float finalPattern = mix(pattern1, pattern2, 0.3);\n    \n    // Add noise for turbulence effect\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float noiseValue = noise(noiseUV) * 0.5;\n    \n    // Combine everything with color gradient and pulsating alpha\n    vec3 finalColor = mix(color1, color2, hexPattern * 0.5 + 0.5);\n    finalColor *= (finalPattern + noiseValue) * 0.5 + 0.5;\n    \n    return vec4(finalColor, alphaPulse);\n}"
}