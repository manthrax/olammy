{
  "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Time-based rotation angle\n    float timeAngle = iTime * 0.1;\n    \n    // Mouse-controlled rotation (assuming mouse data is passed via another uniform)\n    // For this example, we'll use time instead of actual mouse input\n    float mouseAngle = iTime * 0.5; \n    \n    // Combine rotation angles\n    float angle = timeAngle + mouseAngle;\n    \n    // Create rotating coordinate system\n    vec2 rotatedSt = vec2(\n        st.x * cos(angle) - st.y * sin(angle),\n        st.x * sin(angle) + st.y * cos(angle)\n    );\n    \n    // Calculate distance from lines at different angles\n    float d1 = abs(sin(rotatedSt.x * 5.0 + iTime) * 0.5 + 0.5);\n    float d2 = abs(cos(rotatedSt.y * 5.0 - iTime) * 0.5 + 0.5);\n    \n    // Combine distances with noise\n    float combinedDist = min(d1, d2) + turbulent(vec3(st, iTime)) * 0.2;\n    \n    // Create line pattern with varying thickness\n    float linePattern = smoothstep(0.4, 0.6, combinedDist);\n    \n    // Generate color based on angle and time\n    vec3 colorHSL = vec3(\n        atan2(rotatedSt.y, rotatedSt.x) * 0.5 + iTime,\n        0.7,\n        0.8\n    );\n    \n    // Convert to RGB and apply pattern\n    vec3 finalColor = hsl2rgb(colorHSL) * linePattern;\n    \n    return vec4(finalColor, 1.0);\n}"
}