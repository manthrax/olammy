{
  "src": "vec4 Effect2(vec2 uv) {\n    // Time-based animation\n    float time = iTime * 0.5;\n    \n    // Create a grid of points with noise offsets\n    vec2 st = uv * 10.0 + noise(vec3(uv * 5.0, time)) * 2.0;\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Calculate angle and radius for each point\n    float angle = atan2(fpos.y - 0.5, fpos.x - 0.5) + time;\n    float radius = length(fpos - 0.5) * 2.0;\n    \n    // Create rotating beams with noise modulation\n    vec3 beamColor = hsl2rgb(vec3(\n        mod(angle * 180.0 / PI, 360.0),\n        0.7,\n        0.5 + noise(vec3(st.xyy)) * 0.5\n    ));\n    \n    // Add geometric shapes with turbulence\n    float shape = 0.0;\n    for(int i = 0; i < 4; i++) {\n        vec2 pos = vec2(\n            sin(time + float(i) * PI * 0.5) * 0.5 + 0.5,\n            cos(time + float(i) * PI * 0.5) * 0.5 + 0.5\n        );\n        shape += length(uv - pos) < 0.3 + turbulent(vec3(uv, time)) * 0.2 ? \n            1.0 : 0.0;\n    }\n    \n    // Combine beams and shapes with color transformations\n    vec3 finalColor = beamColor * (1.0 - shape) +\n        hsl2rgb(vec3(\n            mod(angle * 180.0 / PI + 180.0, 360.0),\n            0.5,\n            0.3 + noise(vec3(uv.yx, time)) * 0.4\n        )) * shape;\n    \n    // Add glow effect and gamma correction\n    finalColor = pow(finalColor, vec3(1.2));\n    \n    return vec4(finalColor, 1.0);\n}"
}