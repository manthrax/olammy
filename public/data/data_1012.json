{
  "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create hexagonal grid pattern\n    const float hexRadius = 1.0;\n    vec3 color = vec3(0.0);\n    \n    // Generate multiple hexagons with offset positions\n    for(float i = -2.0; i <= 2.0; i++) {\n        for(float j = -2.0; j <= 2.0; j++) {\n            vec2 center = vec2(i * 2.0, j * sqrt(3.0));\n            vec2 offset = st + center;\n            \n            // Convert to polar coordinates relative to hexagon center\n            float r = length(offset);\n            float theta = atan2(offset.y, offset.x) + iTime * 0.5;\n            \n            // Create hexagonal shape using polar coordinates\n            float d = abs(theta) / (pi/3.0); \n            d = min(d, 1.0 - d);\n            float dist = r * cos(d * pi/2.0);\n            \n            // Add turbulence for dynamic effect\n            vec3 noisePos = vec3(offset.x + iTime, offset.y + iTime, 0.0);\n            float turb = turbulent(noisePos) * 0.5 + 0.5;\n            \n            // Create color based on angle and time\n            vec3 hslColor = vec3(theta / (2.0*pi), 1.0, 0.5 + turb * 0.5);\n            vec3 rgbColor = hsl2rgb(hslColor);\n            \n            // Combine colors for overlapping hexagons\n            if(dist < hexRadius) {\n                color += rgbColor * (hexRadius - dist) / hexRadius;\n            }\n        }\n    }\n    \n    return vec4(color, 1.0);\n}"
}