{
  "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Number of orbiting points\n    const int numPoints = 8;\n    \n    // Time-based rotation\n    float time = iTime * 0.5;\n    \n    // Add base noise for turbulence\n    vec2 noiseUV = uv * 10.0 + vec2(time, 0.0);\n    float baseNoise = turbulent(noiseUV) * 0.3;\n    \n    for(int i = 0; i < numPoints; i++) {\n        // Calculate angle for each point\n        float angle = (float(i) / float(numPoints)) * PI * 2.0 + time;\n        \n        // Orbiting position with radius\n        vec2 orbitPos = vec2(cos(angle), sin(angle)) * 0.7;\n        \n        // Add noise to orbit position\n        orbitPos += noise(vec3(orbitPos * 5.0 + time, 0.0)) * 0.1;\n        \n        // Calculate distance from fragment to orbiting point\n        vec2 diff = uv - orbitPos;\n        float dist = length(diff);\n        \n        // Create expanding rings effect\n        float ring = mod(dist - time, 1.0) * 0.5 + 0.5;\n        ring = abs(ring * 2.0 - 1.0);\n        \n        // Add turbulence to the rings\n        float turb = turbulent(diff * 10.0 + vec2(time)) * 0.3;\n        ring += turb;\n        \n        // Create color based on distance and time\n        vec3 color = hsl2rgb(vec3((time + float(i) / float(numPoints)) * 0.5, 0.7, 0.8));\n        \n        // Combine ring effect with color\n        finalColor += color * (1.0 - ring);\n    }\n    \n    // Add base noise to the background\n    finalColor += vec3(baseNoise * 0.2 + 0.1);\n    \n    return vec4(finalColor, 1.0);\n}"
}