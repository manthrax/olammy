{
  "src": "vec4 Effect2(vec2 uv) {\n    // Apply time-based distortion to UV coordinates\n    vec2 distortedUV = uv + 0.1 * sin(iTime + 5.0 * uv.x) * cos(iTime + 5.0 * uv.y);\n    \n    // Create a grid of circles with dynamic positions and sizes\n    float circleCount = 8.0;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < circleCount; i++) {\n        for(float j = 0.0; j < circleCount; j++) {\n            // Calculate circle center with time-based offset\n            vec2 center = vec2(i / circleCount, j / circleCount) + \n                         0.1 * sin(iTime + i * 3.14) * cos(iTime + j * 3.14);\n            \n            // Dynamic radius based on time and position\n            float radius = 0.25 + 0.1 * sin(iTime + i * 2.0 + j * 3.0);\n            \n            // Calculate distance from current pixel to circle center\n            vec2 offset = distortedUV - center;\n            float dist = length(offset);\n            \n            // Create circular pattern with smooth edges\n            float blend = smoothstep(radius, radius + 0.1, dist);\n            \n            // Dynamic color based on time and position\n            vec3 color = hsl(\n                iTime * 0.2 + i * 0.5,\n                0.7 + 0.3 * sin(iTime + j * 2.0),\n                0.5 + 0.5 * blend\n            );\n            \n            // Accumulate colors with transparency\n            finalColor += (1.0 - blend) * color;\n        }\n    }\n    \n    // Apply turbulence-based distortion to the final color\n    float turb = turbulent(vec3(distortedUV, iTime * 0.1)) * 0.5 + 0.5;\n    finalColor = mix(finalColor, hsl2rgb(vec3(iTime * 0.1, 1.0, 0.5)), turb);\n    \n    return vec4(pow(finalColor, vec3(1.0 / 2.2)), 1.0); // Gamma correction\n}"
}