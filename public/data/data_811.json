{
  "src": "vec4 Effect2(vec2 uv) {\n    // Time-based rotation angle\n    float time = iTime * 0.5;\n    \n    // Cube vertices (8 points)\n    vec3[8] vertices = vec3[8](\n        vec3(-1,-1,-1), vec3(1,-1,-1),\n        vec3(1,1,-1), vec3(-1,1,-1),\n        vec3(-1,-1,1), vec3(1,-1,1),\n        vec3(1,1,1), vec3(-1,1,1)\n    );\n    \n    // Cube edges (each edge is a pair of vertex indices)\n    int[24] edges = int[24](\n        0,1, 1,2, 2,3, 3,0,\n        4,5, 5,6, 6,7, 7,4,\n        0,4, 1,5, 2,6, 3,7\n    );\n    \n    // Rotate cube\n    mat3 rot = mat3(\n        cos(time), -sin(time), 0,\n        sin(time), cos(time), 0,\n        0, 0, 1.0\n    ) * mat3(\n        cos(time*0.5), 0, -sin(time*0.5),\n        0, 1.0, 0,\n        sin(time*0.5), 0, cos(time*0.5)\n    );\n    \n    // Project vertices\n    vec2[8] projected;\n    for(int i = 0; i < 8; i++) {\n        vec3 v = rot * (vertices[i] * 0.7);\n        projected[i] = v.xy / (v.z + 1.5);\n    }\n    \n    // Draw edges\n    float alpha = 0.0;\n    for(int i = 0; i < 24; i += 2) {\n        int a = edges[i];\n        int b = edges[i+1];\n        \n        vec2 p1 = projected[a] * 0.5 + 0.5;\n        vec2 p2 = projected[b] * 0.5 + 0.5;\n        \n        // Calculate distance from fragment to line segment\n        vec2 dir = p2 - p1;\n        float t = clamp(dot(uv - p1, dir) / dot(dir, dir), 0.0, 1.0);\n        vec2 closest = p1 + t * dir;\n        float dist = length(uv - closest);\n        \n        // Add glow effect\n        alpha += smoothstep(0.05, 0.0, dist) * \n                 (turbulent(vec3(uv, time)) + 0.5) *\n                 0.1;\n    }\n    \n    // Color transformation with pulsing\n    vec3 color = hsl2rgb(vec3(\n        fract(time * 0.2 + noise(vec2(time))) * 360.0,\n        1.0,\n        0.5\n    ));\n    \n    return vec4(color, alpha);\n}"
}