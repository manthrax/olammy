{
  "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 center = vec2(0.5);\n    vec2 pos = uv - center;\n    float radius = length(pos);\n    float theta = atan(pos.y, pos.x);\n    \n    // Add time-based rotation\n    theta += 3.0 * iTime;\n    \n    // Create multiple layers of particles\n    const int numLayers = 3;\n    vec4 finalColor = vec4(0.0);\n    \n    for(int i = 0; i < numLayers; i++) {\n        float layerRadius = float(i+1) * 0.25;\n        float speed = float(numLayers - i) * 0.5;\n        \n        // Calculate position in current layer\n        theta += speed * iTime;\n        vec2 dir = vec2(cos(theta), sin(theta));\n        float dist = length(pos);\n        \n        // Add noise to create variation\n        float noiseScale = pow(2.0, float(i)) * 0.1;\n        float perturb = noise(vec3(uv * 8.0 + iTime, i)) * noiseScale;\n        \n        // Blend colors based on distance and noise\n        vec3 colorBase = hsl2rgb(vec3(120.0 + float(i)*60.0, 1.0, 0.5));\n        vec3 color = mix(colorBase, vec3(1.0), perturb * 0.5 + 0.5);\n        \n        // Add to final color with transparency\n        float alpha = max(0.0, 1.0 - abs(dist - layerRadius) / 0.1);\n        alpha *= (perturb + 1.0) * 0.5;\n        \n        finalColor += vec4(color, alpha);\n    }\n    \n    // Add some global noise for extra variation\n    float globalNoise = noise(vec3(uv * 2.0 + iTime, 0)) * 0.2;\n    finalColor.rgb *= 1.0 + globalNoise;\n    \n    return finalColor;\n}"
}