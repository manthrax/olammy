{
  "data.json": {
    "src": "\nvec4 Effect2(vec2 uv) {\n    float t = iTime * 0.3;\n    vec2 pos = uv * 4.0 - sin(t);\n    float wave = turbulent(pos * 2.0 + vec2(sin(t), cos(t)));\n    vec3 color = hsv2rgb(vec3(wave * 0.6 + 0.5, 0.9, 0.7));\n    return vec4(color, 1.0);\n}"
  },
  "data_1.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing liquid metal effect using noise and turbulence\n    \n    // Add time-based distortion to UV coordinates\n    vec2 distortedUV = uv * 5.0 + vec2(iTime, iTime * 0.7);\n    distortedUV += turbulent(distortedUV * 0.5) * 0.3;\n    \n    // Generate base color with metallic feel\n    vec3 color = vec3(0.1, 0.1, 0.1); // Dark gray\n    \n    // Add shimmering effect using noise and time\n    float noiseValue = noise(distortedUV);\n    color += mix(vec3(0.5, 0.7, 1.0), // Cyan-ish\n                 vec3(1.0, 0.4, 0.8), // Magenta-ish\n                 noiseValue) * (noiseValue + sin(iTime) * 0.5);\n    \n    // Add flowing highlights\n    vec2 highlightUV = uv * 2.0 + vec2(sin(iTime) * 3.0, cos(iTime) * 2.0);\n    float highlight = turbulent(highlightUV * 0.5) * 0.7;\n    color += vec3(1.0, 0.8, 0.6) * (highlight + sin(length(uv)) * 0.3);\n    \n    // Mix in some yellow for warmth\n    color += vec3(1.0, 1.0, 0.4) * noise(distortedUV + iTime) * 0.2;\n    \n    // Ensure colors don't overflow and apply gamma correction\n    return vec4(pow(color / 1.5, vec3(1.0/2.2)), 1.0);\n}"
  },
  "data_10.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a dark background color\n    vec3 bgColor = hsl2rgb(vec3(0.5, 1.0, 0.1));\n    \n    // Calculate distance from center\n    vec2 pos = uv - 0.5;\n    float dist = length(pos);\n    float distSq = dist * dist;\n    \n    // Create circular pattern with noise\n    float timeFactor = sin(iTime * 0.5) * 0.5 + 0.5;\n    float noise1 = turbulent(vec2(uv.x * 4.0, uv.y * 4.0)) * 0.5 + 0.5;\n    float noise2 = turbulent(vec3(uv * 8.0, iTime * 0.2)) * 0.5 + 0.5;\n    \n    // Combine elements\n    vec3 color = hsl2rgb(vec3(\n        0.6 + noise1 * 0.3,\n        0.7 + noise2 * 0.3,\n        0.2 + timeFactor * 0.3\n    ));\n    \n    // Add circular gradient effect\n    float gradient = smoothstep(0.8, 1.0, dist);\n    color *= mix(vec3(1.0), vec3(0.5), gradient);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_100.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequencies for noise\n    float freq1 = sin(iTime * 0.5 + 1.0);\n    float freq2 = sin(iTime * 0.7 + 2.0);\n    \n    // Create a central point of interest\n    vec2 center = uv - vec2(0.5);\n    float dist = length(center) * 4.0;\n    dist += iTime * 2.0;\n    \n    // Generate noise values with different scales\n    float n1 = noise(vec3(uv * freq1 * 2.0 + iTime, iTime));\n    float n2 = noise(vec3(uv * freq2 * 3.0 + iTime*2.0, iTime*0.5));\n    \n    // Create a color transition effect\n    vec3 color = hsl(\n        sin(iTime * 0.1) * 0.5 + 0.5,\n        0.7 + n1 * 0.3,\n        0.5 + n2 * 0.5\n    );\n    \n    // Add turbulence effect\n    float turb = turbulent(vec2(uv.x * 4.0, uv.y * 4.0 + iTime));\n    color *= pow(abs(turb), 2.0);\n    \n    // Combine everything for the final effect\n    vec3 finalColor = mix(\n        color,\n        hsl(1.0 - sin(iTime * 0.1) * 0.5, 0.8, 0.6),\n        pow(sin(dist * 0.2 + iTime), 4.0)\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1000.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create rotating hexagonal pattern\n    theta += iTime * 6.0; // Rotate over time\n    \n    // Create gradient fill based on angle and radius\n    vec3 color = hsl(theta * 0.15 + 0.5, 0.7, 0.6);\n    \n    // Add pulsating center effect\n    float pulse = sin(iTime) * 0.2;\n    r += pulse;\n    \n    // Create hexagonal shape with multiple layers\n    float d = mod(theta * 6.0 + iTime, pi * 2.0);\n    float layer1 = smoothstep(0.7, 0.8, abs(r - 0.5));\n    float layer2 = smoothstep(0.6, 0.7, abs(r - 0.3));\n    float layer3 = smoothstep(0.5, 0.6, abs(r - 0.1));\n    \n    // Combine layers and add noise\n    float final = (layer1 + layer2 + layer3) * 0.4;\n    final += turbulent(st * 8.0 + iTime) * 0.2;\n    \n    // Convert to RGB and return\n    vec3 finalColor = hsl2rgb(color * final);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1001.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using HSL with time-based animation\n    vec3 baseColor = hsl(\n        sin(iTime * 0.5 + uv.x * 10.0) * 0.5 + 0.5,  // Hue variation\n        0.7,  // Saturation\n        0.5   // Lightness\n    );\n    \n    // Add noise and turbulence effects\n    vec2 noiseUV = uv * 8.0 + iTime;\n    float noiseValue = noise(noiseUV);\n    float turbulentValue = turbulent(noiseUV * 4.0);\n    \n    // Combine effects with color transformations\n    vec3 finalColor = baseColor * (noiseValue * 0.5 + 0.5) + \n                     hsv2rgb(vec3(0.1, 0.8, 1.0)) * turbulentValue;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1002.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x) + iTime; \n    float r = length(st);\n    \n    // Add noise and turbulence in radial direction\n    float tr = turbulent(vec3(r*5.0, iTime*0.5, 0.0));\n    float ttheta = turbulent(vec3(theta*2.0, iTime*0.7, 0.0));\n    \n    // Create color from combined noise patterns\n    vec3 color = hsl(\n        (tr + ttheta) * 180.0,\n        0.6 + 0.4*sin(iTime*0.5),\n        0.5 + 0.5*cos(tr*2.0 + iTime)\n    );\n    \n    // Add some layering and depth\n    float layer1 = turbulent(vec3(r*10.0, theta*3.0, iTime));\n    float layer2 = turbulent(vec3(r*5.0, theta*6.0, iTime+1.0));\n    \n    color *= hsl2rgb(vec3(\n        (layer1 + layer2)*180.0,\n        0.4,\n        0.7\n    ));\n    \n    // Add some tonal adjustments and vignette\n    color = mix(color, vec3(0.0), smoothstep(0.95, 1.0, r));\n    color *= 0.8 + 0.2*sin(iTime);\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_1003.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying frequency\n    float t = iTime * 0.5;\n    \n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 4.0;\n    \n    // Add noise and turbulence\n    theta += noise(vec3(theta / 8.0 + t, r / 8.0 + t, 0.0)) * 0.5;\n    r += turbulent(vec2(r / 8.0 + t, theta / 8.0 + t)) * 0.5;\n    \n    // Create color from HSL\n    vec3 color = hsl(\n        mod(theta * 0.1 + t, 1.0),  // Hue\n        0.7 + noise(vec2(r / 4.0 + t, theta / 4.0 + t)) * 0.3,  // Saturation\n        0.5 + sin(r * 0.1 + t) * 0.5  // Lightness\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_1004.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float t = iTime * 2.0;\n    vec2 rotatedUv = uv * mat2(cos(t), sin(t), -sin(t), cos(t));\n    \n    // Generate noise patterns with different scales\n    float n1 = noise(rotatedUv * 50.0);\n    float n2 = turbulent(rotatedUv * 100.0 + vec2(3.14, 2.718));\n    \n    // Create color variations using HSL to RGB conversion\n    vec3 baseColor = hsl(\n        sin(iTime * 0.5) * 0.5 + 0.5,\n        0.6,\n        0.5\n    );\n    \n    // Mix noise values with UV coordinates and time\n    float mixVal = (n1 + n2 * 0.5 + sin(rotatedUv.x * 10.0) * 0.3) * 0.5 + 0.5;\n    \n    // Create final color by mixing base color with noise-influenced values\n    vec3 finalColor = mix(\n        baseColor,\n        hsl2rgb(vec3(\n            (n1 + rotatedUv.x) * 0.5 + 0.5,\n            0.7,\n            0.6\n        )),\n        mixVal\n    );\n    \n    // Add some time-based pulsing to the color\n    finalColor *= sin(iTime * 0.3) * 0.5 + 0.5;\n    \n    return vec4(finalColor, max(n1, n2) * 0.5 + 0.5);\n}"
  },
  "data_1005.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Dynamic frequency based on time\n    float freq = 5.0 + sin(iTime * 0.5) * 3.0;\n    \n    // Create shifting pattern using sine functions\n    vec2 st = uv * freq;\n    st.x += sin(st.y * 0.5 + iTime) * 0.5;\n    st.y += cos(st.x * 0.7 - iTime * 2.0) * 0.3;\n    \n    // Calculate color components with time-based phase shift\n    vec3 color = vec3(\n        sin(st.x * 4.0 + iTime) * 0.5 + 0.5,\n        cos(st.y * 4.0 - iTime * 2.0) * 0.5 + 0.5,\n        sin((st.x + st.y) * 3.0 + iTime * 1.5) * 0.5 + 0.5\n    );\n    \n    // Apply HSL color shift based on time and position\n    vec3 hslColor = vec3(\n        fract(sin(iTime * 0.2 + uv.x * 4.0) * 0.8 + 0.1),\n        0.7,\n        0.5 + sin(iTime * 0.3 + uv.y * 6.0) * 0.2\n    );\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1006.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create rotating hexagon pattern\n    float rotation = sin(iTime * 0.5) + cos(iTime * 0.3);\n    a += rotation;\n    // Hexagonal tiling using polar coordinates\n    float angleStep = pi / 3.0;\n    float d = min(\n        length(st),\n        min(length(vec2(r, a - angleStep)),\n            min(length(vec2(r, a + angleStep)),\n                min(length(vec2(r, a - 2.0 * angleStep)),\n                    min(length(vec2(r, a + 2.0 * angleStep)),\n                        length(vec2(r, a - 3.0 * angleStep)))))));\n    // Add noise to create dynamic movement\n    vec2 noisePos = uv * 5.0 + iTime;\n    float n = noise(noisePos);\n    d += n * 0.1;\n    // Create pulsing effect\n    float pulse = sin(iTime) * 0.3 + 0.7;\n    d *= pulse;\n    // Generate rainbow colors using HSL\n    vec3 color;\n    if (d < 0.5) {\n        color = hsl2rgb(vec3((a / (2.0 * pi) + iTime * 0.1) * 360.0, 1.0, 0.5));\n    } else {\n        color = vec3(0.0);\n    }\n    // Combine with noise for final effect\n    float intensity = smoothstep(0.4, 0.6, d);\n    color *= intensity;\n    return vec4(color, 1.0);\n}"
  },
  "data_1007.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create pulsating circles with different parameters\n    for(float i = 0.0; i < 5.0; i++) {\n        float phase = i * 0.2;\n        float speed = 1.0 + sin(iTime * 0.5 + phase) * 0.5;\n        \n        // Moving circle position\n        vec2 pos = vec2(\n            sin(iTime * speed + phase) * 0.5 + 0.5,\n            cos(iTime * speed + phase) * 0.5 + 0.5\n        );\n        \n        // Calculate distance from current pixel to circle center\n        float dist = length(uv - pos);\n        \n        // Pulsating radius with time\n        float radius = 0.2 + sin(iTime + phase) * 0.1;\n        \n        // Create color based on distance and time\n        vec3 c = hsl2rgb(vec3(\n            (iTime + dist * 5.0 + phase) * 0.2,\n            0.7,\n            0.6 + sin(iTime + dist * 5.0 + phase) * 0.2\n        ));\n        \n        // Add turbulence effect\n        float turb = turbulent(uv * 10.0 + iTime);\n        c *= 1.0 + turb * 0.3;\n        \n        // Blend circles together with smooth falloff\n        float blend = smoothstep(radius, radius + 0.1, dist);\n        color += c * (1.0 - blend);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1008.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates into 0-1 range\n    vec2 st = uv * 8.0;\n    \n    // Create three layers of sine waves with different frequencies and phase shifts\n    float r = sin(st.x + iTime) * 0.5 + 0.5;\n    float g = sin(st.y + iTime * 0.7 + 2.0) * 0.5 + 0.5;\n    float b = sin(length(st) + iTime * 0.4 + 1.0) * 0.5 + 0.5;\n    \n    // Add turbulence for more dynamic movement\n    vec3 color = vec3(r, g, b) + turbulent(vec2(uv.x * 4.0, uv.y * 4.0) + iTime);\n    \n    // Convert to HSL and back to RGB for smoother transitions\n    vec3 hslColor = hsl(color.r * 360.0, 1.0, 0.5);\n    vec3 finalColor = hsl2rgb(hslColor);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1009.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create color variations using HSL colorspace\n    vec3 hslColor = vec3(\n        0.5 + sin(theta + iTime) * 0.3,\n        1.0,  // Saturation\n        r * 0.5 + sin(r * 20.0 + iTime) * 0.2  // Lightness varies with radius and time\n    );\n    \n    // Convert HSL to RGB and add some turbulence for dynamic effect\n    vec3 color = hsl2rgb(hslColor);\n    \n    // Add distance-based falloff\n    color *= pow(1.0 - r * 0.5, 3.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_101.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for better pattern visibility\n    vec2 st = uv * 10.0;\n    \n    // Create a time-varying base pattern using turbulence\n    float t1 = turbulent(st + iTime);\n    \n    // Add another layer of turbulence with higher frequency\n    float t2 = turbulent(st * 5.0 + iTime);\n    \n    // Combine turbulence values and add time variation\n    float value = (t1 + t2) * 0.5;\n    value += sin(iTime * 0.5) * 0.3;\n    \n    // Create color variations using HSL to RGB conversion\n    vec3 color = hsl(\n        fract(value * 4.0 + iTime),   // Hue variation\n        0.7 + t1 * 0.3,              // Saturation\n        0.5 + t2 * 0.5               // Lightness\n    );\n    \n    // Add geometric transformations\n    vec2 rotated = uv - 0.5;\n    rotated *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    rotated += 0.5;\n    \n    // Create a distance field from center\n    float dist = length(rotated - 0.5);\n    color *= smoothstep(0.3, 1.0, dist); // Add falloff\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1010.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-based animation parameter\n    float t = iTime * 0.5;\n    \n    // Generate animated sine wave patterns with varying frequencies\n    vec3 waves = vec3(\n        sin(uv.x * 8.0 + t) + sin(uv.y * 4.0 - t),\n        sin(uv.x * 6.0 - t*2.0) + sin(uv.y * 5.0 + t*1.5),\n        sin(uv.x * 7.0 + t*3.0) + sin(uv.y * 3.0 - t)\n    );\n    \n    // Add turbulent noise for extra detail\n    vec2 noiseUV = uv * 4.0;\n    float turbulence2D = turbulent(noiseUV);\n    float turbulence3D = turbulent(vec3(noiseUV, t));\n    \n    // Combine waves and noise with varying weights\n    float mixValue = (waves.x + waves.y + waves.z) * 0.3 + turbulence2D * 0.5 + turbulence3D * 0.2;\n    \n    // Create vibrant color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(t * 0.1, 1.0),   // Hue cycling over time\n        0.8,                 // Saturation\n        0.5 + mixValue * 0.4 // Lightness modulation\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1011.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create color wheel using HSL colors\n    vec3 color = hsl(theta / (2.0 * PI), 0.5, 0.5);\n    \n    // Add pulsating rings effect\n    float pulse = sin(iTime * 2.0) * 0.5 + 0.5;\n    float ring = abs(r - 0.5 * (1.0 + pulse)) / 0.4;\n    color.z *= 1.0 - ring; // Modulate lightness\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_1012.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a sawtooth wave pattern with frequency 5.0\n    float a = fract(iTime * 0.5 + uv.x * 5.0 + uv.y * 5.0);\n    \n    // Add noise to create variations in the shifting lines\n    float noiseValue = noise(uv * 10.0) * 0.2;\n    \n    // Create a color palette using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.1 + noiseValue) * 360.0,  // Hue\n        0.7 + noiseValue * 0.3,                     // Saturation\n        0.5 + sin(iTime) * 0.2                    // Lightness\n    ));\n    \n    // Combine the sawtooth pattern with the color palette\n    return vec4(color * (1.0 - abs(a - 0.5)), 1.0);\n}"
  },
  "data_1013.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create expanding wave pattern\n    vec2 st = uv * 5.0; // Scale coordinates\n    \n    // Polar coordinates for expansion effect\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    \n    // Add noise to create dynamic movement\n    float noiseVal = noise(vec3(r + iTime*0.5, a/PI, 0.0));\n    float wave = sin(r - iTime) * (0.5 + noiseVal*0.5);\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        a/(2.0*PI)*0.6 + 0.3, // Hue variation based on angle\n        0.7 + wave*0.3,      // Saturation modulation\n        0.5 + sin(iTime + r*10.0)*0.2 // Time-based brightness variation\n    );\n    \n    // Convert to RGB and add turbulence effect\n    vec3 color = hsl2rgb(hslColor);\n    color *= 1.0 + turbulent(uv * 4.0) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1014.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base position-dependent values\n    vec2 pos = fract(uv * 100.0);\n    \n    // Add time-based variation\n    float timeFactor = sin(iTime * 0.5 + pos.x * 10.0) * 0.5 + 0.5;\n    \n    // Combine position and time with sine functions\n    vec3 colorBase = hsl2rgb(vec3(\n        sin(pos.x * pi + iTime) * 0.5 + 0.5,\n        sin(pos.y * pi + iTime * 0.7) * 0.5 + 0.5,\n        0.8\n    ));\n    \n    // Add turbulent noise variation\n    float turb2D = turbulent(vec2(uv * 10.0 + iTime));\n    float turb3D = turbulent(vec3(uv * 10.0, iTime));\n    \n    // Combine all elements for final color\n    vec3 finalColor = mix(\n        colorBase,\n        hsl2rgb(vec3(\n            sin(iTime * 0.3 + pos.y * pi) * 0.5 + 0.5,\n            sin(pos.x * pi + iTime * 0.4) * 0.5 + 0.5,\n            0.7\n        )),\n        (turb2D + turb3D) * 0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1015.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    uv = uv * 2.0 - 1.0;\n    \n    // Convert to polar coordinates\n    float r = length(uv);\n    float a = atan2(uv.y, uv.x);\n    \n    // Create pulsating effect with time\n    r += sin(iTime * 0.5 + a) * 0.5;\n    \n    // Create rings pattern with noise and turbulence\n    float ring = sin(r * 10.0 + iTime) * 0.5 +\n                 sin(r * 20.0 + iTime * 2.0) * 0.3 +\n                 sin(r * 30.0 + iTime * 3.0) * 0.2;\n    \n    // Add movement to the rings\n    ring += turbulent(vec2(r, a + iTime)) * 0.1;\n    \n    // Create vibrant color transitions\n    vec3 color = hsl(a * 0.5 + iTime * 0.2, 1.0, 0.5);\n    \n    // Combine rings with colors\n    color = mix(vec3(0.0), color, ring * 0.5 + 0.5);\n    \n    // Add glow effect\n    if (r < 0.3) {\n        color += vec3(1.0, 0.8, 0.6) * (1.0 - r / 0.3);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1016.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * 5.0;\n    float time = iTime * 0.5;\n    \n    // Create a base pattern using noise\n    float n1 = noise(st + vec2(time, 0.0)) * 0.5 + 0.5;\n    float n2 = noise(st + vec2(0.0, time)) * 0.5 + 0.5;\n    \n    // Create a rotating pattern\n    vec2 rotatedUV = uv - 0.5;\n    rotatedUV *= mat2(cos(time), sin(time), -sin(time), cos(time));\n    rotatedUV += 0.5;\n    \n    // Add turbulence for more complexity\n    float turb = turbulent(rotatedUV * 4.0 + time) * 0.5 + 0.5;\n    \n    // Combine patterns with color shifts\n    vec3 color1 = hsl2rgb(vec3((n1 * 360.0 + time * 180.0) / 360.0, 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3((n2 * 360.0 - time * 180.0) / 360.0, 1.0, 0.5));\n    \n    // Mix colors and add depth\n    vec3 finalColor = mix(color1, color2, turb);\n    finalColor *= sin(time + uv.x * 2.0 + uv.y * 3.0) * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1017.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create a rotating pattern using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x) + time;\n    float radius = length(st);\n    \n    // Add noise and turbulence for dynamic patterns\n    float noiseVal = turbulent(vec3(uv * 5.0, time));\n    vec3 colorBase = hsl2rgb(vec3(angle * 0.1, 0.7, 0.5 + noiseVal * 0.5));\n    \n    // Create a layered effect with additional noise\n    float noiseLayer = noise(vec3(uv * 10.0 + time, 0.0)) * 0.5;\n    vec3 colorLayer = hsl2rgb(vec3(angle * 0.2 + 1.0, 0.6, 0.4 + noiseLayer));\n    \n    // Combine the layers and apply transformations\n    vec3 finalColor = mix(colorBase, colorLayer, noiseLayer);\n    finalColor *= 1.0 - radius * 0.5;\n    finalColor += vec3(noise(vec2(uv.x * 20.0 + time, uv.y * 20.0)) * 0.2);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1018.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create circular pattern by converting UV coordinates to polar\n    vec2 st = uv - 0.5;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    \n    // Animate the pattern over time\n    angle += iTime * 0.5;\n    \n    // Create sine wave patterns with different frequencies\n    float r1 = sin(radius * 3.0 + iTime) * 0.5 + 0.5;\n    float g1 = sin(angle * 5.0 + iTime * 2.0) * 0.5 + 0.5;\n    float b1 = sin((radius + angle) * 4.0 - iTime) * 0.5 + 0.5;\n    \n    // Add turbulence for dynamic variations\n    vec3 noise = vec3(turbulent(uv), turbulent(uv + 1.0), turbulent(uv + 2.0));\n    r1 += noise.x * 0.2;\n    g1 += noise.y * 0.2;\n    b1 += noise.z * 0.2;\n    \n    // Convert to HSL and back to RGB for vibrant colors\n    vec3 hslColor = vec3(\n        (r1 + g1 + b1) * 0.333,  // Hue\n        0.7,                      // Saturation\n        0.5                       // Lightness\n    );\n    \n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1019.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color with time-based shifting\n    vec3 baseColor = hsl2rgb(vec3(0.5 * sin(iTime * 0.5) + 0.5, 1.0, 0.5));\n    \n    // Add noise and turbulence for dynamic patterns\n    float noise1 = turbulent(uv * 10.0 + iTime);\n    float noise2 = turbulent((uv * 20.0 + iTime * 0.5) + noise1);\n    \n    // Combine noise layers with different frequencies\n    float combinedNoise = mix(noise1, noise2, 0.3 * sin(iTime));\n    \n    // Create color variations using HSL to RGB conversion\n    vec3 finalColor = hsl2rgb(vec3(\n        0.5 + 0.5 * sin(iTime) + combinedNoise * 0.3,\n        1.0 - abs(combinedNoise * 0.5),\n        0.5 + 0.5 * cos(iTime)\n    ));\n    \n    // Add some warping to the UV coordinates\n    vec2 warpedUV = uv + vec2(0.1, 0.1) * noise(uv * 0.5 + iTime);\n    \n    // Final color with time-based intensity modulation\n    return vec4(finalColor * (0.5 + 0.5 * sin(iTime)), 1.0);\n}"
  },
  "data_102.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating circular pattern\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    \n    // Add time-based pulsation\n    float pulse = sin(iTime * 3.0 + r * 10.0) * 0.5 + 0.5;\n    pulse += sin(iTime * 2.0 + r * 8.0) * 0.3;\n    \n    // Add noise and turbulence\n    float noiseVal = noise(uv * 4.0 + iTime);\n    noiseVal += turbulent(uv * 16.0 + iTime * 2.0) * 0.5;\n    \n    // Combine effects\n    float final = r * 3.0 - pulse * 2.0 + noiseVal * 0.4;\n    \n    // Convert to color using HSL\n    vec3 color = hsl2rgb(vec3(final * 0.6 + iTime * 0.1, 0.7, 0.5));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1020.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create dynamic color variations using sine functions and time\n    vec2 st = uv * 10.0 + sin(uv * 5.0 + iTime) * 3.0;\n    \n    // Generate smooth color transitions using HSL colorspace\n    vec3 baseColor = hsl(\n        sin(iTime * 0.5 + st.x * 2.0) * 0.5 + 0.5,\n        0.7 + sin(st.y * 3.0 + iTime * 2.0) * 0.3,\n        0.5 + turbulent(vec2(st)) * 0.4\n    );\n    \n    // Add turbulence for more dynamic movement\n    float turb = turbulent(vec2(uv * 16.0 + iTime));\n    baseColor += vec3(turb * sin(iTime) * 0.3);\n    \n    return vec4(hsl2rgb(baseColor), 1.0);\n}"
  },
  "data_1021.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec3 noise = texture(iChannel0, uv * 10.0).rgb;\n    // Dynamic sine-based color manipulation\n    vec3 color = sin(vec3(\n        time + uv.x * 2.0,\n        time + uv.y * 2.0,\n        time + uv.x + uv.y\n    )) * 0.5 + 0.5;\n    \n    // Add noise and turbulence to create variation\n    color += vec3(\n        noise.r * sin(time * 1.5),\n        noise.g * cos(time * 1.2),\n        noise.b * sin(time * 1.8)\n    ) * 0.3;\n    \n    // Create optical illusion effect with HSL conversion\n    color = hsl2rgb(vec3(\n        (uv.x + uv.y) * 0.5 + time * 0.2,\n        0.7 + sin(time * 0.8) * 0.2,\n        0.5 + cos(time * 0.6) * 0.2\n    ));\n    \n    // Add turbulence effect to UV coordinates\n    vec2 turbulentUV = uv + vec2(\n        turbulent(uv * time) * 0.1,\n        turbulent(uv * time + 1.0) * 0.1\n    );\n    \n    // Final color mix with noise\n    color = mix(color, vec3(1.0), \n                noise.r * sin(time * 2.0) * 0.5 + 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1022.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv - 0.5;\n    float radius = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create rotating color pattern using sine waves\n    vec3 color = hsl2rgb(vec3(\n        (theta * 0.16) + sin(iTime * 0.5) * 0.5,\n        0.7 + turbulent(st * 50.0) * 0.3,\n        0.5 + cos(radius * 4.0 + iTime) * 0.5\n    ));\n    \n    // Add noise variation\n    color += vec3(turbulent(vec3(st * 20.0, iTime)) * 0.1);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1023.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 centered = uv - 0.5;\n    float radius = length(centered);\n    float angle = atan2(centered.y, centered.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create RGB color cycling effect using sine functions\n    vec3 color = vec3(\n        sin(angle + iTime) * 0.5 + 0.5,\n        sin(angle + iTime + 2.0 * PI / 3.0) * 0.5 + 0.5,\n        sin(angle + iTime + 4.0 * PI / 3.0) * 0.5 + 0.5\n    );\n    \n    // Add turbulence effect to create a more dynamic pattern\n    float turbulence = turbulent(vec2(radius, angle));\n    color *= mix(1.0, abs(turbulence), 0.3);\n    \n    // Create multiple rotating wheels with different speeds and sizes\n    float wheel1 = sin(angle * 2.0 + iTime) * radius;\n    float wheel2 = sin(angle * 4.0 + iTime * 2.0) * (radius * 0.7);\n    float wheel3 = sin(angle * 6.0 + iTime * 3.0) * (radius * 0.5);\n    \n    // Combine the wheels and color\n    vec3 finalColor = mix(color, vec3(wheel1, wheel2, wheel3), smoothstep(0.0, 1.0, radius));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1024.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing pattern with turbulence and sine waves\n    vec2 st = uv * 5.0;\n    st += turbulent(st + iTime*0.5)*0.3;\n    \n    // Add oscillating sine wave patterns\n    float wave1 = sin(st.x * 2.0 + iTime) * 0.5;\n    float wave2 = sin(st.y * 2.0 + iTime*0.7) * 0.5;\n    vec2 waves = vec2(wave1, wave2);\n    \n    // Combine patterns with color\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.2 + length(st), 1.0),\n        0.8,\n        0.6\n    ));\n    \n    // Add lighting effect\n    float light = sin(length(uv - 0.5) * 4.0 + iTime*0.3);\n    color *= 1.0 + light * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1025.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating factor over time\n    float pulse = sin(iTime * 0.5 + 1.0) * 0.5 + 0.5;\n    \n    // Scale and animate coordinates\n    vec2 st = uv * (1.0 + pulse * 2.0);\n    \n    // Create lattice pattern using sine waves\n    float lines = sin(st.x * 8.0 - iTime) * 0.5 +\n                  sin(st.y * 8.0 - iTime) * 0.5;\n    \n    // Add noise for complexity\n    vec2 noiseSt = st + vec2(noise(vec3(st, iTime)) * 0.1);\n    float noiseVal = noise(noiseSt * 4.0);\n    \n    // Combine lattice and noise\n    float pattern = lines + noiseVal;\n    \n    // Create pulsating effect\n    pattern *= (1.0 + sin(iTime) * 0.5);\n    \n    // Convert to RGB with HSL color\n    vec3 color = hsl2rgb(vec3(180.0, 0.7, 0.5));\n    \n    // Create final output\n    return vec4(color, max(pattern - 0.5, 0.0) * (1.0 + sin(iTime * 0.5)));\n}"
  },
  "data_1026.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for checkerboard pattern\n    vec2 st = uv * 10.0;\n    \n    // Create rotating checkerboard patterns\n    float angle = iTime * 0.5;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedSt = rot * (st - 5.0) + 5.0;\n    \n    // Generate two different checkerboard patterns with noise\n    float pattern1 = step(0.5, fract(rotatedSt.x * 0.5) + fract(rotatedSt.y * 0.5));\n    float pattern2 = step(0.5, fract((rotatedSt.x + iTime) * 0.3) + fract((rotatedSt.y + iTime) * 0.7));\n    \n    // Mix patterns with noise and turbulence\n    float mixAmount = turbulent(vec2(st)) * 0.5 + 0.5;\n    vec3 color1 = hsl(0.6 + sin(iTime)*0.1, 0.8, 0.6);\n    vec3 color2 = hsl(0.2 + cos(iTime*0.7)*0.1, 0.8, 0.5);\n    \n    // Combine colors and patterns\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    finalColor = mix(finalColor, vec3(1.0), pattern1 * 0.4 + pattern2 * 0.6);\n    \n    // Add transparency based on time\n    float alpha = smoothstep(0.0, 1.0, sin(iTime*0.5) * 0.5 + 0.5);\n    \n    return vec4(finalColor, alpha);\n}"
  },
  "data_1027.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a pulsating wave pattern using time and position\n    float wave = sin(iTime + uv.x * 2.0 + uv.y * 3.0);\n    wave = (wave + 1.0) * 0.5; // Scale to 0-1 range\n    \n    // Add pulsation effect with time modulation\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    vec3 color = hsl2rgb(vec3(\n        (iTime * 0.1 + uv.x) * PI, // Hue based on position and time\n        1.0,                       // Saturation\n        wave * pulse               // Value modulated by pulsation\n    ));\n    \n    return vec4(color * 0.5 + 0.5, 1.0); // Add some brightness to the final color\n}"
  },
  "data_1028.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern by offsetting UV coordinates with time-based sine waves\n    vec2 st = uv * 5.0 + vec2(sin(iTime), cos(iTime)) * 3.0;\n    \n    // Add noise and turbulence to create dynamic patterns\n    float noiseValue = turbulent(st);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        fract(noiseValue + iTime),\n        0.7,\n        0.5\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1029.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a moving pattern by combining UV and time with sine functions\n    vec2 st = uv + sin(iTime * 0.5 + uv.x * pi) * 0.5;\n    \n    // Generate two different color variations using HSL\n    vec3 c1 = hsl(\n        sin(st.x * 5.0 + iTime) * 0.5 + 0.5,\n        abs(noise(vec2(uv.x, uv.y))) * 0.7 + 0.3,\n        0.6\n    );\n    \n    vec3 c2 = hsl(\n        sin(st.y * 5.0 + iTime * 3.0) * 0.5 + 0.5,\n        abs(noise(vec2(uv.y, uv.x))) * 0.7 + 0.3,\n        0.6\n    );\n    \n    // Mix the colors with a time-based blend\n    float blend = sin(iTime * 0.1 + uv.x * pi) * 0.5 + 0.5;\n    vec3 finalColor = mix(c1, c2, blend);\n    \n    return vec4(hsl2rgb(finalColor), 1.0);\n}"
  },
  "data_103.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create cellular pattern with noise and time-based animation\n    vec2 st = uv * 10.0;\n    vec2 cellCenter = fract(st - 0.5) * PI;\n    float cellDist = length(cellCenter);\n    \n    // Add noise distortion to coordinates\n    vec2 noiseCoords = uv + turbulent(vec3(uv * 2.0, iTime)) * 0.1;\n    float noiseValue = noise(noiseCoords);\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(cellDist * 0.5 + iTime * 0.1, 0.7, 0.6);\n    vec3 color2 = hsl(cellDist * 0.5 + iTime * 0.1 + PI/2.0, 0.7, 0.6);\n    \n    // Combine patterns with turbulence\n    float pattern = turbulent(vec3(uv * 4.0, iTime)) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, pattern);\n    \n    // Add depth and layers\n    vec2 cellCenter2 = fract(st - 0.5 + noiseValue) * PI;\n    float cellDist2 = length(cellCenter2);\n    finalColor += hsl(cellDist2 * 0.3 + iTime * 0.1, 0.4, 0.8) * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1030.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create spiral pattern using sine waves\n    float frequency = 5.0;\n    float spiral = sin(r * frequency + theta * 3.0) * 0.5 + 0.5;\n    \n    // Add time-based color changes\n    vec3 colorHSL = vec3(\n        sin(iTime * 0.2 + theta) * 0.5 + 0.5,  // Hue\n        0.7,                                    // Saturation\n        spiral * 0.6 + 0.4                      // Lightness\n    );\n    \n    // Convert HSL to RGB and add turbulence effect\n    vec3 rgbColor = hsl2rgb(colorHSL);\n    float turb = turbulent(vec2(r * frequency, iTime * 0.1));\n    rgbColor *= mix(0.8, 1.2, turb);\n    \n    // Add noise for extra detail\n    vec2 noiseUV = uv * 5.0 + iTime;\n    float noiseVal = noise(noiseUV) * 0.3;\n    rgbColor += noiseVal;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1031.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates and convert to polar coordinates\n    vec2 centeredUV = uv * 2.0 - 1.0;\n    float radius = length(centeredUV);\n    \n    // Create a rotating pattern using time\n    float angle = atan2(centeredUV.y, centeredUV.x) + iTime * 0.5 + radius * 0.5;\n    \n    // Generate RGB values from the angle\n    vec3 color;\n    color.r = sin(angle + 0.0);\n    color.g = sin(angle + 2.094); // 120 degrees in radians (2pi/3)\n    color.b = sin(angle + 4.188); // 240 degrees in radians (4pi/3)\n    \n    // Scale colors by radius to create a circular pattern\n    color *= radius * 0.5 + 0.5;\n    \n    // Add some turbulence for extra visual interest\n    float turb = turbulent(uv * 10.0 + iTime);\n    color += turb * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1032.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation and expansion\n    angle += iTime * 0.5;\n    radius *= sin(iTime) * 0.5 + 0.75;\n    \n    // Create expanding rings pattern\n    float ring = mod(radius * 10.0, 2.0);\n    vec3 color = hsl(angle / (2.0 * PI), 0.6, 0.5);\n    \n    // Add turbulence for dynamic movement\n    vec2 noiseUV = uv + vec2(iTime) * 0.5;\n    float turb = turbulent(noiseUV * 10.0);\n    \n    // Combine patterns and colors\n    color *= hsl2rgb(vec3(ring, 0.8, 0.7));\n    color += turb * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1033.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Combine time with pixel position for dynamic patterns\n    vec3 p = vec3(uv * 2.0 - 1.0, sin(iTime * 0.5));\n    \n    // Generate noise values at different scales\n    float n1 = noise(p);\n    float n2 = noise(p * 10.0 + iTime);\n    float t = turbulent(p * 3.0 + iTime);\n    \n    // Create pulsating color shifts using HSL\n    vec3 hslColor = vec3(\n        (n1 + sin(iTime) * 0.5 + 0.5) * 240.0,  // Hue variation over time and space\n        abs(n2) * 0.7 + 0.3,                       // Saturation modulation\n        abs(t) * 0.6 + 0.4                         // Brightness pulsation\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1034.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create undulating sine wave patterns\n    float wave1 = sin(uv.x * 8.0 + iTime * 2.0) * 0.5;\n    float wave2 = cos(uv.y * 6.0 - iTime * 3.0) * 0.4;\n    \n    // Combine waves and add turbulence\n    float height = wave1 + wave2 + turbulent(vec3(uv, iTime)) * 0.2;\n    \n    // Create smooth color transitions using HSL\n    vec3 colorHSL = vec3(\n        mod(iTime * 0.1 + uv.x * 0.5 + uv.y * 0.7, 1.0),  // Hue\n        0.6 + abs(sin(iTime * 0.2)) * 0.4,                  // Saturation\n        0.5 + height * 0.3                                 // Lightness\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(colorHSL), 1.0);\n}"
  },
  "data_1035.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 uv_centered = uv * 2.0 - 1.0;\n    float r = length(uv_centered);\n    float theta = atan2(uv_centered.y, uv_centered.x);\n    // Add rotation based on time\n    theta += iTime * 1.5;\n    // Create smooth color transitions using HSL\n    vec3 hsl_color = vec3(\n        theta / (pi * 2.0),\n        0.7,\n        pow(r, 2.0) * 0.6 + 0.4\n    );\n    // Convert HSL to RGB and add noise for texture\n    vec3 color = hsl2rgb(hsl_color);\n    color += noise(uv * 100.0 + iTime) * 0.05;\n    return vec4(clamp(color, 0.0, 1.0), 1.0);\n}"
  },
  "data_1036.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating RGB sine waves with time-based animation\n    float t = iTime * 0.5;\n    \n    // Calculate base sine wave patterns for each color channel\n    vec3 rgb = vec3(\n        sin(uv.x * 10.0 + t) * 0.5 + 0.5,\n        cos(uv.y * 10.0 + t + 120.0) * 0.5 + 0.5,\n        sin(uv.x * uv.y * 10.0 + t + 240.0) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence for dynamic effect\n    vec2 st = uv * 10.0;\n    float n = noise(st + vec2(t)) * 0.3;\n    rgb += n;\n    \n    // Create rotating pattern by mixing colors with time offset\n    rgb = vec3(\n        rgb.r * sin(t) + rgb.g * cos(t),\n        rgb.g * sin(t) + rgb.b * cos(t + 120.0),\n        rgb.b * sin(t + 240.0) + rgb.r * cos(t)\n    );\n    \n    return vec4(rgb, 1.0);\n}"
  },
  "data_1037.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying coordinates\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Generate multiple sine wave layers with varying frequencies and phases\n    float pattern = 0.0;\n    for (int i = 1; i <= 4; i++) {\n        float freq = pow(2.0, float(i));\n        float amp = 0.5 / freq;\n        pattern += sin(st.x * freq + iTime) * amp;\n        pattern += sin(st.y * freq + iTime * 0.5 + float(i)) * amp;\n    }\n    \n    // Add noise and turbulence\n    vec2 noiseSt = uv * 10.0 + iTime * 0.5;\n    float noiseVal = noise(noiseSt);\n    pattern += turbulent(noiseSt) * 0.3;\n    \n    // Create RGB cycling effect\n    float hue = fract(iTime * 0.1 + st.x * 0.2 + st.y * 0.3) * PI * 2.0;\n    vec3 color = hsl(hue, 0.8, 0.6);\n    \n    // Combine pattern with color\n    float finalPattern = (pattern + noiseVal) * 0.5 + 0.5;\n    color *= finalPattern;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1038.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create multiple layers of stars for depth effect\n    for(float i = 1.0; i < 6.0; i++) {\n        float scale = pow(2.0, i * 2.0); // Exponential scaling for star field layers\n        \n        // Add noise and turbulence to create organic movement\n        vec3 noiseOffset = vec3(turbulent(uv * scale + iTime), turbulent(uv * scale + iTime + 1.0), 0.0);\n        \n        // Calculate distance from center with pulsing effect\n        float dist = length(uv * scale + noiseOffset.xy * 0.5) * 0.7;\n        dist += sin(dist * 2.0 + iTime) * 0.3; // Add pulsing animation\n        \n        // Create star glow effect using HSL color space\n        vec3 starColor = hsl(\n            fract(iTime * 0.1 + dist * 0.5), // Hue variation over time and distance\n            1.0, // Full saturation for vibrant stars\n            max(0.0, sin(dist * 2.0 - iTime) * 0.5 + 0.5) // Pulsing brightness\n        );\n        \n        // Combine star layers with additive blending\n        color += hsl2rgb(starColor) * (1.0 / scale);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1039.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate the pattern over time\n    float time = iTime * 0.5;\n    \n    // Create a rotating pattern by transforming UV coordinates\n    vec2 st = uv * 10.0 + time;\n    st = (st - 0.5) * mat2(cos(time), sin(time), -sin(time), cos(time)) + 0.5;\n    \n    // Add noise and turbulence to create a dynamic pattern\n    float n1 = noise(st);\n    float n2 = noise(st * 2.0 + time);\n    float n3 = noise(st * 4.0 + time * 2.0);\n    \n    // Combine noise layers with different frequencies\n    float value = (n1 + n2 * 0.5 + n3 * 0.25) * 0.5 + 0.5;\n    \n    // Create a color palette using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        fract((st.x + st.y) * 4.0 + time),  // Hue\n        1.0,                                 // Saturation\n        value                                // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_104.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing patterns using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based animation\n    angle += iTime * 0.5;\n    radius *= 0.75;\n    \n    // Create turbulence effect\n    vec3 pos = vec3(uv * 10.0 + iTime, iTime * 0.25);\n    float turb = turbulent(pos) * 0.5 + 0.5;\n    \n    // Generate color using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        fract(angle * 0.1 + iTime * 0.2),\n        0.7 + turb * 0.3,\n        0.8 + sin(radius * 4.0 + iTime) * 0.2\n    );\n    \n    // Convert to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1040.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of points using UV coordinates\n    vec2 st = uv * 10.0;\n    vec2 ipos = floor(st);\n    \n    // Animate the grid over time\n    float time = iTime * 0.5;\n    vec2 pos = sin(vec2(time + ipos.x, time*0.7 + ipos.y)) * 0.5 + 0.5;\n    \n    // Calculate distance from center\n    vec2 center = vec2(0.5);\n    float dist = length(pos - center);\n    \n    // Create color transitions using HSL\n    vec3 color = hsv2rgb(vec3(\n        (dist * 0.7 + time) * 180.0,\n        0.6 + turbulent(vec3(st, time)) * 0.4,\n        0.5 + sin(time + dist * 10.0) * 0.5\n    ));\n    \n    // Add noise and turbulence for more detail\n    float noiseVal = noise(vec2(pos.x*10.0, pos.y*10.0)) * 0.3;\n    color *= 1.0 + noiseVal;\n    \n    // Create particle effect with alpha based on distance\n    float alpha = smoothstep(0.8, 1.0, 1.0 - dist);\n    alpha *= 0.5 + turbulent(st) * 0.5;\n    \n    return vec4(color, alpha);\n}"
  },
  "data_1041.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Create cell coordinates\n    vec2 cell = floor(st);\n    vec2 pos = fract(st);\n    \n    // Add time-based movement\n    float time = iTime * 0.5;\n    \n    // Calculate noise values for each cell\n    float n1 = turbulent(vec3(cell + time, 0.0));\n    float n2 = turbulent(vec3(cell - time, 0.0));\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(n1 * 0.5 + 0.5, 0.8, 0.6);\n    vec3 color2 = hsl(n2 * 0.5 + 0.5, 0.8, 0.4);\n    \n    // Interpolate between colors based on position\n    vec3 finalColor = mix(color1, color2, pos.x);\n    \n    // Add dynamic movement using sin function\n    float movement = sin(time + cell.x * 0.5) * 0.5 + 0.5;\n    finalColor *= movement;\n    \n    // Convert HSL to RGB for output\n    vec3 rgbColor = hsl2rgb(finalColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1042.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate coordinates over time\n    vec2 st = uv * 5.0 + vec2(sin(iTime), cos(iTime)) * 3.0;\n    \n    // Create flowing sine wave pattern with multiple frequencies\n    float wave1 = sin(st.x * 2.0 + iTime) * 0.5;\n    float wave2 = sin(st.y * 3.0 + iTime * 0.5);\n    float pattern = (wave1 + wave2) * 0.5 + 0.5;\n    \n    // Add noise for organic feel\n    vec2 noiseUV = uv * 4.0 + vec2(iTime * 0.5, 0.0);\n    float noiseVal = noise(noiseUV) * 0.3;\n    pattern += noiseVal;\n    \n    // Create dynamic color transitions using HSV\n    vec3 hsvColor = vec3(\n        fract(pattern + iTime * 0.1),   // Hue variation over time\n        0.8,                            // Saturation\n        pattern                         // Value tied to pattern intensity\n    );\n    vec3 rgbColor = hsv2rgb(hsvColor);\n    \n    // Add turbulence for more complex movement\n    vec3 turbPos = vec3(uv * 10.0 + iTime, 0.0);\n    float turb = turbulent(turbPos) * 0.5;\n    pattern += turb;\n    \n    // Final color with alpha\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1043.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Create pulsating effect using sine wave\n    float pulse = sin(iTime * 0.5 + length(st)) * 0.5 + 0.5;\n    \n    // Calculate cell position in grid\n    vec2 cell = floor(st);\n    \n    // Generate vibrant colors using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3((cell.x + cell.y) * 0.1 + iTime * 0.2, 0.8, 0.6));\n    vec3 color2 = hsl2rgb(vec3((cell.x - cell.y) * 0.1 + iTime * 0.3, 0.7, 0.5));\n    \n    // Mix colors based on pulsation\n    vec3 finalColor = mix(color1, color2, pulse);\n    \n    // Add noise for extra texture\n    float noiseValue = noise(st * 0.5 + iTime) * 0.2;\n    finalColor += noiseValue;\n    \n    // Create grid lines with pulsating width\n    float line = sin(iTime + length(cell)) * 0.3 + 0.7;\n    if (fract(st.x) < line || fract(st.y) < line) {\n        finalColor *= 1.5; // Brighten grid lines\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1044.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Get cell position in grid\n    vec2 pos = fract(st);\n    \n    // Add noise and time variation\n    float noiseVal = turbulent(pos + iTime*0.5);\n    \n    // Create pulsating color pattern using HSL\n    vec3 hslColor = vec3(\n        (pos.x + pos.y) * 0.5,   // Hue varies across grid\n        1.0,                     // Full saturation\n        0.5 + sin(iTime + pos.x*2.0 + pos.y*3.0)*0.4  // Pulsating lightness\n    );\n    \n    // Convert to RGB and add noise effect\n    vec3 rgb = hsl2rgb(hslColor) * (1.0 + noiseVal*0.5);\n    \n    // Combine colors with some blending\n    vec3 finalColor = rgb * sin(iTime*0.5 + pos.x*4.0 + pos.y*6.0)*0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1045.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsing circles using sine waves\n    float time = iTime * 0.5;\n    \n    // Calculate distance from center\n    vec2 pos = uv - 0.5;\n    float r = length(pos);\n    \n    // Create multiple layers of pulsing circles\n    float c1 = sin(r * 2.0 + time) * 0.5;\n    float c2 = sin(r * 3.0 + time * 2.0) * 0.4;\n    float c3 = sin(r * 4.0 + time * 3.0) * 0.3;\n    \n    // Combine layers and add pulsing effect\n    float c = abs(c1 + c2 + c3);\n    c *= sin(r * 50.0 + time) * 0.5;\n    \n    // Convert to color using HSL\n    float hue = sin(time + r * 20.0) * 0.5 + 0.5;\n    vec3 col = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Add noise for extra texture\n    col += vec3(noise(uv * 20.0 + time) * 0.1);\n    \n    return vec4(col, 1.0);\n}"
  },
  "data_1046.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using sine functions\n    vec2 st = uv * 10.0;\n    float time = iTime * 0.5;\n    \n    // Add noise and turbulence\n    vec3 noisePattern = vec3(\n        noise(st + time),\n        noise(st + time * 0.7 + 100.0),\n        noise(st + time * 0.4 + 200.0)\n    );\n    \n    // Create geometric patterns with smooth transitions\n    float pattern = sin(st.x * 0.5 + time) * cos(st.y * 0.5) +\n                   sin(st.y * 0.7 + time * 0.6) * cos(st.x * 0.3);\n    \n    // Add turbulence to create dynamic movement\n    pattern += turbulent(vec2(st.x * 0.1, st.y * 0.1)) * 0.5;\n    \n    // Generate vibrant colors using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        fract(time * 0.2) * 360.0,\n        0.7 + noisePattern.x * 0.3,\n        0.5 + pattern * 0.4\n    ));\n    \n    // Create a glowing effect by adding brightness\n    float glow = smoothstep(0.0, 1.0, sin(pattern * 2.0 + time));\n    color *= glow;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1047.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color;\n    color.r = sin(uv.x * 40.0 + iTime) * 0.5 + 0.5;\n    color.g = sin(uv.y * 40.0 + iTime * 2.0) * 0.5 + 0.5;\n    color.b = sin((uv.x + uv.y) * 30.0 + iTime * 3.0) * 0.5 + 0.5;\n    return vec4(color, 1.0);\n}"
  },
  "data_1048.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using sine functions\n    float pattern = sin(uv.x * 10.0 + iTime * 2.0) +\n                    sin(uv.y * 10.0 + iTime * 3.0) +\n                    sin((uv.x + uv.y) * 5.0 + iTime * 4.0);\n    \n    // Add some turbulence for more dynamic movement\n    vec2 st = uv * 10.0;\n    float turb = turbulent(st + vec2(iTime, 0.0)) * 0.5;\n    \n    // Combine pattern and turbulence\n    float value = (pattern * 0.3) + turb;\n    \n    // Create vibrant colors using HSL to RGB conversion\n    vec3 color = hsl(\n        sin(value * 10.0 + iTime) * 0.5 + 0.5,  // Hue variation\n        0.8,                                      // Saturation\n        0.5                                       // Lightness\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1049.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate rotation based on time\n    float angle = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(angle)*uv.x - sin(angle)*uv.y,\n        sin(angle)*uv.x + cos(angle)*uv.y\n    ) * 0.8 + 0.5;\n    // Create a pattern with noise and turbulence\n    float noiseValue = turbulent(rotatedUv * 4.0);\n    vec3 color = hsl2rgb(vec3(0.6, 0.7, 0.5));\n    \n    // Add variation based on noise\n    color *= mix(1.0, 1.5, noiseValue);\n    color += vec3(turbulent(rotatedUv * 8.0) * 0.2);\n    // Brightness modulation over time\n    float brightness = sin(iTime * 0.7 + PI) * 0.5 + 0.5;\n    color *= mix(1.0, 1.3, brightness);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_105.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying component\n    float time = iTime * 0.1;\n    \n    // Scale coordinates for different color channels\n    vec2 scaleR = uv * 10.0;\n    vec2 scaleG = uv * 8.0;\n    vec2 scaleB = uv * 6.0;\n    \n    // Generate noise values with time offset\n    float rNoise = turbulent(scaleR + time);\n    float gNoise = turbulent(scaleG + time * 2.0);\n    float bNoise = turbulent(scaleB + time * 3.0);\n    \n    // Create a base color that shifts over time\n    vec3 baseColor = hsl2rgb(vec3(\n        uv.x + uv.y + time,\n        1.0,\n        0.5\n    ));\n    \n    // Combine noise with color and position\n    vec3 finalColor = vec3(\n        baseColor.r * (rNoise * 0.6 + 0.4),\n        baseColor.g * (gNoise * 0.6 + 0.4),\n        baseColor.b * (bNoise * 0.6 + 0.4)\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1050.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 rgb = vec3(0.0);\n    \n    // Create dynamic sine wave patterns\n    float timeSine = sin(iTime * 0.5);\n    float pattern1 = sin(uv.x * 8.0 + iTime) * 0.5 + 0.5;\n    float pattern2 = sin(uv.y * 4.0 + iTime * 0.7) * 0.5 + 0.5;\n    \n    // Add turbulence for more complex patterns\n    float turb = turbulent(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    \n    // Combine patterns with color transformations\n    rgb.r += pattern1 * (sin(iTime) * 0.5 + 0.5);\n    rgb.g += pattern2 * (cos(iTime) * 0.5 + 0.5);\n    rgb.b += turb * 0.3;\n    \n    // Add noise for texture\n    vec3 noiseColors = vec3(\n        noise(uv + sin(iTime)),\n        noise(uv * 2.0 + iTime),\n        noise(uv * 3.0 - iTime)\n    );\n    \n    // Mix colors and add noise\n    rgb = mix(rgb, noiseColors, 0.3);\n    \n    // Convert to HSL for better color control\n    vec3 hslColor = hsl(\n        (uv.x + uv.y) * pi,\n        sin(iTime * 0.5) * 0.5 + 0.5,\n        turb * 0.7 + 0.3\n    );\n    \n    // Combine both color approaches\n    rgb = mix(rgb, hsl2rgb(hslColor), 0.6);\n    \n    return vec4(hsv2rgb(vec3(\n        (uv.x + uv.y) * pi,\n        sin(iTime * 0.5) * 0.5 + 0.5,\n        turb * 0.7 + 0.3\n    )), 1.0);\n}"
  },
  "data_1051.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 centeredUV = uv * 2.0 - 1.0;\n    float theta = atan2(centeredUV.y, centeredUV.x);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor;\n    hslColor.x = mod(theta + iTime * 0.5, PI * 2.0) / (PI * 2.0);\n    hslColor.y = 1.0; // Full saturation\n    \n    // Add pulsing effect to lightness\n    float pulse = sin(iTime * 0.5) * 0.3 + 0.7;\n    hslColor.z = pulse * (length(centeredUV) * 3.0 + 1.0);\n    \n    // Convert HSL to RGB and return\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1054.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Create grid lines using sine functions\n    float xLine = sin(st.x + iTime) * 0.5 + 0.5;\n    float yLine = sin(st.y + iTime) * 0.5 + 0.5;\n    \n    // Combine lines and add turbulence\n    float grid = min(xLine, yLine);\n    grid += turbulent(vec2(uv * 10.0 + iTime));\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.5 + st.x) * 0.5 + 0.5,\n        0.7,\n        0.6\n    ));\n    \n    return vec4(color * grid, 1.0);\n}"
  },
  "data_1055.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float a = atan(st.y, st.x);\n    float r = length(st);\n    \n    // Add rotation based on time\n    a += iTime * 0.5; // Speed of rotation\n    \n    // Create geometric pattern using sine waves\n    float pattern = sin(a) * 4.0;\n    pattern = abs(pattern);\n    \n    // Add turbulence for dynamic effect\n    vec2 noiseUV = uv * 100.0 + iTime * 0.5;\n    float turb = turbulent(noiseUV);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 color;\n    color.x = sin(iTime * 0.2 + a) * 0.5 + 0.5; // Hue variation\n    color.y = 1.0; // Saturation\n    color.z = abs(sin(r * 4.0 + iTime)); // Lightness variation\n    \n    // Convert HSL to RGB and mix with turbulence\n    vec3 finalColor = hsl2rgb(color) * (1.0 - turb * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1056.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Base color transition using time and position\n    vec3 color = hsl(\n        sin(time + uv.x * 10.0) * 0.5 + 0.5,\n        0.7,\n        0.6\n    );\n    \n    // Add dynamic noise pattern\n    float noiseScale = 4.0;\n    vec2 noisePos = uv * noiseScale + time;\n    float noiseValue = noise(noisePos);\n    \n    // Create pulsing effect using turbulence\n    float pulse = turbulent(vec3(uv * 10.0, time)) * 0.5 + 0.5;\n    \n    // Combine effects with color transformation\n    vec3 finalColor = hsl2rgb(\n        vec3(\n            (color.r + noiseValue) * 0.5,\n            color.g + pulse * 0.3,\n            color.b + sin(time) * 0.2\n        )\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1057.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Transform UV coordinates to range [-1,1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create rotating pattern using time\n    float angle = iTime * 0.5;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle),\n                         sin(angle), cos(angle));\n                         \n    // Apply rotation and mix with noise\n    vec2 rotated = rotMatrix * st;\n    float noiseVal = turbulent(rotated * 4.0 + iTime) * 0.5 + 0.5;\n    \n    // Calculate distance from center\n    float dist = length(st);\n    \n    // Create color based on position and time\n    vec3 color = hsl2rgb(vec3(\n        (dist * 0.6 + noiseVal * 0.4) * 360.0,\n        0.7,\n        0.5 + sin(iTime) * 0.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1058.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation and scaling\n    theta += iTime * 0.5;\n    st.x *= cos(theta) * (1.0 + sin(iTime * 0.3));\n    st.y *= sin(theta) * (1.0 + cos(iTime * 0.3));\n    // Create color variations using noise and time\n    vec2 noiseCoords = st * 5.0;\n    float n = noise(noiseCoords);\n    \n    // Generate RGB colors with shifting hues\n    vec3 color1 = hsl2rgb(vec3(0.5 + sin(iTime * 0.2) * 0.5, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.7 + cos(iTime * 0.3) * 0.5, 1.0, 0.6));\n    \n    // Mix colors based on noise and position\n    vec3 finalColor = mix(color1, color2, n);\n    finalColor *= sin(r * 8.0 + iTime) * 0.5 + 0.5;\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1059.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Rotate over time\n    \n    // Create color wheel with HSL colors\n    vec3 colorWheel = hsl(theta / (2.0 * PI), 1.0 - 0.5*r, 0.5);\n    \n    // Add pulsing center effect\n    float pulse = sin(iTime) * 4.0;\n    float radial = r + turbulent(vec3(st.x, st.y, iTime)) * 0.2;\n    vec3 colorPulse = hsl(0.5, 1.0 - abs(radial - 0.5 - pulse), 0.5);\n    \n    // Combine effects\n    vec3 finalColor = mix(colorWheel, colorPulse, smoothstep(0.7, 1.0, r));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_106.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 pos = uv * 4.0 - 1.0;\n    float time = iTime * 0.5;\n    \n    int max_steps = 100;\n    int steps = 0;\n    float trap = 0.1;\n    vec3 color = vec3(0.0);\n    \n    while (steps < max_steps) {\n        pos.x += sin(time + pos.y * 2.0) * 0.5;\n        pos.y += cos(time - pos.x * 2.0) * 0.5;\n        \n        float noise_val = noise(vec3(pos, time));\n        pos *= 1.0 + noise_val * 0.2;\n        \n        if (length(pos) < trap) {\n            color = hsl(float(steps)/float(max_steps), 1.0, 0.5);\n            break;\n        }\n        \n        steps++;\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1060.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 center = vec2(0.5);\n    float r = length(uv - center);\n    float theta = atan2(uv.y - center.y, uv.x - center.x);\n    \n    // Add rotation over time\n    theta += iTime * 2.0 + sin(iTime) * 0.5;\n    \n    // Create color based on polar coordinates and time\n    vec3 color = hsl2rgb(vec3(\n        (theta / (pi * 2.0)) + iTime,\n        1.0,\n        0.5 + turbulent(vec2(r, theta)) * 0.5\n    ));\n    \n    // Add noise variation\n    float noiseFactor = turbulent(vec2(uv * 4.0));\n    color = mix(color, hsl2rgb(vec3(\n        (r / 2.5) + iTime,\n        1.0,\n        0.5\n    )), noiseFactor);\n    \n    // Add brightness variation\n    float brightness = sin(iTime) * 0.5 + 0.7;\n    color *= brightness;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1061.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create multiple overlapping sine wave layers with different frequencies\n    float freq1 = sin(uv.x * 8.0 + iTime * 2.0) * 0.5 + 0.5;\n    float freq2 = sin(uv.y * 4.0 + iTime * 3.0 + pi) * 0.5 + 0.5;\n    float freq3 = sin((uv.x + uv.y) * 16.0 + iTime * 5.0) * 0.5 + 0.5;\n    \n    // Combine frequencies with noise and turbulence\n    float pattern = (freq1 + freq2 + freq3) / 3.0;\n    pattern += turbulent(uv * 4.0 + vec2(iTime)) * 0.3;\n    pattern = mod(pattern, 1.0);\n    \n    // Create shifting RGB colors using HSL\n    float hue = iTime * 0.1 + noise(vec3(uv * 4.0, iTime)) * 0.5;\n    vec3 hslColor = vec3(hue, 1.0, pattern);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Mix colors from different layers\n    color += rgbColor * (pattern * 0.6 + 0.4);\n    color += vec3(sin(iTime) * 0.5 + 0.5) * (1.0 - pattern);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1062.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying coordinates\n    vec2 st = uv * 5.0 + vec2(sin(iTime)*3.0, cos(iTime*0.7)*2.0);\n    \n    // Add multiple sine waves with different frequencies\n    float wave1 = sin(st.x + iTime) * 0.5;\n    float wave2 = sin(st.y + iTime*0.5) * 0.3;\n    float wave3 = sin(st.x*2.0 - iTime) * 0.4;\n    \n    // Combine waves and add turbulence\n    float noiseVal = noise(vec2(st.x, st.y)) * 0.3;\n    noiseVal += turbulent(vec2(st.x*0.5 + iTime, st.y*0.7));\n    \n    // Create color from HSL values\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime*0.3)*0.5 + 0.5,\n        0.8,\n        0.6\n    ));\n    \n    // Mix noise with color and create final output\n    vec3 finalColor = mix(color, vec3(noiseVal), abs(sin(iTime))*0.4);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1063.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Offset UV coordinates based on time for rotation effect\n    vec2 offset = vec2(sin(iTime), cos(iTime)) * 0.5;\n    vec2 st = uv + offset;\n    \n    // Create a base color using HSL with time-based hue\n    vec3 color = hsl(st.x * pi + iTime, 1.0, 0.5);\n    \n    // Add turbulent noise to create dynamic variations\n    float noiseValue = turbulent(vec2(st.x * 100.0, st.y * 100.0));\n    color += vec3(noiseValue * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1064.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates with time\n    vec2 st = uv * 10.0 + sin(iTime * 0.5) * 3.0;\n    \n    // Create a base pattern using noise and turbulence\n    float noiseValue = noise(st * 0.5) * 0.5 + turbulent(st * 0.25);\n    \n    // Generate color components with smooth transitions\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.1 + st.x * 0.2) * 0.5 + 0.5,\n        abs(sin(iTime * 0.2 + st.y * 0.3)) * 0.7 + 0.3,\n        noiseValue * 0.5 + 0.5\n    ));\n    \n    // Add dynamic movement using sine functions\n    color *= sin(iTime * 0.1 + uv.x * 8.0) * 0.5 + 0.5;\n    color += turbulent(vec2(uv.x * 4.0, iTime)) * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1065.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 centeredUv = uv - 0.5;\n    \n    // Calculate distance from center and scale it\n    float dist = length(centeredUv) * 2.0;\n    \n    // Add pulsation effect using time\n    float t = iTime * 0.5;\n    dist += sin(t) * 0.3 + cos(t * 1.5) * 0.2;\n    \n    // Apply turbulence to create dynamic variations\n    vec2 noiseCoords = vec2(dist, t);\n    dist += turbulent(noiseCoords) * 0.1;\n    \n    // Create color transitions using HSL\n    float hue = t * 2.0 + dist * 5.0;\n    hue += sin(t + dist * 3.14) * 0.5;\n    \n    vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Blend colors for smoother transitions\n    float blend = smoothstep(0.0, 1.0, sin(t + dist * 2.0) * 0.5 + 0.5);\n    color = mix(color, hsl2rgb(vec3(hue + 1.0, 1.0, 0.5)), blend);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1066.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Combine UV with time-based sine waves\n    vec2 st = uv;\n    float time = iTime * 0.5;  // Scale time for slower movement\n    \n    // Create flowing patterns using sine waves\n    vec2 flow = vec2(\n        sin(st.x * 10.0 + time) * 0.5,\n        sin(st.y * 10.0 + time + pi) * 0.5\n    );\n    \n    // Add turbulence to create more dynamic movement\n    float turb = turbulent(st * 10.0 + flow * 2.0);\n    \n    // Combine with noise for texture\n    vec3 color = hsl(\n        sin(time * 0.2) * 0.5 + 0.5,  // Hue variation over time\n        0.7 + turb * 0.3,            // Saturation influenced by turbulence\n        0.5                         // Lightness\n    );\n    \n    // Final color with noise modulation\n    float n = noise(st * 10.0 + flow);\n    return vec4(color * (n * 0.5 + 0.5), 1.0);\n}"
  },
  "data_1067.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += iTime * 0.5 + noise(vec3(uv * 10.0, iTime)) * 0.2;\n    // Create hexagonal grid pattern\n    vec2 grid = vec2(sin(theta), cos(theta));\n    grid *= 4.0;\n    grid.x += sin(iTime) * 2.0;\n    grid.y += cos(iTime) * 2.0;\n    \n    // Calculate distance to nearest grid point\n    vec2 ipos = floor(grid);\n    vec2 fpos = fract(grid);\n    float d = min(min(length(fpos - vec2(0.5)), length(fpos - vec2(1.0, 0.5))), \n                  min(length(fpos - vec2(0.0, 0.5)), length(fpos - vec2(0.5, 1.0))));\n    // Create hexagon shape\n    float hex = smoothstep(0.4, 0.6, d);\n    \n    // Calculate color based on rotation and time\n    vec3 color = hsl(theta * 0.5 + iTime * 0.2, 0.7, 0.5);\n    color = hsl2rgb(color);\n    // Apply noise to color for dynamic effects\n    float n = noise(vec3(uv * 10.0, iTime)) * 0.3;\n    color += n;\n    return vec4(hex * color, 1.0);\n}"
  },
  "data_1068.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Offset UV coordinates based on time\n    vec2 st = uv - 0.5;\n    \n    // Create rotation effect using sine and cosine of time\n    float angle = sin(iTime * 0.5);\n    float rotate_x = cos(angle) * st.x + (-sin(angle)) * st.y;\n    float rotate_y = sin(angle) * st.x + cos(angle) * st.y;\n    \n    // Scale coordinates for better pattern distribution\n    vec2 scaled_uv = vec2(rotate_x, rotate_y) * 4.0;\n    \n    // Add time-based offset to create movement\n    scaled_uv += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    // Use turbulent noise to add complexity\n    float noise_val = turbulent(scaled_uv);\n    \n    // Create color transitions using HSL\n    vec3 hsl_color = vec3(\n        fract(noise_val + iTime) * 0.5,  // Hue variation over time\n        0.7,                              // Saturation\n        0.6                               // Lightness\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hsl_color), 1.0);\n}"
  },
  "data_1069.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Time-based rotation angle\n    float timeAngle = iTime * 0.1;\n    \n    // Mouse-controlled rotation (assuming mouse data is passed via another uniform)\n    // For this example, we'll use time instead of actual mouse input\n    float mouseAngle = iTime * 0.5; \n    \n    // Combine rotation angles\n    float angle = timeAngle + mouseAngle;\n    \n    // Create rotating coordinate system\n    vec2 rotatedSt = vec2(\n        st.x * cos(angle) - st.y * sin(angle),\n        st.x * sin(angle) + st.y * cos(angle)\n    );\n    \n    // Calculate distance from lines at different angles\n    float d1 = abs(sin(rotatedSt.x * 5.0 + iTime) * 0.5 + 0.5);\n    float d2 = abs(cos(rotatedSt.y * 5.0 - iTime) * 0.5 + 0.5);\n    \n    // Combine distances with noise\n    float combinedDist = min(d1, d2) + turbulent(vec3(st, iTime)) * 0.2;\n    \n    // Create line pattern with varying thickness\n    float linePattern = smoothstep(0.4, 0.6, combinedDist);\n    \n    // Generate color based on angle and time\n    vec3 colorHSL = vec3(\n        atan2(rotatedSt.y, rotatedSt.x) * 0.5 + iTime,\n        0.7,\n        0.8\n    );\n    \n    // Convert to RGB and apply pattern\n    vec3 finalColor = hsl2rgb(colorHSL) * linePattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_107.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Normalize UV coordinates to -1..1 range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Convert to polar coordinates\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Create orbit trap effect using multiple layers\n    vec3 color = vec3(0.0);\n    for(int i = 0; i < 4; i++) {\n        // Rotate and scale each layer\n        angle += iTime * 0.2;\n        radius *= 1.5;\n        \n        // Apply noise-based perturbation\n        vec2 pos = vec2(cos(angle), sin(angle)) * radius;\n        float n = noise(vec3(pos, iTime));\n        \n        // Create geometric trap pattern\n        float d = abs(length(pos) - 0.5);\n        float trap = smoothstep(0.1, 0.0, d);\n        \n        // Mix colors based on proximity to trap\n        color += mix(vec3(0.0), hsl2rgb(vec3(iTime + angle * 2.0, 1.0, 0.5)), trap);\n    }\n    \n    // Add turbulence effect\n    vec2 noisePos = uv * 4.0;\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    color *= turb;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1070.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal pattern\n    float radius = length(uv * 0.5);\n    float angle = atan2(uv.y, uv.x);\n    \n    // Create pulsating effect using time and radius\n    float pulse = sin(iTime + radius * 10.0) * 0.5 + 0.5;\n    \n    // Generate hexagonal pattern by repeating every 60 degrees (pi/3 radians)\n    angle = mod(angle, pi / 3.0);\n    \n    // Create color shifts using HSL\n    vec3 colorHSL = vec3(\n        mod(angle * 180.0 / pi + iTime * 2.0, 360.0) / 360.0,\n        0.7,\n        pulse\n    );\n    \n    // Convert to RGB and add noise for more dynamic effect\n    vec3 color = hsl2rgb(colorHSL);\n    color += turbulent(uv * 10.0) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1071.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base frequency using UV coordinates and time\n    float freq = 4.0 * pi;\n    \n    // Create undulating patterns using sine functions\n    float pattern1 = sin(uv.x * freq + iTime * 2.0);\n    float pattern2 = sin(uv.y * freq - iTime * 2.0);\n    \n    // Combine the patterns with noise for more complexity\n    float combined = (pattern1 + pattern2) / 2.0;\n    combined += turbulent(vec3(uv, iTime)) * 0.5;\n    \n    // Create a color gradient using HSL conversion\n    vec3 color = hsl(\n        fract(combined * 0.5 + iTime * 0.1) * 360.0,\n        0.7,\n        0.5\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_1072.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add time variation\n    vec2 st = uv * 8.0 + sin(iTime * 0.5) * 3.0;\n    \n    // Create RGB values from sine functions with different frequencies\n    float r = sin(st.x * 0.5 + iTime) * 0.5 + 0.5;\n    float g = sin(st.y * 0.7 - iTime * 0.3) * 0.5 + 0.5;\n    float b = sin((st.x + st.y) * 0.4 + iTime) * 0.5 + 0.5;\n    \n    // Add turbulence for more dynamic patterns\n    vec2 noiseSt = uv * 16.0 + sin(iTime) * 8.0;\n    float t = turbulent(noiseSt);\n    \n    // Combine color and turbulence\n    vec3 color = hsl2rgb(vec3(\n        (r + g + b) * 0.333,\n        0.7 + t * 0.3,\n        0.5 + sin(iTime * 0.2) * 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1073.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base sine wave patterns with varying frequencies and phases\n    float wave1 = sin(uv.x * 8.0 + iTime * 2.0);\n    float wave2 = sin(uv.y * 4.0 + iTime * 3.0);\n    \n    // Combine waves and add noise for complexity\n    vec2 noiseCoords = uv * 5.0 + vec2(iTime, iTime) * 2.0;\n    float noiseValue = noise(noiseCoords);\n    float pattern = wave1 * wave2 + noiseValue * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.5) * 0.5 + 0.5,   // Hue variation over time\n        0.7,                             // Saturation\n        0.6                              // Lightness\n    ));\n    \n    // Add interactivity based on mouse movement (simulated with uv)\n    vec2 mouse = uv;\n    float interact = length(mouse - vec2(0.5)) * 2.0;\n    pattern += sin(interact * 10.0 + iTime) * 0.3;\n    \n    // Final color calculation\n    vec3 finalColor = color * (abs(pattern) * 0.6 + 0.4);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1074.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Create multiple layers of particles\n    for(float i = 0.0; i < 5.0; i++) {\n        // Scale coordinates for different particle sizes\n        vec2 st = uv * pow(1.5, i) + iTime * 0.5;\n        \n        // Use noise to generate random positions\n        float n = noise(st * 4.0);\n        \n        // Create circular particles with glow effect\n        vec2 pos = fract(st) - 0.5;\n        float dist = length(pos);\n        float angle = atan2(pos.y, pos.x) + iTime * 0.1 + i * 0.3;\n        \n        // Color based on position and time\n        vec3 color = hsv2rgb(vec3(\n            fract(iTime * 0.1 + pos.x * 0.5 + pos.y * 0.5),\n            0.7,\n            0.8\n        ));\n        \n        // Add rotation effect\n        float rotate = sin(angle) * 0.5 + 0.5;\n        color *= rotate;\n        \n        // Draw particles with glow\n        if(dist < 0.4) {\n            finalColor += color * (1.0 - dist / 0.4);\n        }\n        \n        // Add some noise variation\n        finalColor += n * 0.2;\n    }\n    \n    // Mix with background\n    vec3 bg = hsv2rgb(vec3(iTime * 0.1, 0.1, 0.2));\n    finalColor = mix(bg, finalColor, finalColor.r + finalColor.g + finalColor.b);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1075.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color with time-based hue shift\n    vec3 hslColor = vec3(\n        sin(iTime * 0.5 + uv.x * 10.0) * 0.5 + 0.5,\n        0.7,\n        0.6\n    );\n    \n    // Add noise and turbulence to create dynamic patterns\n    float noiseValue = noise(uv * 20.0);\n    float turbulentValue = turbulent(vec3(uv, iTime));\n    \n    // Mix in sine-based animation\n    vec3 animatedColor = vec3(\n        sin(uv.x * 10.0 + iTime) * 0.5 + 0.5,\n        sin(uv.y * 10.0 + iTime * 0.5) * 0.5 + 0.5,\n        sin(iTime * 0.2) * 0.5 + 0.5\n    );\n    \n    // Combine everything and convert to RGB\n    vec3 finalColor = hsl2rgb(\n        hslColor +\n        animatedColor * 0.3 +\n        noiseValue * 0.2 +\n        turbulentValue * 0.1\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1076.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color from UV coordinates with time influence\n    vec3 hslColor = vec3(uv.x * 0.5 + 0.5, uv.y * 0.5 + 0.5, sin(iTime * 0.1 + uv.x * 2.0));\n    \n    // Add noise texture sampling with time offset\n    vec2 noiseUV = uv * 40.0 + fract(iTime * 0.5);\n    vec3 noiseColor = texture(iChannel0, noiseUV).rgb;\n    \n    // Mix HSL and noise colors with smooth transitions\n    vec3 finalColor = mix(hsl2rgb(hslColor), noiseColor, 0.7);\n    \n    // Add flowing movement effect\n    float flowX = sin(uv.y * 10.0 + iTime) * 0.5;\n    float flowY = cos(uv.x * 10.0 + iTime * 0.8) * 0.5;\n    vec2 flowUV = uv + vec2(flowX, flowY);\n    \n    // Apply turbulence to create melting effect\n    float turb = turbulent(flowUV * 40.0 + iTime);\n    finalColor += turb * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1077.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create time-based animation\n    float time = iTime * 0.5;\n    \n    // Add rotation effect\n    float angle = sin(time) * 0.5 + pi;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotated = rot * st;\n    \n    // Create color shifting pattern using sine functions\n    vec3 color = vec3(\n        sin(rotated.x * 4.0 + time) * 0.5 + 0.5,\n        sin(rotated.y * 4.0 + time + 2.0) * 0.5 + 0.5,\n        sin((rotated.x + rotated.y) * 3.0 + time + 4.0) * 0.5 + 0.5\n    );\n    \n    // Add turbulence for more dynamic effect\n    vec2 noiseUV = st * 0.5 + vec2(time, 0.0);\n    float turb = turbulent(noiseUV);\n    color += turb * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1078.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a coordinate system centered at (0.5, 0.5)\n    vec2 st = uv - 0.5;\n    \n    // Add some noise to create interesting patterns\n    float scale = 10.0;\n    float timeScale = iTime * 0.5;\n    \n    // Create three color channels with phase shifts\n    float r = length(st) * scale;\n    float theta = atan2(st.y, st.x);\n    \n    // Use noise to create shifting patterns\n    float n = noise(vec2(r + timeScale, theta));\n    \n    // Create RGB color channels with phase shifts\n    vec3 color = vec3(\n        sin(theta + 0.0) * r + n,\n        sin(theta + 120.0) * r + n,\n        sin(theta + 240.0) * r + n\n    );\n    \n    // Add some turbulence to create more dynamic patterns\n    color += turbulent(vec3(st.x * scale, st.y * scale, iTime)) * 0.5;\n    \n    // Clamp values between 0 and 1 for valid RGB output\n    return vec4(clamp(color, 0.0, 1.0), 1.0);\n}"
  },
  "data_1079.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float theta = atan2(uv.y, uv.x) + iTime * 3.0;\n    float r = length(uv);\n    \n    // Create rotating color wheel effect\n    vec3 color = hsl2rgb(vec3(\n        (theta / (2.0 * PI)) + sin(iTime * 0.5) * 0.5,\n        1.0,\n        0.5 + 0.5 * turbulent(uv * 4.0)\n    ));\n    \n    // Add pulsating center effect\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    color = mix(color, vec3(1.0), pulse * (1.0 - r));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_108.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar space\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create warp effect using noise and time\n    float warp = sin(r + iTime) * 0.5;\n    a += warp;\n    // Convert back to cartesian coordinates with warping\n    vec2 pos = vec2(cos(a), sin(a)) * r;\n    // Add turbulence based on position and time\n    float turb = turbulent(pos * 10.0 + iTime);\n    \n    // Create geometric orbit trap patterns\n    float d = length(pos);\n    d += mod(length(pos * 5.0), 1.0) * 0.2;\n    d += sin(d * 8.0) * 0.1;\n    // Calculate color based on distance to traps\n    vec3 color = hsl(\n        mod(r + iTime, 1.0),\n        0.5,\n        clamp(1.0 - d * 2.0, 0.0, 1.0)\n    );\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_1080.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotatedUV = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create geometric pattern with noise and turbulence\n    float circleDist = length(rotatedUV);\n    float pattern = mod(circleDist * 10.0 + t, 1.0);\n    \n    // Add noise texture\n    vec2 noiseScale = rotatedUV * 5.0;\n    float noiseVal = noise(noiseScale) * 0.5 + 0.5;\n    float turbulence = turbulent(vec3(rotatedUV, t)) * 0.5 + 0.5;\n    \n    // Combine pattern and noise\n    pattern = mix(pattern, noiseVal, turbulence);\n    \n    // Create RGB shifts with time\n    vec3 color = hsl2rgb(vec3(\n        mod(circleDist * 10.0 + t * 2.0, 1.0),\n        0.7,\n        0.5\n    ));\n    \n    // Add geometric transformations\n    float angle = atan2(rotatedUV.y, rotatedUV.x);\n    color *= sin(angle * 4.0 + t) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1081.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequencies using time\n    float freq1 = sin(iTime * 0.5);\n    float freq2 = cos(iTime);\n    \n    // Rotate and transform UV coordinates\n    vec2 st = uv;\n    st.x *= freq1 + 0.5;\n    st.y *= freq2 + 0.5;\n    \n    // Add some turbulence to create interesting patterns\n    st += turbulent(st * 10.0) / 50.0;\n    \n    // Create color cycling effect using HSL\n    float h = sin(iTime * 0.3 + st.x * 2.0) * 0.5 + 0.5;\n    float s = sin(iTime * 0.4 + st.y * 3.0) * 0.5 + 0.5;\n    float l = sin(iTime * 0.6 + st.x * st.y * 2.0) * 0.5 + 0.5;\n    \n    // Convert HSL to RGB\n    vec3 color = hsl2rgb(vec3(h, s, l));\n    \n    // Add some sine wave modulation\n    float mod = sin(iTime + st.x * 10.0);\n    color = mix(color, vec3(mod), 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1082.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating noise patterns with color shifts over time\n    \n    // Speed up time for more dynamic movement\n    float time = iTime * 0.5;\n    \n    // Rotate coordinates based on time\n    vec2 rotatedUv = vec2(\n        cos(time) * uv.x - sin(time) * uv.y,\n        sin(time) * uv.x + cos(time) * uv.y\n    );\n    \n    // Add noise layers with different rotations and speeds\n    float noise1 = noise(vec3(rotatedUv * 4.0, time));\n    float noise2 = noise(vec3(uv * 8.0 - rotatedUv * 4.0, time + 1.0));\n    \n    // Combine noise patterns with turbulence\n    float pattern = turbulent(rotatedUv * 4.0) * 0.5 +\n                   turbulent(uv * 2.0 + rotatedUv * 3.0) * 0.3;\n    \n    // Add color shifts using HSL conversion\n    vec3 color = hsl(\n        sin(time * 0.7) * 0.5 + 0.5,   // Hue variation over time\n        1.0,                            // Saturation\n        pattern * 0.6 + 0.4             // Lightness based on noise\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1083.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec3 color = vec3(0.0);\n    \n    // Grid position calculation\n    vec2 gridPos = fract(uv * 20.0);\n    vec2 g = floor(gridPos);\n    \n    // Calculate rotation speed for each square using noise\n    float speed = noise(vec3(g, time)) * 0.5 + 0.5;\n    \n    // Calculate rotation angle\n    float angle = time * speed * 10.0;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    // Apply rotation to grid position\n    vec2 rotatedUV = (uv - g) * rot + g;\n    \n    // Add perspective distortion\n    float z = sin(time + length(rotatedUV)) * 0.5 + 0.5;\n    color += vec3(z);\n    \n    // Color calculation using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        fract(g.x * 0.1 + g.y * 0.2 + time),\n        0.5,\n        0.5\n    );\n    color *= hsl2rgb(hslColor);\n    \n    // Add turbulence effect for more complexity\n    float turb = turbulent(vec2(uv * 10.0));\n    color += vec3(turb) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1084.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 2.0;\n    // Create rotating pattern using noise and turbulence\n    float n1 = noise(vec3(theta, r * 10.0, iTime));\n    float n2 = noise(vec3(theta * 2.0, r * 50.0, iTime * 0.5));\n    float t = turbulent(vec2(r * 10.0 + iTime, theta));\n    // Create color transitions\n    vec3 hslColor = vec3(\n        mod(theta / 4.0 + iTime * 0.5, 1.0),\n        0.7,\n        0.5 + t * 0.5\n    );\n    // Mix noise values into the color\n    hslColor.rg += n1 * 0.3;\n    hslColor.b += n2 * 0.4;\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1085.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 col = 0.5 + 0.5 * sin(\n        iTime +\n        vec3(1.0/3.0, 1.0/4.0, 1.0/5.0) * \n        (uv.x * 2.0 + uv.y * 2.0) * PI\n    );\n    \n    return vec4(col, 1.0);\n}"
  },
  "data_1086.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a coordinate system centered at (0,0)\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add time-based rotation\n    float t = iTime * 0.5;\n    vec2 rotated = vec2(\n        st.x * cos(t) - st.y * sin(t),\n        st.x * sin(t) + st.y * cos(t)\n    );\n    \n    // Create a noise pattern with turbulence\n    float n1 = noise(vec3(rotated, iTime * 0.1));\n    float n2 = turbulent(rotated * 4.0);\n    \n    // Combine noise layers with time-based variation\n    float pattern = sin(n1 * 8.0 + t) * cos(n2 * 2.0 + t * 0.5);\n    \n    // Create a color palette using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        fract(t * 0.2 + pattern * 0.1) * 360.0,\n        0.7 + abs(sin(t)) * 0.3,\n        0.5 + abs(cos(t)) * 0.5\n    ));\n    \n    // Output the final color with some transparency\n    return vec4(color, 0.8);\n}"
  },
  "data_1087.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 centered = uv - 0.5;\n    float radius = length(centered);\n    float angle = atan2(centered.y, centered.x);\n    \n    // Add time-based rotation and expansion\n    float timeScale = iTime * 0.1;\n    radius += sin(iTime) * 0.3;\n    angle += iTime + turbulent(vec2(radius * 5.0, iTime));\n    \n    // Create color variations using HSL\n    vec3 hslColor;\n    hslColor.x = fract(angle / (pi * 2.0) + timeScale);\n    hslColor.y = 1.0 - abs(0.5 - radius) * 2.0;\n    hslColor.z = 0.7 + turbulent(vec2(radius * 3.0, iTime)) * 0.3;\n    \n    // Convert to RGB and add noise\n    vec3 color = hsl2rgb(hslColor);\n    color += noise(vec2(angle, radius * 10.0)) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1088.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Generate multiple layers of particles\n    for (int i = 0; i < 5; i++) {\n        // Scale and offset for different particle sizes\n        float scale = pow(1.5, float(i)) * 2.0;\n        vec2 st = uv * scale + iTime * 0.5;\n        \n        // Add noise to create organic movement patterns\n        vec2 pos = vec2(\n            sin(iTime * 0.3 + turbulent(st.yy) * 2.0),\n            cos(iTime * 0.4 + turbulent(st.xx) * 2.0)\n        ) * 0.5;\n        \n        // Create a grid of particle points\n        vec2 grid = fract(st);\n        vec2 center = vec2(0.5, 0.5);\n        vec2 toCenter = center - grid;\n        \n        // Calculate distance from particle point\n        float dist = length(toCenter) * scale;\n        float influence = smoothstep(1.0, 0.0, dist);\n        \n        // Create color based on position and time\n        vec3 hslColor = vec3(\n            fract(iTime * 0.2 + grid.x * 2.0),\n            0.7,\n            0.5 + influence * 0.5\n        );\n        vec3 rgbColor = hsl2rgb(hslColor);\n        \n        // Add noise to color for more dynamic effect\n        rgbColor *= 1.0 + noise(vec3(st, iTime)) * 0.3;\n        \n        // Accumulate color with alpha based on influence\n        color += rgbColor * influence;\n    }\n    \n    // Final color with glow effect\n    vec4 finalColor = vec4(color, max(0.2, length(color) - 0.5));\n    return finalColor;\n}"
  },
  "data_1089.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Add time-based rotation\n    a += iTime * 0.5 + r * 0.5;\n    // Create hexagonal pattern using polar coordinates\n    float hex = sin(6.0 * a) * 0.5 + 0.5;\n    float pattern = step(hex, 0.7);\n    // Add noise and turbulence for more complexity\n    vec3 noisePos = vec3(uv * 10.0, iTime);\n    float turb = turbulent(noisePos);\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(a * 0.5 + iTime, 1.0),\n        0.7,\n        0.5 + 0.5 * sin(iTime)\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Combine pattern and color\n    float finalPattern = mix(pattern, turb, 0.5);\n    vec3 finalColor = mix(vec3(1.0), rgbColor, finalPattern);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_109.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating pattern with time-based warping\n    vec2 translated = uv * 1.5 - 0.5;\n    \n    // Add time-based rotation\n    float angle = sin(iTime * 0.2) * 0.5 + 0.5;\n    vec2 rotated = vec2(\n        translated.x * cos(angle) - translated.y * sin(angle),\n        translated.x * sin(angle) + translated.y * cos(angle)\n    );\n    \n    // Convert to polar coordinates\n    vec2 polar = vec2(length(rotated), atan2(rotated.y, rotated.x));\n    \n    // Create warping effect using turbulence\n    float warp = (turbulent(polar * 10.0 + iTime) * 0.5 + 0.5) * 2.0;\n    polar.x += warp;\n    \n    // Convert back to cartesian coordinates with warping\n    vec2 warped = vec2(\n        cos(polar.y) * polar.x,\n        sin(polar.y) * polar.x\n    );\n    \n    // Create orbit trap effect\n    float distance = length(warped);\n    float angleMod = fract(polar.y / (pi * 2.0)) * 2.0 - 1.0;\n    \n    // Color based on position and time\n    vec3 color = hsl(\n        (polar.y / (pi * 2.0) + iTime * 0.1),\n        0.8,\n        0.5\n    );\n    \n    // Add pattern detail\n    float pattern = mod(distance * 4.0, 1.0);\n    pattern += noise(vec2(pattern, iTime)) * 0.3;\n    \n    color *= 1.0 - pattern;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1090.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing patterns using time-based transformations\n    vec2 st = uv * 10.0 + vec2(sin(iTime)*5.0, cos(iTime*0.7)*3.0);\n    \n    // Add turbulence for dynamic movement\n    float t = turbulent(vec3(st.x + iTime*2.0, st.y + iTime, 0.0));\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 col = hsl2rgb(vec3(t * 0.6 + 0.4, 0.8, 0.5));\n    \n    // Add secondary color layer for more depth\n    float t2 = turbulent(vec3(st.x + iTime*1.5, st.y - iTime, 0.0));\n    vec3 col2 = hsl2rgb(vec3(t2 * 0.6 + 0.4, 0.8, 0.7));\n    \n    // Mix colors based on noise for smooth transitions\n    float blend = noise(vec2(st.x*0.5 + iTime, st.y*0.5)) * 0.5 + 0.5;\n    col = mix(col, col2, blend);\n    \n    return vec4(col, 1.0);\n}"
  },
  "data_1091.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV coordinates from 0-1 range to -1 to 1\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Convert to polar coordinates\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(angle * 0.5 + 0.1, 0.6, 0.5);\n    \n    // Add noise and turbulence effects\n    float noiseValue = turbulent(vec3(st.x, st.y, iTime * 0.2)) * 0.5 + 0.5;\n    color = mix(color, hsl(angle * 0.5 + 0.1 + noiseValue * 0.2, 0.8, 0.6), noiseValue);\n    \n    // Vary saturation based on radius\n    color = hsl2rgb(vec3(hsl2rgb(color).xy * (1.0 - radius * 0.5) + radius * 0.5, color.z));\n    \n    // Add time-based lightness variation\n    float timeFactor = sin(iTime * 0.5) * 0.2 + 0.5;\n    color *= timeFactor;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1092.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using sine functions\n    float time = iTime * 0.5;\n    \n    // Translate UV to center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Apply rotation based on time\n    float angle = time;\n    vec2 rotated = vec2(\n        st.x * cos(angle) - st.y * sin(angle),\n        st.x * sin(angle) + st.y * cos(angle)\n    );\n    \n    // Create color variations using HSL\n    vec3 color1 = hsl(0.5 * sin(time + 1.0) + 0.5, \n                     0.7, \n                     0.5 * rotated.x * rotated.y + 0.5);\n                     \n    vec3 color2 = hsl(0.5 * cos(time + 2.0) + 0.5,\n                     0.7,\n                     0.5 * (sin(rotated.x * 4.0 + time) + 1.0));\n    \n    // Combine colors with distance from center\n    float dist = length(st);\n    vec3 finalColor = mix(color1, color2, sin(dist * 8.0 + time) * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1093.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Time-based frequency and amplitude modulation\n    float time = iTime * 0.5;\n    \n    // Position transformation with sine waves\n    vec2 pos = uv * 10.0 + vec2(sin(time) * 3.0, cos(time) * 3.0);\n    \n    // Multiple octaves for complex pattern\n    float freq1 = sin(pos.x * 0.5 + time) * 0.5;\n    float freq2 = sin(pos.y * 0.5 + time * 0.7) * 0.3;\n    float freq3 = sin((pos.x + pos.y) * 0.2 + time * 0.4) * 0.2;\n    \n    // Combine frequencies for color\n    vec3 color = vec3(freq1, freq2, freq3);\n    \n    // HSL to RGB conversion with time-based hue shift\n    vec3 hslColor = vec3(\n        (freq1 + freq2 + freq3) * 0.5 + 0.5,\n        sin(time * 0.7) * 0.5 + 0.5,\n        cos(time * 0.5) * 0.5 + 0.5\n    );\n    \n    // Final color transformation\n    vec3 finalColor = hsl2rgb(hslColor);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1094.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    vec2 st = uv * 2.0 - 1.0;\n    float t = iTime * 0.5;\n    \n    // Create a rotating pattern using sine and cosine\n    mat2 rot = mat2(cos(t), sin(t), -sin(t), cos(t));\n    vec2 rotated = rot * st;\n    \n    // Calculate distance from line with time variation\n    float d = abs(rotated.x * sin(t) + rotated.y * cos(t)) * 4.0;\n    \n    // Add noise and turbulence for dynamic variations\n    float noiseVal = noise(vec3(uv * 10.0, t));\n    float turbulentVal = turbulent(vec2(uv * 5.0 + t));\n    \n    // Combine distance with noise for thickness variation\n    float line = smoothstep(0.4 + noiseVal * 0.2, 0.6 + noiseVal * 0.2, d);\n    \n    // Create color variations using HSL to RGB conversion\n    vec3 hslColor = vec3(t * 0.1, 0.7, 0.5 + turbulentVal * 0.2);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Mix colors and apply line effect\n    vec3 finalColor = mix(vec3(0.1), rgbColor, line);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1095.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing vertical stripes pattern\n    float time = iTime * 0.5;\n    \n    // Vertical stripe pattern with sine wave variation\n    float pattern1 = sin(uv.x * 10.0 + time) * 0.5 + 0.5;\n    float pattern2 = sin(uv.x * 20.0 + time * 0.7) * 0.3 + 0.3;\n    \n    // Combine patterns with turbulence\n    float mixValue = (pattern1 + pattern2) * 0.8;\n    mixValue += turbulent(vec3(uv.x, time, 0.0)) * 0.2;\n    \n    // Create smooth color transitions using HSL to RGB conversion\n    vec3 mainColor = hsl(mixValue * 0.6 + 0.4, 1.0, 0.5);\n    vec3 secondaryColor = hsl(mixValue * 0.6 + 0.8, 1.0, 0.5);\n    \n    // Interpolate between colors based on position and time\n    float colorMix = sin(uv.x * 2.0 + time) * 0.5 + 0.5;\n    vec3 finalColor = mix(mainColor, secondaryColor, colorMix);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1096.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create wave patterns with different frequencies and phases\n    float wave1 = sin(uv.x * 8.0 + iTime) * cos(uv.y * 4.0);\n    float wave2 = sin(uv.y * 6.0 - iTime) * cos(uv.x * 3.0);\n    float wave3 = sin((uv.x + uv.y) * 5.0 + iTime * 2.0);\n    \n    // Combine waves with different phase shifts\n    vec3 waves = vec3(\n        wave1 + sin(iTime * 0.5 + 1.0),\n        wave2 + cos(iTime * 0.6 + 2.0),\n        wave3 + sin(iTime * 0.7 + 3.0)\n    );\n    \n    // Add turbulence for more dynamic patterns\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float turb = turbulent(noiseUV);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1 + waves.r, 1.0),\n        0.7,\n        0.5 + turb * 0.5\n    ));\n    \n    // Combine everything with some blending\n    vec3 finalColor = (waves * 0.5 + 0.5) * color;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1097.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create hexagonal grid pattern\n    theta += iTime * 0.2; // Rotate over time\n    float angleSegment = pi / 3.0;\n    float segment = mod(theta, angleSegment) / angleSegment;\n    \n    // Calculate color with smooth transitions\n    vec3 baseColor = hsl2rgb(vec3(0.5 + 0.5 * sin(iTime * 0.1), 0.7, 0.6));\n    vec3 secondaryColor = hsl2rgb(vec3(0.5 + 0.5 * cos(iTime * 0.1), 0.5, 0.4));\n    \n    // Mix colors based on segment\n    vec3 color = mix(baseColor, secondaryColor, sin(segment * pi) * 0.5 + 0.5);\n    \n    // Add noise for detail\n    float noiseValue = noise(uv * 10.0 + iTime);\n    color = mix(color, baseColor, noiseValue * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1098.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for rotation effect\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create square pattern using polar coordinates\n    vec2 sq = vec2(\n        sin(angle) * radius,\n        cos(angle) * radius\n    );\n    \n    // Use noise to create dynamic color transitions\n    float noiseVal = noise(vec3(sq.x, sq.y, iTime));\n    \n    // Convert to HSL for easier color manipulation\n    vec3 hslColor = vec3(\n        fract(angle * 0.1 + iTime) * 360.0,\n        0.7 + noiseVal * 0.3,\n        0.5 + noiseVal * 0.5\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1099.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequency components\n    float freq1 = sin(uv.x * 5.0 + iTime) * cos(uv.y * 3.0 + iTime);\n    float freq2 = sin(uv.y * 4.0 - iTime) * cos(uv.x * 6.0 - iTime);\n    \n    // Combine frequencies with noise\n    vec2 noiseUV = uv * 5.0;\n    float noise1 = noise(noiseUV + vec2(iTime, 0.0));\n    float noise2 = noise(noiseUV + vec2(-iTime, 0.0));\n    \n    // Create wave patterns with time-based movement\n    float wave1 = sin(uv.x * 10.0 + iTime * 2.0) * cos(uv.y * 10.0 + iTime);\n    float wave2 = cos(uv.x * 8.0 - iTime * 3.0) * sin(uv.y * 6.0 - iTime);\n    \n    // Combine all components\n    vec3 colorMix = vec3(\n        (freq1 + noise1 + wave1) * 0.5 + 0.5,\n        (freq2 + noise2 + wave2) * 0.5 + 0.5,\n        turbulent(vec2(uv.x * 4.0, uv.y * 4.0) + iTime)\n    );\n    \n    // Convert to HSL and back to RGB for color shifting\n    vec3 hslColor = vec3(\n        (colorMix.r + colorMix.g + colorMix.b) * 0.6,\n        abs(colorMix.x - colorMix.y) * 2.0,\n        0.5\n    );\n    \n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_11.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float t = iTime * 0.1;\n    \n    vec2 p = uv;\n    p.x *= cos(t);\n    p.y *= sin(t);\n    \n    p += noise(p * 5.0);\n    p += turbulent(vec2(noise(p * 3.0), noise(p * 4.0)));\n    \n    float a = atan2(p.y, p.x) + t;\n    vec3 color = hsl2rgb(vec3(sin(a) * 0.5 + 0.5, \n                              cos(a) * 0.5 + 0.5,\n                              sin(t) * 0.5 + 0.5));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_110.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 pos = uv * 2.0 - 1.0;\n    float speed = 0.5;\n    \n    float time = iTime * speed;\n    vec2 trapCenter = vec2(sin(time * 0.7), cos(time * 0.6)) * 0.3;\n    \n    float maxIterations = 30.0;\n    float escapeRadius = 1.5;\n    float distanceSum = 0.0;\n    \n    for(float i = 0.0; i < maxIterations; i++) {\n        pos = vec2(\n            pow(length(pos), 2.0) * cos(atan2(pos.y, pos.x)) - trapCenter.x,\n            pow(length(pos), 2.0) * sin(atan2(pos.y, pos.x)) + trapCenter.y\n        );\n        \n        float noiseFactor = noise(vec3(pos * 0.5 + time, 0.0)) * 0.1;\n        pos += vec2(sin(time + i) * noiseFactor, cos(time + i) * noiseFactor);\n        \n        if(length(pos - trapCenter) < 0.2) {\n            distanceSum += length(pos) * 0.1;\n        }\n    }\n    \n    float normalizedDistance = min(distanceSum / maxIterations, 1.0);\n    vec3 color = hsl2rgb(vec3(\n        (time + pos.x * 0.5) * 4.0,\n        0.7,\n        0.5 + normalizedDistance * 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1100.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and create grid cells\n    vec2 st = floor(uv * 100.0);\n    \n    // Create base color using HSL with time-based hue shift\n    vec3 baseColor = hsl(st.x + sin(iTime)*50.0, \n                         st.y + cos(iTime*0.7)*50.0,\n                         0.5);\n    \n    // Add dynamic turbulence based on position and time\n    float turb = turbulent(vec2(uv * 10.0 + iTime));\n    \n    // Combine base color with turbulence for shifting effect\n    vec3 finalColor = hsl2rgb(vec3(\n        (baseColor.r + turb) * 0.5,\n        (baseColor.g + turb) * 0.7,\n        0.6\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1101.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of rotating squares\n    vec2 st = uv * 10.0; // Tile the space\n    \n    // Add some time-based rotation\n    float timeRotation = iTime * 0.5;\n    \n    // Calculate distance from center for each square\n    vec2 sqPos = floor(st) + 0.5;\n    vec2 sqUv = (st - sqPos);\n    \n    // Apply rotation to each square position\n    float angle = timeRotation + length(sqPos) * 0.1;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedSqUv = rotMatrix * (sqUv - 0.5) + 0.5;\n    \n    // Create square pattern with time-based color shifts\n    float dist = length(rotatedSqUv - 0.5);\n    vec3 color = hsl2rgb(vec3(0.6 + sin(iTime * 0.5 + dist * 10.0) * 0.4, 0.8, 0.7));\n    \n    // Add some noise and turbulence for extra detail\n    float noiseVal = noise(st + iTime);\n    color *= 1.0 + turbulent(rotatedSqUv * 5.0) * 0.3;\n    \n    // Mix colors between squares\n    vec3 finalColor = mix(color, hsl2rgb(vec3(0.3 + sin(iTime * 0.7 + dist * 8.0), 0.6, 0.5)), \n                         smoothstep(0.4, 0.6, dist));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1102.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add time offset for animation\n    vec2 st = uv * 4.0 + iTime;\n    \n    // Create two wave components with different frequencies\n    float wave1 = sin(st.x + sin(iTime)) * cos(st.y);\n    float wave2 = cos(st.x - cos(iTime)) * sin(st.y);\n    \n    // Combine waves and add turbulence for more complex patterns\n    float combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(vec3(uv * 2.0, iTime * 0.1));\n    \n    // Create a color based on the wave pattern\n    vec3 color = hsl(\n        mod(iTime * 0.2 + combined * 0.5, 1.0),  // Hue variation over time and space\n        0.7,                                      // Saturation\n        0.6 + abs(combined) * 0.4                 // Brightness modulation\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_1103.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates centered at 0.5\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add rotation over time\n    \n    // Create rotating circular patterns using sine waves\n    float pattern1 = sin(theta * 4.0 + iTime * 2.0) * 0.5 + 0.5;\n    float pattern2 = sin(r * 8.0 - iTime) * 0.3 + 0.7;\n    \n    // Combine patterns with noise for more complexity\n    float noiseValue = noise(vec2(uv.x * 10.0, uv.y * 10.0)) * 0.5 + 0.5;\n    float finalPattern = pattern1 * pattern2 * noiseValue;\n    \n    // Create pulsating color effect using HSL\n    vec3 hslColor = vec3(\n        mod(theta * 4.0 + iTime, 1.0), // Hue variation over time and angle\n        1.0,                            // Full saturation\n        finalPattern                    // Brightness based on pattern\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1104.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale UV coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create polar coordinates\n    float angle = atan2(st.y, st.x) + iTime; // Add time for rotation\n    float radius = length(st);\n    \n    // Create spiral pattern using polar coordinates\n    float spiral = sin(angle + radius * 5.0) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for more dynamic effect\n    vec3 color = hsl2rgb(vec3(\n        (angle * 0.15 + iTime * 0.1) * 360.0, // Hue variation with time\n        0.7, // Saturation\n        0.5 + turbulent(vec3(st.x*0.5, st.y*0.5, iTime)) * 0.2 // Lightness modulation\n    ));\n    \n    // Combine spiral pattern with color\n    vec3 finalColor = mix(color, hsl2rgb(vec3(0.0, 0.0, 1.0)), spiral);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1105.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 8.0 + iTime;\n    \n    // Create a noise-based value with turbulence\n    float n = turbulent(st);\n    \n    // Base color using HSL conversion\n    vec3 baseColor = hsl2rgb(vec3(\n        sin(st.x * 0.5 + iTime) * 0.5 + 0.5,  // Hue\n        0.7,                                    // Saturation\n        0.5 + n * 0.2                           // Lightness\n    ));\n    \n    // RGB shift based on time and position\n    vec3 shiftedColor = vec3(\n        sin(iTime + st.x) * baseColor.z,\n        sin(iTime + st.y) * baseColor.r,\n        sin(iTime + st.x + st.y) * baseColor.g\n    );\n    \n    // Combine colors with noise modulation\n    vec3 finalColor = mix(baseColor, shiftedColor, abs(sin(n * 2.0 + iTime)));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1106.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x);\n    float radius = length(st);\n    \n    // Create rotating pattern using sine waves and noise\n    float timeSpeed = iTime * 2.0;\n    float pattern = sin(angle + timeSpeed) * 4.0;\n    pattern += turbulent(vec3(uv * 10.0, iTime)) * 2.0;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(radius * 5.0 + iTime, 1.0),\n        0.7,\n        0.6\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine pattern and color with smooth transitions\n    float transition = sin(iTime) * 0.5 + 0.5;\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(1.0, 0.5, 0.2),\n        abs(pattern) * 0.5 + transition * 0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1107.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale\n    vec2 st = (uv - 0.5) * 4.0;\n    \n    // Polar coordinates\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Time-based animation\n    float time = iTime * 0.5;\n    \n    // Color transitions using sine functions\n    vec3 color = hsl2rgb(vec3(\n        0.5 * sin(angle + time) + 0.5,   // Hue\n        0.7 + 0.3 * sin(radius - time), // Saturation\n        0.5 + 0.5 * sin(time + radius * 0.1) // Lightness\n    ));\n    \n    // Add noise for texture\n    float n = noise(uv * 4.0 + iTime);\n    color += vec3(0.2 * n);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1108.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv - 0.5;\n    float theta = atan2(st.y, st.x) + time;\n    float radius = length(st);\n    \n    // Create rotating geometric patterns using sine waves\n    float pattern1 = sin(theta * 6.0) * 0.5 + 0.5;\n    float pattern2 = sin(theta * 4.0 + time) * 0.3 + 0.7;\n    float pattern3 = sin(theta * 2.0 - time) * 0.2 + 0.8;\n    \n    // Combine patterns with turbulence for dynamic effect\n    float combined = (pattern1 + pattern2 + pattern3) / 3.0;\n    combined += turbulent(uv * 4.0 + time) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(time * 0.2 + radius * 0.7),\n        0.8,\n        0.6 + turbulent(uv * 2.0 + time) * 0.4\n    );\n    \n    // Convert to RGB and mix with patterns\n    vec3 color = hsl2rgb(hslColor);\n    color *= combined;\n    \n    // Add depth variation\n    float depth = turbulent(uv * 8.0 + time * 2.0) * 0.5 + 0.5;\n    color = mix(color, vec3(1.0), depth * 0.4);\n    \n    return vec4(color, combined * 0.8 + depth * 0.2);\n}"
  },
  "data_1109.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate pattern over time\n    float time = iTime * 0.5;\n    \n    // Create intersecting sine wave patterns\n    vec2 st1 = uv * 10.0 + vec2(time, 0.0);\n    vec2 st2 = uv * 10.0 + vec2(0.0, time);\n    \n    // Generate wave patterns with noise and turbulence\n    float wave1 = sin(st1.x) * cos(st1.y) * 0.5;\n    float wave2 = sin(st2.y) * cos(st2.x) * 0.5;\n    \n    // Combine waves and add turbulence\n    float pattern = (wave1 + wave2) * 0.5;\n    pattern += turbulent(uv * 4.0 + vec2(time)) * 0.3;\n    \n    // Create shifting hues using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.6 + time * 0.1, 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.3 - time * 0.1, 1.0, 0.5));\n    \n    // Mix colors based on pattern\n    vec3 finalColor = mix(color1, color2, abs(pattern) * 0.5 + 0.5);\n    \n    // Add pulsing effect to the overall brightness\n    float pulse = sin(time * 2.0) * 0.5 + 0.5;\n    finalColor *= pulse;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_111.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and shift UV coordinates\n    vec2 st = uv * 5.0 - 2.0;\n    \n    // Polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add some movement over time\n    theta += sin(iTime) * 0.5;\n    \n    // Create orbit trap effect using turbulence\n    float trap = turbulent(vec3(r, theta, iTime));\n    \n    // Convert back to cartesian coordinates\n    vec2 pos = vec2(\n        cos(theta + trap * 0.5) * r,\n        sin(theta - trap * 0.5) * r\n    );\n    \n    // Add noise and color\n    float n = noise(pos * 0.5 + iTime);\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.15 + n * 0.2,\n        0.7 + trap * 0.3,\n        0.5 + sin(iTime) * 0.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1110.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Time-based animation parameters\n    float time = iTime * 0.5; // Speed control\n    \n    // Create sine wave patterns with different frequencies\n    float pattern1 = sin(uv.x * 8.0 + time) * cos(uv.y * 4.0 + time);\n    float pattern2 = sin(uv.y * 6.0 - time) * cos(uv.x * 3.0 + time);\n    \n    // Combine patterns with intensity\n    float combined = (pattern1 + pattern2) * 2.0;\n    combined += turbulent(vec3(uv * 4.0, time)) * 0.5; // Add turbulence\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(sin(time) * 0.5 + 0.5, 0.7, 0.6));\n    vec3 color2 = hsl2rgb(vec3(0.3 + combined * 0.2, 0.8, 0.7));\n    \n    // Blend colors based on pattern\n    vec3 finalColor = mix(color1, color2, abs(sin(uv.x * 2.0 + uv.y * 3.0 + time) * 0.5 + 0.5));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1111.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Number of particles\n    const int numParticles = 50;\n    \n    // Time-based seed for randomness\n    float timeSeed = iTime * 0.1;\n    \n    // Center point\n    vec2 center = vec2(0.5, 0.5);\n    \n    // For each particle\n    for(int i = 0; i < numParticles; i++) {\n        // Random seed based on particle index and time\n        float seed = (float(i) * 0.1 + timeSeed) * 3.1415926;\n        \n        // Calculate angle with some noise variation\n        float angle = atan2(sin(seed), cos(seed)) + turbulent(vec3(uv, iTime)) * 0.5;\n        \n        // Radius with some variation and noise\n        float radius = 0.3 + noise(vec3(angle, timeSeed, float(i))) * 0.15;\n        \n        // Current position relative to center\n        vec2 pos = center + vec2(cos(angle), sin(angle)) * radius;\n        \n        // Add slight drift based on time\n        angle += iTime * 0.05;\n        \n        // Create orbit trail effect by integrating over time\n        for(float t = 0.0; t < 1.0; t += 0.2) {\n            vec2 prevPos = center + vec2(cos(angle - t), sin(angle - t)) * (radius + noise(vec3(angle, timeSeed, float(i))) * 0.1);\n            \n            // Calculate distance from current UV to particle position\n            float dist = length(uv - prevPos);\n            \n            // Add color contribution with fading trail\n            if(dist < 0.02) {\n                // Color based on angle and noise\n                vec3 particleColor = hsl(angle * 180.0 / PI + timeSeed * 50.0, \n                                       0.7 + noise(vec3(iTime, float(i), seed)) * 0.3,\n                                       0.5 + noise(vec3(float(i), timeSeed, angle)) * 0.2);\n                \n                // Apply exponential fade\n                color += particleColor * exp(-dist * 100.0) * (1.0 - t);\n            }\n        }\n    }\n    \n    // Add some glow around the center\n    float distToCenter = length(uv - center);\n    if(distToCenter < 0.5) {\n        color += vec3(1.0, 0.8, 0.6) * exp(-distToCenter * 4.0) * 0.2;\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1112.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 50.0 + iTime * 10.0;\n    \n    // Create multi-scale noise patterns\n    float n1 = noise(st * 0.5);\n    float n2 = noise(st * 0.75);\n    float n3 = noise(st * 1.0);\n    \n    // Combine noise layers with different frequencies\n    vec3 color = vec3(\n        sin(n1 * pi + iTime) * 0.5 + 0.5,\n        sin(n2 * pi + iTime * 0.7) * 0.5 + 0.5,\n        sin(n3 * pi + iTime * 0.4) * 0.5 + 0.5\n    );\n    \n    // Add turbulence for more complex patterns\n    vec2 pos = uv * 10.0;\n    float turb = turbulent(pos);\n    color *= abs(turb * 0.5 + 0.5);\n    \n    // Create optical illusion effect by mixing colors\n    color = hsl2rgb(vec3(\n        (uv.x * pi + iTime) * 0.5,\n        1.0 - length(uv)*0.5,\n        0.5 + turb * 0.25\n    ));\n    \n    // Add global brightness variation\n    float bright = sin(iTime * 0.3) * 0.5 + 0.7;\n    color *= bright;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1113.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a dynamic pattern based on time and mouse movement\n    float time = iTime * 0.5;\n    \n    // Add mouse position influence (assuming mouse coordinates are normalized)\n    vec2 mousePos = vec2(0.5, 0.5); // Replace with actual mouse input if available\n    \n    // Create a noise-based pattern with turbulence\n    float pattern = sin(uv.x * 10.0 + time) * cos(uv.y * 10.0 + time);\n    pattern += noise(vec3(uv * 2.0, time)) * 0.5;\n    pattern += turbulent(vec3(uv * 4.0, time)) * 0.3;\n    \n    // Create shifting lines effect\n    float line = sin(pattern * 10.0 + mousePos.x * 100.0) * 0.5 + 0.5;\n    \n    // Convert to HSL color with dynamic hue\n    vec3 hslColor = vec3(line * 360.0, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1114.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing patterns using sine waves and time\n    float time = iTime * 0.5;\n    \n    // Base color using HSL\n    vec3 baseColor = hsl(\n        sin(time + uv.x * 2.0) * 0.4 + 0.6,  // Hue variation\n        0.7,                                   // Saturation\n        0.5                                    // Lightness\n    );\n    \n    // Create flowing pattern using sine waves and noise\n    float wave1 = sin(uv.x * 8.0 + time) * 0.5;\n    float wave2 = sin(uv.y * 4.0 + time * 0.7) * 0.3;\n    float wave3 = turbulent(vec2(uv.x * 2.0, uv.y * 3.0 + time)) * 0.2;\n    \n    // Combine waves with alpha blending\n    float blend = sin(wave1 + wave2 + wave3 + time) * 0.5 + 0.5;\n    vec4 color = vec4(baseColor, blend);\n    \n    // Add depth using noise and turbulence\n    float depth = turbulent(vec3(uv.x * 2.0, uv.y * 2.0, time)) * 0.3;\n    color.rgb += hsv2rgb(vec3(sin(time + uv.y) * 0.5 + 0.5, 1.0, 0.5)) * depth;\n    \n    // Soften edges using smoothstep\n    float edge = smoothstep(0.0, 1.0, blend);\n    color.a *= edge;\n    \n    return color;\n}"
  },
  "data_1115.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsing effect by scaling UV coordinates over time\n    vec2 st = uv * 10.0;\n    float scale = sin(iTime * 0.5 + length(uv)) * 0.5 + 0.5;\n    vec2 pos = (st - floor(st)) * scale + fract(vec2(iTime) * 0.3);\n    \n    // Generate grid pattern with noise\n    float noiseVal = noise(pos * 0.5 + iTime);\n    float grid = abs(sin(pos.x * pi) * sin(pos.y * pi));\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1 + pos.x * 0.5, 1.0),\n        0.7,\n        0.6\n    ));\n    \n    // Add turbulence for dynamic movement\n    float turb = turbulent(pos * 0.5 + iTime);\n    color *= grid * (1.0 + turb * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1116.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create smooth waves with varying frequencies and phases\n    float time = iTime * 0.5;\n    \n    // Wave pattern calculations\n    vec3 wave1 = sin(uv.xxy * 8.0 + time * 2.0);\n    vec3 wave2 = cos(uv.yyx * 4.0 + time * 3.0);\n    vec3 waves = (wave1 + wave2) * 0.5;\n    \n    // Add turbulence for more complex patterns\n    float turb = turbulent(uv * 4.0 + time);\n    waves += turb * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl2rgb(vec3(0.6, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.2, 0.8, 0.7));\n    vec3 finalColor = mix(color1, color2, waves.x * 0.5 + 0.5);\n    \n    // Add lighting effects\n    float light = length(uv - 0.5) * 2.0;\n    light = mod(light, 1.0) * 0.5 + 0.5;\n    finalColor *= light;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1117.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave patterns with time-based movement\n    float time = iTime * 0.5;\n    \n    // Base pattern using sine waves\n    vec2 st = uv * 10.0;\n    float pattern = sin(st.x + time) * 0.5 + 0.5;\n    pattern += sin(st.y + time * 0.7) * 0.3;\n    \n    // Add noise and turbulence for more dynamic patterns\n    vec2 noisePos = uv * 10.0 + vec2(time);\n    float n = noise(noisePos) * 0.5 + 0.5;\n    pattern += turbulent(noisePos) * 0.3;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor;\n    hslColor.x = (time * 0.1) + mod(pattern, 1.0); // Changing hue over time\n    hslColor.y = 0.7; // Saturation\n    hslColor.z = pattern * 0.5 + 0.2; // Brightness\n    \n    vec3 color = hsl2rgb(hslColor);\n    \n    // Add secondary color component for more depth\n    float secondaryPattern = sin(uv.x * 10.0 - time) * 0.5 + 0.5;\n    vec3 secondaryColor = hsl2rgb(vec3((time * 0.1) + 0.5, 0.7, pattern * 0.5 + 0.2));\n    \n    // Combine patterns and colors\n    color = mix(color, secondaryColor, secondaryPattern);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1118.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create rotating color wheel effect\n    float time = iTime * 0.5;\n    theta += time;\n    // Convert polar coordinates to HSL color space\n    vec3 hslColor = vec3(theta * 0.16 + 0.5, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Add pulsing glow effect based on radius and time\n    float pulse = sin(time * 4.0) * 0.5 + 0.5;\n    float glowFactor = smoothstep(1.0 - pulse, 1.0 + pulse, r);\n    \n    // Combine color with glow effect\n    vec3 finalColor = rgbColor * glowFactor;\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1119.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale UV coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create rotating pattern using polar coordinates\n    float angle = atan2(st.y, st.x) + iTime * 0.5;\n    float radius = length(st);\n    \n    // Add noise and turbulence\n    float noiseVal = turbulent(vec3(st * 4.0, iTime)) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 baseColor = hsl(angle * 2.0, 1.0, 0.6);\n    vec3 finalColor = mix(baseColor, vec3(1.0), noiseVal);\n    \n    // Add geometric elements\n    float pattern = sin(radius * 8.0 + iTime) * 0.5 + 0.5;\n    finalColor *= pattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_112.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create a radial glow effect\n    float glow = 1.0 - r*r;\n    glow *= turbulent(vec3(r*5.0 + iTime, angle*5.0, 0.0));\n    \n    // Add smile shape\n    float mouth = sin(angle * 4.0 + iTime * 2.0) * (1.0 - r*r);\n    float smile = max(0.0, glow + mouth * 0.5);\n    \n    // Color transformation using HSL to RGB\n    vec3 color = hsl2rgb(vec3(\n        angle * 0.5 + iTime,\n        0.7,\n        0.5 + smile * 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1120.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x) + iTime * 0.5;\n    float radius = length(st);\n    \n    // Use sine waves with time-based phase shifts for RGB colors\n    vec3 color = vec3(\n        sin(angle + iTime) * 0.5 + 0.5,\n        sin(angle + iTime + 2.0 * PI / 3.0) * 0.5 + 0.5,\n        sin(angle + iTime + 4.0 * PI / 3.0) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence for more dynamic patterns\n    vec2 noiseUV = uv * 10.0;\n    float n = noise(noiseUV);\n    color += n * 0.2;\n    \n    // Convert to HSL for better color control\n    vec3 hslColor = vec3(\n        angle * 0.5 + iTime * 0.1,\n        radius * 0.7 + 0.3,\n        0.5 + sin(iTime) * 0.2\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1121.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create time-based animation\n    float time = iTime * 0.5;\n    \n    // Generate sine wave patterns with varying frequencies\n    vec3 color = sin(vec3(st.x + time, st.y + time*0.7, 1.0)) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for more complex patterns\n    vec2 noiseUV = uv * 4.0 + time;\n    float noiseValue = noise(noiseUV);\n    \n    // Create color shifts using HSL conversion\n    vec3 hslColor = vec3(\n        sin(time + st.x * 5.0) * 0.5 + 0.5,  // Hue variation\n        1.0,                                   // Full saturation\n        0.5 + noiseValue * 0.2                // Modulate lightness with noise\n    );\n    \n    // Convert HSL to RGB and mix with original color\n    vec3 finalColor = hsl2rgb(hslColor) * (color + turbulent(vec2(st.x*10.0, st.y*10.0)));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1122.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating pattern using time and noise\n    float time = iTime * 0.5;\n    \n    // Generate grid lines with varying thickness\n    vec2 st = uv * 10.0; // Scale up for more squares\n    \n    // Horizontal line\n    float hline = step(0.4, sin(time + st.x) * 0.5 + 0.5);\n    \n    // Vertical line\n    float vline = step(0.4, sin(time + st.y) * 0.5 + 0.5);\n    \n    // Combine lines to form squares\n    vec2 lines = vec2(hline, vline);\n    \n    // Add noise and turbulence for dynamic movement\n    vec3 noiseColor = hsl(\n        (turbulent(vec3(st.x + time, st.y + time, 0.0)) * 0.5 + 0.5) * 360.0,\n        1.0,\n        0.7\n    );\n    \n    // Convert HSL to RGB and mix with background\n    vec3 color = hsl2rgb(noiseColor);\n    vec3 finalColor = mix(vec3(0.0), color, lines.x * lines.y);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1123.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying coordinates\n    vec2 st = uv * 10.0 + sin(iTime * 0.5) * 3.0;\n    \n    // Generate noise values with different scales\n    float n1 = noise(st + iTime * 0.5);\n    float n2 = turbulent(st * 0.5 + iTime * 0.7);\n    \n    // Combine noise and time for color transitions\n    float value = sin(n1 * 3.0 + iTime) * 0.5 + 0.5;\n    value += sin(n2 * 2.0 + iTime * 0.3) * 0.3;\n    \n    // Create smooth color transitions using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        (value * 360.0 + iTime * 180.0) / 360.0,   // Hue\n        0.7 + sin(iTime * 0.5) * 0.2,               // Saturation\n        0.5 + cos(iTime * 0.4) * 0.3               // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1124.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float frequency = 8.0;\n    float speed = 1.5;\n    \n    // Create rotating pattern using sine and cosine functions\n    vec2 st = uv * frequency;\n    float time = iTime * speed;\n    \n    // Calculate oscillating values for x and y directions\n    float xOsc = sin(st.x + time) * cos(time);\n    float yOsc = cos(st.y - time) * sin(time);\n    \n    // Combine x and y oscillations with different phase shifts for RGB channels\n    vec3 color;\n    color.r = sin(xOsc + yOsc + time) * 0.5 + 0.5;\n    color.g = sin(xOsc - yOsc + time + (2.0 * PI)/3.0) * 0.5 + 0.5;\n    color.b = sin(xOsc + yOsc + time + (4.0 * PI)/3.0) * 0.5 + 0.5;\n    \n    // Add turbulence to create more dynamic pattern\n    vec2 noiseUV = uv * 10.0;\n    float turbulence = turbulent(noiseUV);\n    color *= 1.0 + turbulence * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1125.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and shift UV coordinates over time\n    vec2 st = uv * 2.0 + iTime;\n    \n    // Create a noise-based offset for color shifting\n    float n1 = noise(st + vec2(0.0, 0.0));\n    float n2 = noise(st + vec2(1.0, 1.0) * 0.5);\n    \n    // Combine noise values with sine wave modulation\n    float hueShift = sin(iTime * 0.5) * 0.5 + 0.5;\n    float saturation = cos(iTime) * 0.5 + 0.7;\n    \n    // Create HSL color based on UV coordinates and time\n    vec3 hslColor = vec3(\n        (st.x * 0.5 + st.y * 0.5 + iTime) * 0.1,\n        saturation,\n        0.5 + n1 * 0.2\n    );\n    \n    // Convert HSL to RGB and add noise variation\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor += vec3(n1, n2, turbulent(st)) * 0.2;\n    \n    // Add time-based color shifting\n    rgbColor *= sin(uv.x * pi + iTime) * 0.5 + 0.5;\n    rgbColor = clamp(rgbColor, 0.0, 1.0);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1126.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x);\n    // Create shifting lines pattern\n    float linePattern = sin(theta * 8.0 + iTime) * 0.5 + 0.5;\n    \n    // Add depth effect using perspective projection\n    vec3 color = hsl(\n        (theta / PI + 1.0) * 0.5,   // Hue based on angle\n        0.7 + linePattern * 0.3,     // Saturation modulation\n        0.5 + noise(vec2(r * 4.0, iTime)) * 0.5  // Value with noise\n    );\n    \n    // Convert to RGB and apply perspective distortion\n    color = hsl2rgb(color) / (r * 3.0 + 1.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1127.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates relative to center\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    \n    // Create rotating pattern using time and angle\n    float time = iTime * 3.0;\n    a += time;\n    \n    // Create expanding rings effect\n    float ring = sin(r * 15.0 + time) * 0.5 + 0.5;\n    ring = mod(ring, 1.0);\n    \n    // Use angle to create rainbow colors\n    vec3 color = hsl(a / (2.0 * PI), 1.0, 0.5);\n    \n    // Add pulsing effect to rings\n    float pulse = sin(time * 0.5 + r * 10.0) * 0.5 + 0.5;\n    color = mix(color, vec3(1.0), pulse);\n    \n    // Combine ring pattern with color\n    color *= ring;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1128.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using HSL\n    vec3 baseColor = hsl2rgb(vec3(0.5 + sin(iTime * 0.5) * 0.5, 1.0, 0.8));\n    \n    // Add sine wave modulation based on time and position\n    float freq = 4.0;\n    vec3 sineMod = vec3(\n        sin(uv.x * freq * 2.0 + iTime) * 0.5 + 0.5,\n        sin(uv.y * freq * 3.0 + iTime * 0.7) * 0.5 + 0.5,\n        sin((uv.x + uv.y) * freq * 4.0 + iTime * 1.2) * 0.5 + 0.5\n    );\n    \n    // Add turbulence effect\n    vec3 turb = vec3(turbulent(uv * 8.0 + vec2(iTime)), \n                    turbulent(uv * 6.0 + vec2(iTime * 0.7)),\n                    turbulent(uv * 4.0 + vec2(iTime * 1.2)));\n    \n    // Combine effects\n    vec3 finalColor = mix(baseColor, sineMod, 0.5) + turb * 0.3;\n    finalColor = clamp(finalColor, 0.0, 1.0);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1129.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using sine waves with time-based modulation\n    float speed = 0.5;\n    vec2 st = uv * 10.0; // Scale up coordinates for more detailed patterns\n    \n    // Add time-based oscillation\n    float timeMod = sin(iTime * speed) * 0.5 + 0.5;\n    \n    // Create a pattern using sine functions in both x and y directions\n    float patternX = sin(st.x * 2.0 + iTime * speed) * 0.5 + 0.5;\n    float patternY = sin(st.y * 2.0 + iTime * speed * 0.7) * 0.5 + 0.5;\n    \n    // Combine patterns and add turbulence\n    float combined = (patternX + patternY) * 0.5;\n    combined += turbulent(vec3(uv * 10.0, iTime)) * 0.2; // Add some randomness\n    \n    // Create a color shift effect using HSL colorspace\n    vec3 hslColor = vec3(\n        sin(iTime * 0.3 + uv.x * 5.0) * 0.5 + 0.5, // Hue variation\n        0.7, // Saturation\n        combined * 0.6 + 0.4 // Lightness based on pattern\n    );\n    \n    // Convert HSL to RGB and add some RGB variations\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor += sin(vec3(uv.x, uv.y, iTime) * 15.0 + vec3(0.0, 0.7, 1.4)) * 0.2;\n    \n    // Final color with alpha\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_113.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create central point\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan(pos.y, pos.x);\n    \n    // Add noise and time variation\n    float noiseVal = turbulent(uv * 5.0 + iTime) * 0.3;\n    float timeScale = iTime * 0.2;\n    \n    // Create orbiting rings\n    vec3 color = hsl2rgb(vec3(0.0, 0.0, 0.1));\n    for(float i = 0.0; i < 5.0; i++) {\n        float orbitRadius = 0.2 + i * 0.15;\n        float angleOffset = timeScale + i * 0.3;\n        \n        // Calculate distance from current orbit\n        float dist = abs(r - orbitRadius);\n        if(dist < 0.03) {\n            // Add color variation to orbits\n            vec3 orbitColor = hsl2rgb(vec3((theta + angleOffset) * 0.1, 0.7, 0.4));\n            color += orbitColor * (1.0 - dist / 0.03);\n        }\n    }\n    \n    // Add central star glow\n    if(r < 0.1) {\n        float glow = smoothstep(0.05, 0.0, r);\n        color += vec3(1.0, 0.9, 0.7) * glow;\n    }\n    \n    // Add orbiting points (planets)\n    for(float i = 0.0; i < 4.0; i++) {\n        float angle = timeScale + i * 0.5;\n        vec2 planetPos = vec2(cos(angle), sin(angle)) * (0.2 + i * 0.15);\n        if(length(pos - planetPos) < 0.03) {\n            color += hsl2rgb(vec3(0.0, 0.8, 0.6));\n        }\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1130.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 result;\n    \n    // Scale UV coordinates for pattern size\n    vec2 st = uv * 50.0;\n    \n    // Time-based animation\n    float time = iTime * 0.2; // Speed control\n    \n    // Color components with different frequencies\n    float red = sin(st.x * 0.1 + time) * 0.5 + 0.5;\n    float green = sin(st.y * 0.3 + time * 2.0) * 0.5 + 0.5;\n    float blue = sin(length(st) * 0.5 + time * 4.0) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for more dynamic patterns\n    red += noise(st * 0.1) * 0.3;\n    green += turbulent(st * 0.2) * 0.2;\n    blue += noise((st.x + time)*vec2(1.0, 0.5)) * 0.4;\n    \n    // Clamp values to prevent overflow\n    red = clamp(red, 0.0, 1.0);\n    green = clamp(green, 0.0, 1.0);\n    blue = clamp(blue, 0.0, 1.0);\n    \n    result = vec4(red, green, blue, 1.0);\n    return result;\n}"
  },
  "data_1131.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create RGB sine waves with different phases\n    vec3 color = vec3(\n        sin(uv.x * 4.0 + time) * 0.5 + 0.5,\n        sin(uv.y * 4.0 + time * 0.7) * 0.5 + 0.5,\n        sin((uv.x + uv.y) * 3.0 - time) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence for more dynamic effect\n    vec2 pos = uv * 4.0;\n    color += turbulent(pos + time) * 0.3;\n    \n    // Shift hues over time\n    color = hsl2rgb(vec3(\n        mod(time * 0.1, 1.0),\n        0.7,\n        0.5\n    )) * color;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1132.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based modulation\n    float t = iTime * 0.5;\n    \n    // Generate base patterns using sine waves\n    vec3 color1 = sin(vec3(6.0, 7.0, 8.0) * uv.x + t);\n    vec3 color2 = sin(vec3(4.0, 5.0, 6.0) * uv.y - t);\n    \n    // Add noise and turbulence\n    float noise1 = noise(uv * 4.0 + t);\n    float noise2 = turbulent(vec3(uv * 2.0, t));\n    \n    // Combine patterns with noise\n    vec3 combined = (color1 + color2) * 0.5;\n    combined += noise1 * 0.3;\n    combined += noise2 * 0.4;\n    \n    // Convert to HSL and back for smooth transitions\n    vec3 hslColor = hsl(0.5, 0.7, 0.6 + sin(t) * 0.3);\n    vec3 finalColor = hsv2rgb(vec3(combined.x, combined.y, combined.z));\n    \n    // Mix colors and add glow effect\n    finalColor = mix(finalColor, hslColor, 0.4);\n    finalColor *= 1.5 - length(uv * 1.5); // Add radial falloff\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1133.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Time-based rotation\n    float t = iTime * 0.5;\n    vec2 rot = vec2(cos(t), sin(t));\n    \n    // Create grid pattern with rotating squares\n    vec2 grid = floor(uv * 4.0);\n    vec2 cell = fract(uv * 4.0 - 0.5) * 2.0 - 1.0;\n    \n    // Apply rotation matrix to each square\n    vec2 rotated = vec2(\n        cell.x * rot.x - cell.y * rot.y,\n        cell.x * rot.y + cell.y * rot.x\n    );\n    \n    // Create square mask with color transitions\n    float dist = length(rotated);\n    float mask = 1.0 - smoothstep(0.4, 0.5, max(abs(rotated.x), abs(rotated.y)));\n    \n    // Color based on HSL with time variation\n    vec3 color = hsl2rgb(vec3(\n        (t + grid.x * 0.25) * 180.0,\n        0.7,\n        0.5 + 0.5 * sin(t + grid.y * 0.25)\n    ));\n    \n    // Add noise for extra variation\n    float noiseVal = noise(vec3(grid, t)) * 0.1;\n    color *= 1.0 + noiseVal;\n    \n    return vec4(color * mask, 1.0);\n}"
  },
  "data_1134.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 5.0;\n    \n    // Create flowing pattern using noise and time\n    float flow = noise(vec2(theta + iTime * 0.5, r * 0.1));\n    flow += turbulent(vec2(theta - iTime * 0.3, r * 0.2)) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl2rgb(vec3(0.6 + flow * 0.4, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.2 + flow * 0.6, 0.7, 0.6));\n    \n    // Combine colors based on pattern\n    float blend = smoothstep(0.0, 1.0, sin(r + iTime) * 0.5 + 0.5);\n    vec3 finalColor = mix(color1, color2, blend);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1135.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for a grid pattern\n    vec2 st = uv * 20.0;\n    \n    // Create integer grid coordinates\n    vec2 grid = floor(st);\n    \n    // Calculate pulsation using sine function\n    float pulse = sin(iTime + grid.x + grid.y) * 0.5 + 0.5;\n    \n    // Offset UV coordinates based on pulsation\n    vec2 offset = (st - grid) - 0.5;\n    offset *= 1.0 + pulse * 2.0;\n    \n    // Create color transitions using HSL\n    float hue = iTime * 0.1 + grid.x * 0.3 + grid.y * 0.4;\n    vec3 color = hsl(hue, 0.7, 0.5);\n    \n    // Add noise for variation\n    float noiseVal = noise(grid) * 0.2;\n    color += noiseVal;\n    \n    // Combine pulsation and color\n    vec3 finalColor = mix(vec3(0.1), color, pulse);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1136.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add time-based movement\n    vec2 st = uv * 4.0 + iTime;\n    \n    // Create a turbulent noise pattern\n    float t1 = turbulent(st);\n    \n    // Add another layer of turbulence with offset\n    float t2 = turbulent(st + vec2(1.5, 3.2));\n    \n    // Combine turbulence values and scale for color transitions\n    float hue = (t1 + t2 * 0.5) * 0.5;\n    \n    // Create smooth color transitions using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(hue, 0.7, 0.6));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1137.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern with sine waves\n    float pattern = sin(uv.y * 10.0 + iTime) * 0.5 + 0.5;\n    \n    // Add horizontal movement and create interference patterns\n    pattern += sin(2.0 * uv.x - iTime * 0.5) * 0.3;\n    \n    // Use turbulence to add noise and complexity\n    float noise = turbulent(vec2(uv.x * 10.0, uv.y * 10.0)) * 0.2;\n    \n    // Combine patterns and add time-based color variation\n    vec3 color = hsl2rgb(vec3(\n        (pattern + noise) * 0.5 + iTime * 0.1,\n        0.7,\n        0.6\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1138.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset UV coordinates for a more interesting pattern\n    vec2 st = uv * 8.0 + iTime;\n    \n    // Create a grid of points using fract and noise\n    vec2 grid = fract(st);\n    \n    // Calculate distance from center to create circular patterns\n    float dist = length(grid - 0.5);\n    \n    // Use time to animate the colors\n    float hue = iTime * 0.1;\n    \n    // Create a color based on HSL values\n    vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Add turbulence for dynamic noise effect\n    float turb = turbulent(vec3(st, iTime)) * 0.5 + 0.5;\n    \n    // Mix colors based on distance and noise\n    vec3 finalColor = mix(color, vec3(1.0), dist * turb);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1139.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 result;\n    \n    // Create a base pattern using noise and time\n    float base = noise(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    \n    // Add smooth sine wave transitions\n    float timeFactor = sin(iTime * 0.5) * 0.5 + 0.5;\n    float pattern = base + sin(uv.x * 10.0 + iTime) * 0.3;\n    \n    // Create a color transition using HSL\n    vec3 color = hsl2rgb(vec3(\n        (uv.x + uv.y + timeFactor) * 360.0,\n        0.7,\n        0.5\n    ));\n    \n    // Add turbulence for more dynamic effect\n    float turb = turbulent(vec2(uv.x + sin(iTime), uv.y)) * 0.3;\n    \n    // Combine all elements into the final color\n    result.rgb = color * (pattern + turb);\n    result.a = 1.0;\n    \n    return result;\n}"
  },
  "data_114.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a dark blue background with noise texture\n    vec3 bg = mix(vec3(0.1, 0.15, 0.2), vec3(0.0), uv.y * 0.5 + 0.5);\n    \n    // Add moon glow using noise and turbulence\n    float moonGlow = noise(vec3(uv * 0.5 + iTime * 0.1, iTime)) * 0.2;\n    bg += vec3(0.9, 0.85, 0.7) * moonGlow;\n    \n    // Create owl shape with procedural noise\n    float dist = length(uv - vec2(sin(iTime)*0.4 + 0.5, cos(iTime*0.7)*0.3 + 0.6));\n    float owlShape = smoothstep(0.15, 0.0, dist);\n    \n    // Add wing animation\n    float wingFlap = sin(iTime * 2.0) * 0.4;\n    vec2 wingPos = uv - vec2(sin(iTime)*0.3 + 0.5, cos(iTime*0.7)*0.3 + 0.6);\n    float wingShape = smoothstep(0.15, 0.0, length(wingPos));\n    \n    // Create stage lights with turbulence\n    float stageLight = turbulent(vec2(uv.x * 4.0, uv.y - 0.8)) * 0.3;\n    bg += vec3(0.7, 0.5, 0.1) * stageLight;\n    \n    // Combine elements with color transformations\n    vec3 finalColor = hsl2rgb(vec3(\n        (moonGlow + wingShape) * 180.0,\n        0.6 + moonGlow * 0.4,\n        0.5 + stageLight * 0.3\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1140.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a value that changes with position and time\n    float pattern = sin(uv.x * 10.0 + iTime * 5.0) * \n                   cos(uv.y * 10.0 + iTime * 3.0);\n    \n    // Add some noise for complexity\n    vec2 noiseUV = uv * 4.0 + vec2(iTime, 0.0);\n    float turbulence = turbulent(noiseUV);\n    \n    // Combine the patterns and add time-based variation\n    float colorValue = (pattern + turbulence) * 0.5 + 0.5;\n    \n    // Convert to HSL color space for smooth transitions\n    vec3 hslColor = vec3(colorValue, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1141.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5; // Animation speed\n    \n    // Generate noise patterns with different scales\n    float n1 = noise(uv * 100.0 + time);\n    float n2 = noise(uv * 50.0 + time * 0.7);\n    float n3 = noise(uv * 25.0 + time * 0.4);\n    \n    // Combine noise with sine waves for pulsating effect\n    vec3 color;\n    color.r = sin(n1 * pi + time) * 0.5 + 0.5;\n    color.g = sin(n2 * pi + time * 0.9) * 0.5 + 0.5;\n    color.b = sin(n3 * pi + time * 0.6) * 0.5 + 0.5;\n    \n    // Add turbulence for more dynamic movement\n    vec3 turb = vec3(turbulent(uv * 10.0 + time), \n                    turbulent(uv * 12.0 + time * 0.8),\n                    turbulent(uv * 14.0 + time * 0.6));\n    \n    // Combine color and turbulence with HSL conversion\n    vec3 finalColor = hsl2rgb(vec3(\n        (color.r + turb.x) * 0.5,\n        (color.g + turb.y) * 0.7,\n        (color.b + turb.z) * 0.6\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1142.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 centered = uv * 2.0 - 1.0;\n    float theta = atan2(centered.y, centered.x);\n    float r = length(centered);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5; // Rotate at 0.5 radians per second\n    \n    // Create color gradient based on angle and radius\n    vec3 color = hsl(\n        (theta / (2.0 * PI)) + (r * 0.2), // Hue: rotate with time and vary with radius\n        0.7,                              // Saturation\n        0.5                               // Lightness\n    );\n    \n    // Add some turbulence to the color transitions\n    float turb = turbulent(uv * 10.0 + iTime);\n    color = hsl2rgb(vec3(\n        (theta / (2.0 * PI)) + (r * 0.2) + (turb * 0.3), // Add turbulence to hue\n        0.7,\n        0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1143.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar for rotation effect\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create a turbulent pattern with pulsating colors\n    float t = turbulent(vec3(uv * 5.0, iTime * 0.5));\n    \n    // Generate color using HSL to RGB conversion\n    vec3 color = hsl(\n        mod(angle * 0.2 + iTime * 0.1, 1.0), // Hue variation over time and space\n        0.7 + t * 0.3,                       // Saturation modulation\n        0.5 + sin(iTime) * 0.4               // Brightness pulsation\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1144.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating pattern using polar coordinates\n    float radius = length(uv);\n    float angle = atan2(uv.y, uv.x) + iTime * 0.5;\n    \n    // Create geometric shape with multiple frequencies\n    float pattern = sin(angle * 4.0) * 0.5 +\n                    sin(angle * 8.0) * 0.3 +\n                    sin(angle * 16.0) * 0.2;\n    \n    // Add noise and turbulence for dynamic effect\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseVal = noise(noiseUV);\n    float turbulentVal = turbulent(noiseUV * 5.0);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 color = hsl(\n        mod(iTime * 0.2 + angle, 1.0),  // Hue variation over time and position\n        0.7 + noiseVal * 0.3,           // Saturation modulation with noise\n        0.5 + turbulentVal * 0.5        // Lightness modulation with turbulence\n    );\n    \n    // Combine pattern and color for final effect\n    float shape = abs(pattern) * (1.0 - radius * 0.5);\n    vec3 finalColor = mix(color, vec3(0.0), max(0.0, 1.0 - radius));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1145.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Remap UV to center-based coordinates\n    vec2 st = uv - 0.5;\n    \n    // Add time-based rotation\n    float theta = atan2(st.y, st.x) + sin(iTime * 0.5) * 3.0;\n    float r = length(st);\n    \n    // Create base color with rotating hues\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.16 + iTime * 0.2,   // Hue rotation over time\n        0.7 + turbulent(vec2(r, iTime)) * 0.3, // Saturation variation\n        0.5 + sin(iTime) * 0.2         // Brightness variation\n    ));\n    \n    // Add noise and turbulence effects\n    float noise1 = turbulent(vec2(theta, r * 4.0));\n    float noise2 = turbulent(vec2(r * 3.0 + iTime, theta * 2.0));\n    \n    // Combine colors with mix function\n    color = mix(color, hsl2rgb(vec3(\n        theta * 0.16 + iTime * 0.3,\n        0.5,\n        0.7 + sin(iTime) * 0.2\n    )), noise1 * 0.5);\n    \n    // Add final variations\n    color *= 1.0 + noise2 * 0.3;\n    color *= 1.0 - abs(r - 0.5) * 0.8; // Distance falloff\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1146.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add rotation based on time\n    theta += iTime * 0.5;\n    // Create hexagon shape using polar coordinates\n    float hexAngle = theta + radians(30.0); // Offset for hexagon points\n    float hexDistance = abs(sin(hexAngle * 6.0)) / (1.0 - r * 0.5);\n    \n    // Add pulsating effect\n    float pulse = sin(iTime) * 0.2;\n    float radius = r + pulse;\n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        iTime * 0.1,          // Hue\n        0.7 + turbulent(uv * 4.0), // Saturation with noise\n        0.5                  // Lightness\n    );\n    \n    // Convert to RGB and add pulsation effect\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= sin(iTime) * 0.5 + 0.75;\n    // Create glowing border effect\n    float edge = abs(dFdx(radius)) + abs(dFdy(radius));\n    edge = smoothstep(0.0, 1.0, edge * 2.0);\n    \n    // Combine effects and output final color\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(1.0),\n        edge * 0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1147.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating sine wave patterns\n    vec3 color = vec3(\n        sin(uv.x * 10.0 + iTime) * 0.5 + 0.5,\n        sin(uv.y * 10.0 + iTime * 0.9) * 0.5 + 0.5,\n        sin((uv.x + uv.y) * 10.0 + iTime * 0.8) * 0.5 + 0.5\n    );\n    \n    // Add color variation using HSL conversion\n    vec3 hslColor = hsl(\n        sin(iTime * 0.2 + uv.x * 2.0 + uv.y * 3.0) * 0.5 + 0.5,\n        0.7,\n        0.6\n    );\n    \n    // Combine patterns and convert to RGB\n    color = mix(color, hsl2rgb(hslColor), 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1148.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create a noise-based pattern with time variation\n    float noiseValue = noise(vec3(st * 4.0, iTime * 0.1));\n    r += noiseValue * 0.2;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(theta * 0.5 + 0.5, 0.8, 0.6);\n    \n    // Add geometric pattern overlay\n    float pattern = sin(r * 10.0) * cos(theta * 3.0) * 0.5;\n    pattern += sin(r * 5.0) * cos(theta * 5.0) * 0.3;\n    \n    // Combine patterns and colors\n    vec3 finalColor = color + vec3(pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1149.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate position relative to center\n    vec2 pos = uv - 0.5;\n    \n    // Convert to polar coordinates\n    float angle = atan2(pos.y, pos.x);\n    float radius = length(pos);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5; // Adjust speed by changing 0.5\n    \n    // Create smooth color transitions using HSL\n    vec3 hslColor;\n    hslColor.x = fract(angle / (2.0 * PI) + 0.5); // Hue based on angle\n    hslColor.y = 1.0;                            // Full saturation\n    hslColor.z = 0.5 + turbulent(vec2(radius)) * 0.4; // Add noise to value\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_115.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan(st.y, st.x) + iTime;\n    // Create multiple layers of rotating triangles\n    const int layers = 5;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < layers; i++) {\n        // Vary scale and rotation speed per layer\n        float scale = pow(0.5, float(i));\n        float rotateSpeed = 1.0 + float(i) * 0.2;\n        \n        // Calculate rotated coordinates\n        vec2 rotatedUv = vec2(\n            cos(a * rotateSpeed) * st.x - sin(a * rotateSpeed) * st.y,\n            sin(a * rotateSpeed) * st.x + cos(a * rotateSpeed) * st.y\n        );\n        \n        // Create triangle vertices\n        float angleStep = 60.0;\n        vec3 angles = a + vec3(0.0, angleStep, -angleStep);\n        \n        // Calculate distance to each vertex\n        vec2 v1 = rotatedUv - vec2(cos(angles.x), sin(angles.x)) * scale;\n        vec2 v2 = rotatedUv - vec2(cos(angles.y), sin(angles.y)) * scale;\n        vec2 v3 = rotatedUv - vec2(cos(angles.z), sin(angles.z)) * scale;\n        \n        // Find minimum distance to triangle edges\n        float d1 = length(v1);\n        float d2 = length(v2);\n        float d3 = length(v3);\n        float minD = min(min(d1, d2), d3);\n        \n        // Create triangle mask\n        float mask = smoothstep(0.4, 0.5, minD);\n        \n        // Generate color per layer with noise variation\n        vec3 c = hsl(\n            (iTime + float(i)) * 0.1,\n            0.7 + noise(vec2(a, iTime)) * 0.3,\n            0.5 + noise(vec2(r, a)) * 0.5\n        );\n        \n        // Accumulate color with mask\n        color += c * mask;\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1150.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave pattern with dynamic colors\n    \n    // Transform UV coordinates for larger scale\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Add time-based movement\n    float time = iTime * 0.5;\n    \n    // Calculate sine waves in both directions\n    float waveX = sin(st.x + time) * 0.5 + 0.5;\n    float waveY = sin(st.y + time * 0.7) * 0.5 + 0.5;\n    \n    // Combine waves and add noise\n    float pattern = (waveX + waveY) * 0.5;\n    pattern += turbulent(vec2(st.x * 0.5, st.y * 0.5)) * 0.3;\n    \n    // Create color transitions using HSL\n    vec3 colorHSL = vec3(\n        fract(time * 0.1 + pattern * 0.2) * 360.0,\n        0.7,\n        0.5 + sin(time * 0.3 + pattern * 0.4) * 0.2\n    );\n    \n    // Convert to RGB and output\n    vec3 rgbColor = hsl2rgb(colorHSL);\n    \n    return vec4(rgbColor * (sin(pattern * 10.0 + time) * 0.5 + 0.5), 1.0);\n}"
  },
  "data_1151.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create pulsating effect using sine wave\n    float pulse = sin(iTime * 3.0) * 0.5 + 0.5;\n    float radius = r * (1.0 + sin(iTime * 2.0)) * 0.5;\n    // Calculate base color using HSL\n    vec3 hslColor = vec3(\n        a / (2.0 * PI) + 0.5 + iTime * 0.1,\n        0.7,\n        0.6\n    );\n    // Add turbulence to create interesting patterns\n    float noiseValue = turbulent(vec3(uv * 4.0, iTime));\n    hslColor.x += noiseValue * 0.2;\n    radius += noiseValue * 0.1;\n    // Convert HSL to RGB and mix with pulsating white\n    vec3 color = hsl2rgb(hslColor);\n    color = mix(color, vec3(1.0), pulse * 0.5);\n    // Add brightness variation\n    float brightness = sin(iTime) * 0.5 + 0.7;\n    color *= brightness;\n    return vec4(color, 1.0);\n}"
  },
  "data_1152.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv * 1.5); // Scale radius for better pattern spacing\n    \n    // Add time-based rotation and create a rotating color effect\n    theta += iTime * 0.5;\n    \n    // Use turbulence to add dynamic noise patterns\n    float turb = turbulent(vec2(theta, r));\n    \n    // Create HSL color based on polar coordinates and time\n    vec3 hslColor = vec3(\n        (theta + iTime) * 0.1,\n        0.7 + turb * 0.3,\n        0.5 + sin(r * 4.0 + iTime) * 0.5\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1153.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating grid pattern using sine waves\n    vec2 st = uv * 10.0; // Scale UV coordinates\n    \n    // Add time-based oscillation\n    float time = iTime * 0.5;\n    \n    // Calculate grid lines with pulsing effect\n    float xLine = sin(st.x + time) * cos(time);\n    float yLine = cos(st.y + time) * sin(time);\n    \n    // Combine lines and add turbulence for dynamic effect\n    float pattern = sin(xLine + yLine + time) * 0.5 + 0.5;\n    pattern += turbulent(vec2(st.x, st.y)) * 0.3;\n    \n    // Create color shift over time using HSL\n    vec3 color = hsl(pattern * 360.0, 1.0, 0.5);\n    color = hsl2rgb(color);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1154.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset coordinates for better pattern distribution\n    vec2 st = uv * 5.0 - 2.7;\n    \n    // Create a moving position vector with time component\n    vec3 pos = vec3(st.x + iTime*0.5, st.y + iTime*0.3, sin(iTime)*1.5);\n    \n    // Generate noise and turbulence values\n    float n = noise(pos);\n    float t = turbulent(vec2(uv * 4.0 + iTime));\n    \n    // Calculate hue based on position and time\n    float hue = atan2(st.y, st.x) / (2.0 * PI) + 0.5;\n    hue += sin(iTime * 0.3) * 0.5;\n    \n    // Create HSL color from components\n    vec3 hslColor = vec3(hue, 1.0 - abs(n), 0.6 + t*0.4);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1155.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of squares\n    float numTiles = 15.0;\n    vec2 tilePos = floor(uv * numTiles);\n    \n    // Calculate center of each square\n    vec2 center = (tilePos + 0.5) / numTiles;\n    \n    // Calculate distance from center\n    vec2 toCenter = uv - center;\n    float dist = length(toCenter);\n    \n    // Create rotation effect\n    float angle = iTime * 0.5 + tilePos.x * 1.7 + tilePos.y * 3.4;\n    angle += noise(vec3(tilePos, iTime)) * 2.0;\n    vec2 rotated = vec2(\n        toCenter.x * cos(angle) - toCenter.y * sin(angle),\n        toCenter.x * sin(angle) + toCenter.y * cos(angle)\n    );\n    \n    // Calculate color\n    float hue = fract(iTime * 0.1 + tilePos.x * 0.3 + tilePos.y * 0.4);\n    vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Add pulsing effect based on distance\n    float pulse = sin(iTime + dist * 10.0) * 0.5 + 0.5;\n    color *= pulse;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1156.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing noise patterns\n    vec2 st = uv * 5.0 + iTime;\n    float n1 = noise(st);\n    float n2 = noise(st + vec2(1.0, 2.0));\n    \n    // Add turbulence for more complex flow\n    float turb = turbulent(vec3(uv * 4.0, iTime * 0.5));\n    \n    // Combine patterns with different scales\n    float pattern = (n1 + n2) * 0.5 + turb * 0.3;\n    \n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + uv.x * 2.0),\n        0.7,\n        0.5 + pattern * 0.3\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1157.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating patterns using sine waves\n    vec2 st = uv * 5.0 + vec2(sin(iTime)*3.0, cos(iTime)*3.0);\n    \n    // Add time-based rotation\n    float angle = iTime * 0.1;\n    st = mat2(cos(angle), -sin(angle),\n              sin(angle), cos(angle)) * st;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(0.5 + sin(iTime + st.x) * 0.5,\n                              0.7, 0.8));\n    \n    // Add noise and turbulence for depth\n    float turb = turbulent(st);\n    color *= 1.0 - turb * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1158.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    float r = length(uv);\n    float a = atan2(uv.y, uv.x);\n    \n    // Create flowing sine wave patterns\n    float pattern1 = sin(r * 5.0 + iTime) * cos(a * 3.0 + iTime * 0.5);\n    float pattern2 = sin(r * 4.0 - iTime) * sin(a * 6.0 + iTime * 0.7);\n    \n    // Combine patterns with noise\n    float noise1 = noise(vec2(r * 2.0, a));\n    float noise2 = noise(vec2(r * 3.0, a + iTime));\n    \n    // Create turbulence effect\n    float turbulentValue = turbulent(vec2(r * 4.0, a)) * 0.5 + 0.5;\n    \n    // Combine all elements\n    float finalPattern = (pattern1 + pattern2) * 0.5 + noise1 * noise2 * turbulentValue;\n    \n    // Convert to color using HSL\n    vec3 hslColor = vec3(finalPattern * 0.7 + 0.3, 0.8, 0.6);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1159.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create sine wave patterns with varying frequencies\n    float freq = 5.0;\n    vec2 st = uv * freq;\n    \n    // Add time-based phase shift\n    float timePhase = iTime * 0.1;\n    \n    // Calculate sine waves in both directions\n    float xSine = sin(st.x + timePhase) * 0.5 + 0.5;\n    float ySine = sin(st.y + timePhase * 2.0) * 0.5 + 0.5;\n    \n    // Combine patterns using multiplication and addition\n    float pattern = xSine * ySine + (xSine + ySine) * 0.5;\n    \n    // Add noise for extra complexity\n    vec3 noiseParams = vec3(uv * 10.0, iTime);\n    float noiseValue = noise(noiseParams);\n    pattern += noiseValue * 0.2;\n    \n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.5) + 0.5,\n        1.0 - abs(pattern - 0.5) * 2.0,\n        pattern\n    );\n    \n    // Convert to RGB and mix with noise for depth\n    vec3 color = hsl2rgb(hslColor);\n    color += noiseValue * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_116.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan(st.y, st.x);\n    float r = length(st);\n    \n    // Create hexagonal rotation pattern\n    theta += iTime * 0.5;\n    theta *= 6.0; // Hexagon symmetry\n    \n    // Add noise and turbulence\n    vec2 noiseUV = uv + vec2(turbulent(vec3(uv * 10.0, iTime)));\n    float noiseVal = noise(noiseUV);\n    \n    // Create color pattern with shifting hues\n    float hue = theta * 0.5 + iTime;\n    vec3 hslColor = vec3(hue, sin(r * 2.0 + iTime) * 0.5 + 0.5, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine patterns\n    float pattern = abs(sin(theta)) * r;\n    pattern += noiseVal * 0.3;\n    \n    // Final color output\n    return vec4(rgbColor * (1.0 - pattern), 1.0);\n}"
  },
  "data_1160.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    \n    // Pulsating ring parameters\n    float baseRadius = 0.7;\n    float pulsation = sin(iTime * 0.5) * 0.5;\n    float ringWidth = 0.15;\n    \n    // Dynamic color shifting\n    vec3 innerColor = hsl2rgb(vec3((sin(iTime * 0.5) + 1.0) / 2.0, 0.8, 0.6));\n    vec3 outerColor = hsl2rgb(vec3((cos(iTime * 0.5) + 1.0) / 2.0, 0.7, 0.4));\n    \n    // Create inner glow effect\n    float innerGlow = smoothstep(0.0, 0.1, abs(r - (baseRadius - ringWidth)));\n    \n    // Create outer glow effect  \n    float outerGlow = smoothstep(0.0, 0.15, abs(r - (baseRadius + ringWidth + pulsation)));\n    \n    // Combine effects with color\n    vec3 finalColor = mix(\n        innerColor * sin(theta * 8.0 + iTime) * 0.5 + innerColor * 0.5,\n        outerColor * sin(theta * 4.0 + iTime) * 0.5 + outerColor * 0.5,\n        smoothstep(baseRadius - ringWidth, baseRadius + ringWidth, r)\n    );\n    \n    // Add pulsation effect\n    finalColor *= 1.0 + sin(iTime) * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1161.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Remap coordinates from 0-1 range to -1-1 range for easier manipulation\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Convert to polar coordinates\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 4.0; // Scale radius\n    \n    // Add time-based rotation\n    theta += 8.0 * iTime;\n    \n    // Create rotating sine wave pattern\n    float wave1 = sin(r + theta * 5.0 + 2.0 * iTime);\n    float wave2 = sin(theta - r * 3.0 + 4.0 * iTime);\n    float value = (wave1 + wave2) / 2.0;\n    \n    // Add some frequency modulation\n    value += sin(r * 10.0 + theta * 10.0 + 8.0 * iTime) * 0.5;\n    \n    // Create color from HSL values with time-based shifting\n    float hue = theta / (2.0 * PI);\n    float saturation = 0.7 + turbulent(vec3(st.x, st.y, iTime)) * 0.3;\n    float lightness = 0.5 + value * 0.4;\n    \n    // Add some noise to the color\n    vec3 color = hsl(hue, saturation, lightness);\n    color += vec3(turbulent(vec3(st.x*2.0, st.y*2.0, iTime)) * 0.15);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1162.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing movement pattern\n    vec2 st = uv * 5.0 + vec2(sin(iTime)*0.5, cos(iTime*0.7)*0.5);\n    \n    // Add turbulence at different scales\n    float t1 = turbulent(st * 0.5);\n    float t2 = turbulent(st * 1.5);\n    \n    // Combine turbulence layers\n    float noiseValue = (t1 + t2) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(iTime*0.5 + noiseValue*2.0)*0.5 + 0.5,  // Hue variation\n        0.7,  // Saturation\n        abs(noiseValue) * 0.6 + 0.2  // Lightness modulation\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_1163.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Get cell position using floor function\n    vec2 pos = floor(st);\n    \n    // Calculate distance from center of each cell\n    vec2 center = (pos + 0.5) / 10.0;\n    float dist = length(uv - center);\n    \n    // Create pulsing animation using sine and cosine functions\n    float time = iTime * 0.5;\n    float pulse = sin(time + pos.x * 3.1415926) * cos(time + pos.y * 3.1415926);\n    \n    // Generate color pattern using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        (pos.x + time) * 0.1,\n        0.7 + sin(time + pos.y * 3.1415926) * 0.3,\n        0.5 + pulse * 0.5\n    );\n    \n    // Convert HSL to RGB and add noise for glowing effect\n    vec3 color = hsl2rgb(hslColor);\n    color *= 1.0 + turbulent(vec3(st, time)) * 0.5;\n    \n    // Create smooth transitions between cells using distance\n    float blend = smoothstep(0.4, 0.6, dist);\n    \n    // Mix colors based on distance from cell center\n    vec3 finalColor = mix(color, vec3(1.0), blend);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1164.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Add time-based movement and turbulence\n    float time = iTime * 0.5;\n    float radius = r + sin(time) * 0.3;\n    float angle = a + time;\n    // Create color variations using HSL\n    vec3 baseColor = hsl2rgb(vec3(0.5 + sin(angle) * 0.4, 0.7, 0.6));\n    vec3 mixColor = hsl2rgb(vec3(0.3 + cos(angle) * 0.4, 0.8, 0.5));\n    // Combine colors with noise and turbulence\n    float noiseValue = noise(vec3(uv * 10.0, time)) * 0.5 + 0.5;\n    vec3 finalColor = mix(baseColor, mixColor, noiseValue);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1165.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Animate UV coordinates with sine functions\n    vec2 animatedUV = uv + sin(uv * 10.0 + time) * 0.3;\n    animatedUV += sin(uv * 5.0 + time * 0.7) * 0.2;\n    \n    // Add turbulence for more complex patterns\n    float noiseValue = turbulent(animatedUV * 4.0);\n    \n    // Create color from noise values using HSL conversion\n    vec3 color = hsl2rgb(vec3(\n        noiseValue * 360.0,   // Hue\n        0.7 + noiseValue * 0.3, // Saturation\n        0.5 + sin(time) * 0.4  // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1166.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale them\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a base frequency for movement\n    float time = iTime * 0.5;\n    \n    // Add noise to create organic movement patterns\n    vec3 noisePos = vec3(st.x + sin(time), st.y + cos(time * 0.7), time);\n    float n1 = noise(noisePos) * 0.5 + 0.5;\n    float n2 = noise(vec3(st.x, st.y, time)) * 0.5 + 0.5;\n    \n    // Create a flowing pattern using sine waves\n    vec2 flow = vec2(\n        sin(time + st.x * 4.0) * 0.1,\n        cos(time * 0.7 - st.y * 3.0) * 0.1\n    );\n    \n    // Add turbulence for more complex movement patterns\n    float turb = turbulent(vec2(st.x, st.y)) * 0.5 + 0.5;\n    flow += vec2(sin(turb * pi), cos(turb * pi)) * 0.05;\n    \n    // Combine noise and flow to create final position offset\n    vec2 finalPos = st + flow * (n1 + n2);\n    \n    // Create a color gradient that shifts over time\n    float hue = atan2(finalPos.y, finalPos.x) * 0.5 + time;\n    vec3 color = hsl(hue, 0.7, 0.6);\n    \n    // Add brightness variation using noise\n    color *= n1 * 0.8 + 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1167.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating RGB shifts using time-based functions\n    vec3 color = hsl(uv.x * 10.0 + iTime, uv.y * 10.0 - iTime, 0.5);\n    \n    // Add turbulence and noise for more complex patterns\n    vec2 st = uv * 4.0;\n    float t = iTime * 0.5;\n    \n    // Create rotating pattern\n    vec2 pos = uv - 0.5;\n    float angle = length(pos) * 10.0 + t * 2.0;\n    mat2 rot = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 rotatedPos = pos * rot;\n    \n    // Add noise and turbulence\n    float noiseVal = noise(vec3(rotatedPos, iTime)) * 0.5 + 0.5;\n    float turbulentVal = turbulent(rotatedPos * 10.0) * 0.5 + 0.5;\n    \n    // Combine effects for final color\n    vec3 finalColor = hsl2rgb(vec3(\n        uv.x * 3.14 + t,\n        noiseVal,\n        turbulentVal\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1168.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and shift UV coordinates for grid pattern\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create a grid of cells using fract function\n    vec3 color = vec3(fract(sin(st.x)*1000.0), \n                     fract(cos(st.y)*1000.0),\n                     fract(sin(st.x+st.y)*1000.0));\n    \n    // Add turbulence to create flowing effect\n    float turb = turbulent(vec2(uv * 5.0 + iTime*0.5));\n    color += vec3(turb);\n    \n    // Create rotating pattern using polar coordinates\n    float angle = atan2(uv.y - 0.5, uv.x - 0.5) + iTime;\n    float radius = length(uv - 0.5);\n    \n    // Combine rotation and turbulence effects\n    color += vec3(sin(angle)*radius*0.5,\n                 cos(angle)*radius*0.5,\n                 sin(angle+PI/2.0)*radius*0.5);\n    \n    // Final color adjustment using HSL to RGB conversion\n    return vec4(hsl2rgb(vec3(\n        fract(color.r + iTime),\n        0.7 + 0.3*sin(iTime),\n        0.5 + 0.5*cos(iTime)\n    )), 1.0);\n}"
  },
  "data_117.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale coordinates\n    vec2 st = uv - 0.5;\n    st *= 3.0; // Scale up for better detail\n    \n    // Base color with time-based hue shift\n    vec3 baseColor = hsl2rgb(vec3(0.5 + iTime * 0.1, 0.7, 0.6));\n    \n    // Create a turbulent pattern\n    float turb = turbulent(vec3(st.x*0.5, st.y*0.5, iTime*0.2)) * 0.5 + 0.5;\n    \n    // Add radial component\n    float dist = length(st);\n    float radial = (1.0 - smoothstep(0.0, 1.2, dist)) * 0.7;\n    radial += noise(vec3(dist*4.0, iTime*0.2, 0.0)) * 0.3;\n    \n    // Combine patterns\n    float pattern = turb * (radial + 0.3);\n    pattern = mix(radial, turb, pattern) * 1.5;\n    \n    // Color transformation\n    vec3 color = hsv2rgb(vec3(0.6 + iTime*0.1, pattern*0.8 + 0.2, pattern*0.7 + 0.3));\n    \n    // Add distance-based intensity\n    float distFactor = (1.0 - smoothstep(0.0, 1.5, dist)) * 0.6;\n    color *= distFactor + 0.4;\n    \n    // Final pulsation effect\n    color *= sin(iTime*0.3 + pattern*2.0) * 0.5 + 0.7;\n    \n    return vec4(color * 1.2, 1.0);\n}"
  },
  "data_1170.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    vec2 st = uv - 0.5;\n    float d = length(st);\n    \n    // Create rotating pattern using polar coordinates\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Add multiple frequencies for concentric circles\n    theta += sin(theta * 4.0) * cos(iTime) * 0.5;\n    \n    // Create color variations based on distance and angle\n    vec3 color = hsl2rgb(vec3(\n        mod(d * 10.0 + iTime, 1.0),\n        1.0,\n        sin(theta * 2.0 + iTime) * 0.5 + 0.5\n    ));\n    \n    // Add turbulence effect to create dynamic circles\n    float turb = turbulent(vec3(uv * 4.0, iTime));\n    color *= sin(d * 10.0 + theta * 3.0 + turb * 2.0) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1172.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add time-based rotation and expansion\n    theta += iTime * 5.0;\n    r += sin(iTime) * 2.0;\n    \n    // Create swirling pattern using polar coordinates\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.1 + r * 0.2,   // Hue variation based on angle and radius\n        0.7 + turbulent(vec3(uv * 4.0, iTime)) * 0.3, // Saturation with turbulence\n        0.5 + sin(r * 5.0 + iTime) * 0.5 // Brightness variation\n    ));\n    \n    // Add radial color variation\n    color *= vec3(1.0 - r * 0.5);\n    \n    return vec4(color, turbulent(vec2(uv * 2.0)) * 0.5 + 0.5);\n}"
  },
  "data_1173.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to range -1.0 to 1.0\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a center point (mouse position would go here)\n    vec2 center = vec2(0.0);\n    \n    // Calculate distance from center\n    float dist = length(st);\n    \n    // Add circular motion using time and noise\n    float angle = atan2(st.y, st.x) + iTime * 0.5;\n    float radius = 0.3 + turbulent(vec2(angle, iTime)) * 0.2;\n    \n    // Create particle effect\n    float d = length(st - vec2(cos(angle), sin(angle)) * radius);\n    float glow = step(0.1, radius - d) * (radius - d) / 0.1;\n    \n    // Add color variation using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(angle + iTime, PI) / PI,\n        0.7 + turbulent(vec2(st.x * 2.0, st.y * 2.0)) * 0.3,\n        0.5 + glow * 0.5\n    ));\n    \n    // Add glow effect\n    color = mix(color, vec3(1.0), glow);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1174.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create multiple rotating squares\n    for(float i = 0.0; i < 6.0; i++) {\n        for(float j = 0.0; j < 6.0; j++) {\n            // Square position and rotation\n            vec2 pos = vec2(i, j) * 0.18 - 0.5;\n            float time = iTime * (i + j + 1.0) * 0.5;\n            float angle = sin(time) * 0.5 + i * 0.2;\n            \n            // Rotate coordinates\n            vec2 rotatedUv = uv - pos;\n            rotatedUv = vec2(\n                rotatedUv.x * cos(angle) - rotatedUv.y * sin(angle),\n                rotatedUv.x * sin(angle) + rotatedUv.y * cos(angle)\n            );\n            \n            // Square check\n            float d = max(abs(rotatedUv.x), abs(rotatedUv.y));\n            \n            // Color cycling\n            vec3 squareColor = hsl2rgb(vec3(\n                (time + i + j) * 0.1,\n                0.7,\n                0.5 + turbulent(vec3(uv, time)) * 0.5\n            ));\n            \n            // Draw squares with smooth edges\n            if(d < 0.5) {\n                float edge = smoothstep(0.48, 0.5, d);\n                color += squareColor * edge;\n            }\n        }\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1175.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based pulsation\n    r += sin(iTime * 0.5 + theta) * 0.3;\n    // Create a flowing color pattern using HSL\n    vec3 color = hsl(\n        (theta / PI + 1.0) * 0.5,   // Hue based on angle\n        0.7 + turbulent(vec2(r * 4.0, iTime * 0.2)) * 0.3, // Saturation variation\n        0.5 + sin(iTime * 0.2 + r * 10.0) * 0.5          // Brightness variation\n    );\n    // Add noise texture for detail\n    vec2 noiseScale = vec2(4.0, 4.0);\n    float n1 = noise(st * noiseScale + iTime);\n    float n2 = turbulent(st * noiseScale * 2.0 + iTime);\n    // Combine noise and color with light falloff\n    float intensity = (1.0 - exp(-r)) * (n1 * 0.5 + 0.5) * (n2 * 0.5 + 0.5);\n    \n    return vec4(hsl2rgb(color) * intensity, 1.0);\n}"
  },
  "data_1176.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + vec2(sin(iTime), cos(iTime)) * 5.0;\n    \n    // Create rotating color pattern using noise\n    float n = noise(st + vec2(iTime));\n    vec3 color = hsl(n * 0.6 + 0.3, 0.8, 0.7);\n    \n    // Add turbulence for dynamic effect\n    float t = turbulent(st + vec2(iTime * 0.5));\n    color = mix(color, hsl(0.5, 1.0, 0.5), abs(t * 0.5));\n    \n    // Create psychedelic swirl effect\n    float angle = atan2(uv.y - 0.5, uv.x - 0.5);\n    float dist = length(uv - 0.5);\n    color += hsv2rgb(vec3(angle * 0.1 + iTime * 0.1, dist * 0.6 + 0.4, 0.8));\n    \n    // Add noise variation\n    vec2 noiseSt = st * 0.2;\n    float n2 = noise(noiseSt);\n    color += hsv2rgb(vec3(n2 * 0.5 + iTime * 0.1, 0.7, 0.6));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1177.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + vec2(iTime, iTime*0.5);\n    \n    // Create sine wave patterns with different frequencies\n    float a = sin(st.x * 2.0 + iTime) * cos(st.y + iTime*3.0);\n    float b = sin(st.y * 2.0 - iTime*2.0) * cos(st.x + iTime);\n    float c = sin(st.x + st.y + iTime*4.0) * turbulent(vec2(uv)*10.0);\n    \n    // Combine patterns for RGB channels with color shifting\n    vec3 color = vec3(\n        sin(a * 0.5 + iTime) * 0.5 + 0.5,\n        sin(b * 0.7 - iTime*0.5) * 0.5 + 0.5,\n        cos(c * 0.6 + iTime*2.0) * 0.5 + 0.5\n    );\n    \n    // Add some turbulence for extra movement\n    color += vec3(turbulent(vec2(uv)*15.0 + iTime)) * 0.3;\n    \n    return vec4(clamp(color, 0.0, 1.0), 1.0);\n}"
  },
  "data_1178.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base noise pattern with time offset\n    float noise1 = turbulent(uv * 5.0 + iTime);\n    \n    // Create shifting grid lines using sine waves\n    vec2 st = uv;\n    float line1 = sin(st.x * 10.0 + iTime) * 0.5 + 0.5;\n    float line2 = cos(st.y * 10.0 + iTime * 0.5) * 0.5 + 0.5;\n    \n    // Combine lines with noise for organic movement\n    float pattern = (line1 + line2) * 0.5 + noise1 * 0.3;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.1 + pattern, 1.0),  // Hue\n        0.7 + noise(uv * 2.0) * 0.3,       // Saturation\n        0.5 + sin(iTime) * 0.3           // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1179.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern using sine functions for smooth transitions\n    vec2 st = uv * 10.0;\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Calculate distance from center of each cell\n    vec2 center = vec2(0.5, 0.5);\n    float dist = distance(center, fpos);\n    \n    // Create pulsating effect using sine wave\n    float pulse = sin(dist * 10.0 + iTime) * 0.5 + 0.5;\n    \n    // Generate color based on position and time\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + ipos.x * 0.1 + ipos.y * 0.2),\n        0.7,\n        pulse * 0.8 + 0.2\n    );\n    \n    // Convert to RGB and add noise for texture\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= sin(iTime) * 0.5 + 0.5;\n    rgbColor += noise(vec3(uv * 10.0, iTime)) * 0.2;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_118.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x) + iTime * 0.5;\n    float radius = length(st);\n    \n    // Add time-based animation\n    vec3 noisePos = vec3(radius * 4.0, angle * 4.0, iTime * 2.0);\n    float turb = turbulent(noisePos);\n    \n    // Create color variations using HSL\n    vec3 hslColor = vec3(\n        fract(angle * 0.1 + iTime * 0.1),\n        0.7 + turb * 0.3,\n        0.5 + sin(iTime) * 0.2\n    );\n    \n    // Convert to RGB and add noise texture\n    vec3 color = hsl2rgb(hslColor);\n    color *= 1.0 + turbulent(vec2(uv * 4.0)) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1180.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    vec2 st = uv;\n    \n    // Create grid pattern\n    vec2 grid = floor(st * 10.0);\n    float rotation = mod(grid.x + grid.y, 4.0); // Rotate squares in 4 different directions\n    \n    // Calculate rotation angle based on time and position\n    float angle = (rotation * pi/2.0) + iTime*0.5 + sin(grid.x)*0.3;\n    \n    // Apply rotation to UV coordinates\n    vec2 rotatedUV = vec2(\n        cos(angle)*st.x - sin(angle)*st.y,\n        sin(angle)*st.x + cos(angle)*st.y\n    );\n    \n    // Add noise to create dynamic color shifts\n    float noiseValue = noise(vec3(st*10.0, iTime));\n    vec3 hslColor = vec3(\n        mod(grid.x * 0.2 + grid.y * 0.3 + iTime*0.1, 1.0),\n        0.7 + noiseValue*0.3,\n        0.8 + sin(iTime)*0.2\n    );\n    \n    // Convert HSL to RGB and mix with turbulence\n    color = hsl(hslColor.x, hslColor.y, hslColor.z);\n    color *= 1.0 + turbulent(rotatedUV*5.0 + iTime) * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1181.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base wave patterns with different frequencies\n    float wave1 = sin(uv.x * 4.0 + iTime) + cos(uv.y * 4.0 - iTime);\n    float wave2 = sin((uv.x - 0.5) * 6.0 + iTime * 0.5) * cos((uv.y - 0.5) * 6.0 - iTime * 0.5);\n    \n    // Add noise and turbulence\n    vec3 noisePoint1 = vec3(uv.x, uv.y, iTime * 0.2);\n    float turb1 = turbulent(noisePoint1);\n    \n    vec3 noisePoint2 = vec3(uv.y, uv.x, iTime * 0.3) + vec3(10.0);\n    float turb2 = turbulent(noisePoint2);\n    \n    // Combine waves and turbulence\n    float combined = (wave1 * 0.5 + wave2 * 0.5) * (turb1 * 0.5 + turb2 * 0.5);\n    \n    // Create color variations using HSL\n    vec3 hslColor;\n    hslColor.x = fract((combined * 0.5 + iTime * 0.1)) * 360.0; // Hue variation over time\n    hslColor.y = abs(sin(iTime * 0.2) * 0.7 + 0.3); // Saturation modulation\n    hslColor.z = abs(combined * 0.5 + 0.5); // Brightness based on wave pattern\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1182.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating patterns using sine waves\n    vec2 st = uv * 5.0 + vec2(sin(iTime), cos(iTime)) * 3.0;\n    \n    // Add time-based rotation\n    float angle = iTime * 0.1;\n    st = mat2(cos(angle), -sin(angle),\n              sin(angle), cos(angle)) * st;\n    \n    // Create color variations using noise and turbulence\n    float noiseVal = turbulent(st) + turbulent(vec3(st, iTime*0.5));\n    \n    // Generate rotating colors using HSL\n    vec3 hslColor = vec3(\n        mod(noiseVal + iTime, 1.0),   // Hue variation over time\n        0.7 + noiseVal * 0.3,         // Saturation\n        0.5 + sin(iTime) * 0.2       // Lightness variation\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1183.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing noise patterns with time\n    float n = noise(uv * 10.0 + vec2(iTime, iTime));\n    \n    // Create positional sine waves with time offset\n    float waveX = sin(uv.x * 5.0 + iTime * 2.0);\n    float waveY = sin(uv.y * 5.0 + iTime * 3.0);\n    \n    // Combine noise and waves for color variation\n    vec3 color = hsl(\n        mod(iTime * 0.1 + n * 0.5, 1.0),   // Hue variation over time\n        0.7 + n * 0.3,                     // Saturation\n        0.5 + (waveX + waveY) * 0.2         // Brightness modulation\n    );\n    \n    // Add turbulence for more complex patterns\n    vec2 st = uv * 10.0;\n    float turb = turbulent(st + vec2(iTime, iTime));\n    \n    // Mix in some RGB components for depth\n    color += vec3(\n        sin(uv.x * 8.0 + iTime) * 0.5,\n        sin(uv.y * 8.0 + iTime * 1.2) * 0.5,\n        turb * 0.5\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1184.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 pos = uv - 0.5;\n    float dist = length(pos);\n    float angle = atan2(pos.y, pos.x) + iTime * 0.1;\n    \n    // Add circular motion with noise modulation\n    vec2 motion = vec2(sin(angle), cos(angle)) * (0.3 + 0.2 * noise(vec3(uv * 4.0, iTime)));\n    vec2 finalPos = uv + motion * dist;\n    \n    // Calculate color based on position and time\n    float hue = atan2(finalPos.y, finalPos.x) / (2.0 * PI) + 0.5 + iTime * 0.1;\n    vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Add glow effect\n    float glow = max(0.0, 1.0 - length(finalPos - 0.5) * 4.0);\n    glow = smoothstep(0.0, 1.0, glow);\n    \n    return vec4(color, glow);\n}"
  },
  "data_1185.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create smooth color transitions using sine functions\n    float time = iTime * 0.5;\n    \n    // Generate base color with time-based hue shift\n    vec3 color1 = hsl2rgb(vec3(\n        sin(time + uv.x * 2.0) * 0.5 + 0.5,\n        0.7,\n        0.6\n    ));\n    \n    // Add turbulence to create dynamic movement\n    float turb = turbulent(uv * 4.0 + vec2(sin(time), cos(time)));\n    \n    // Create secondary color with offset hue for transition effect\n    vec3 color2 = hsl2rgb(vec3(\n        sin(time + uv.y * 2.0) * 0.5 + 0.5,\n        0.7,\n        0.6\n    ));\n    \n    // Mix colors based on turbulence and position\n    vec3 finalColor = mix(color1, color2, abs(turb * 0.5 + 0.5));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1186.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x) + iTime;  // Add time for rotation\n    \n    // Create a checkerboard pattern using polar coordinates\n    vec2 st = vec2(r * cos(theta), r * sin(theta));\n    float frequency = 10.0;\n    float cell = floor(st.x * frequency);\n    \n    // Alternate colors based on cell position and time\n    vec3 colorA = hsl2rgb(vec3(\n        mod(cell + iTime, 1.0) * 360.0,\n        0.5,\n        0.5\n    ));\n    \n    vec3 colorB = hsl2rgb(vec3(\n        mod(cell + iTime + 0.5, 1.0) * 360.0,\n        0.5,\n        0.5\n    ));\n    \n    // Use turbulence to create dynamic color transitions\n    float noiseA = turbulent(vec3(st.x, st.y, iTime));\n    float noiseB = turbulent(vec3(st.x + 1.0, st.y + 1.0, iTime));\n    \n    vec3 finalColor = mix(colorA, colorB, smoothstep(0.0, 1.0, noiseA * 0.5 + 0.5));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1187.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based animation\n    float time = iTime * 0.5;\n    \n    // Remap UV coordinates to (-1,-1) to (1,1)\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add some movement using sine wave\n    vec2 movement = vec2(sin(time * 0.5), cos(time));\n    st += movement * 0.3;\n    \n    // Create a base color using HSL\n    vec3 baseColor = hsl(0.5, 1.0, 0.5);\n    \n    // Add noise and turbulence for dynamic patterns\n    float noiseValue = noise(vec2(st.x + time, st.y));\n    float turbulentValue = turbulent(vec3(st.x + time, st.y, time * 0.1));\n    \n    // Combine colors using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        0.5 + noiseValue * 0.4,\n        1.0 - abs(turbulentValue) * 0.6,\n        0.5 + turbulentValue * 0.3\n    ));\n    \n    // Mix base color with dynamic color\n    color = mix(baseColor, color, 0.7);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1188.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to -1.0 to 1.0 range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create flowing sine wave pattern with time offset\n    float time = iTime * 0.5;\n    float waveX = sin(st.x * 4.0 + time) * 0.5;\n    float waveY = sin(st.y * 4.0 + time * 0.7) * 0.5;\n    \n    // Combine waves and add noise for complexity\n    vec2 flow = vec2(waveX, waveY);\n    flow += noise(vec3(st * 4.0 + time, time)) * 0.3;\n    \n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        sin(time * 0.5 + st.x * 2.0) * 0.5 + 0.5,\n        0.7,\n        0.8\n    );\n    \n    // Convert to RGB and add turbulence effect\n    vec3 color = hsl2rgb(hslColor);\n    color *= turbulent(vec3(st * 2.0, time)) * 0.5 + 0.5;\n    \n    // Final RGB shift based on flow\n    vec3 finalColor = vec3(\n        color.r + sin(time + st.x) * 0.3,\n        color.g + cos(time + st.y) * 0.3,\n        color.b + sin(time * 0.7 + st.x + st.y) * 0.3\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1189.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave patterns with time-based animation\n    vec2 st = uv * 5.0;\n    float time = iTime * 0.5;\n    \n    // Add noise to create organic movement\n    float n1 = noise(st + vec2(time, 0.0)) * 0.5;\n    float n2 = noise(st + vec2(-time, 0.0)) * 0.5;\n    \n    // Create undulating patterns using sine waves\n    float pattern = sin(st.x * 0.5 + time) + cos(st.y * 0.5 - time);\n    pattern += turbulent(st + vec2(time * 0.5, 0.0)) * 0.3;\n    \n    // Generate color gradients with shifting hues\n    vec3 color1 = hsl2rgb(vec3(0.6 + time * 0.1, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.3 - time * 0.1, 0.8, 0.5));\n    \n    // Mix colors based on pattern and noise values\n    vec3 finalColor = mix(color1, color2, abs(pattern * 0.5 + n1 * 0.3));\n    \n    // Add metallic sheen using noise and turbulence\n    float sheen = turbulent(vec3(st.x, st.y, time)) * 0.3;\n    finalColor += vec3(0.1) + sheen * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_119.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 st = uv - 0.5;\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create rotating pattern using time\n    float time = iTime * 0.5; // Speed control\n    \n    // Create multiple mirrored sections\n    int numSections = 6;\n    theta = mod(theta + time, (2.0 * PI) / float(numSections)) * float(numSections);\n    \n    // Calculate color based on angle and radius\n    vec3 color = hsl2rgb(vec3(\n        theta * 180.0 / PI * 0.5, // Hue based on angle\n        0.7 + 0.3 * sin(r * 10.0 + time), // Saturation variation\n        0.5 + 0.5 * sin(r * 20.0 + theta * 4.0) // Lightness variation\n    ));\n    \n    // Add noise for extra detail\n    float noiseValue = turbulent(vec3(uv * 10.0, time));\n    color *= 1.0 + 0.2 * noiseValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1190.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 0.5 + 0.5;\n    float r = length(st - 0.5);\n    float theta = atan2(st.y - 0.5, st.x - 0.5);\n    // Create pulsating effect using time\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    r *= (1.0 + pulse * 0.3);\n    \n    // Generate color transitions\n    vec3 color1 = hsl2rgb(vec3(0.6 + iTime * 0.1, 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.3 + iTime * 0.15, 1.0, 0.7));\n    \n    // Add noise texture\n    float noiseVal = noise(vec3(st * 4.0, iTime)) * 0.5;\n    color1 += noiseVal;\n    color2 += noiseVal;\n    // Create geometric pattern using polar coordinates\n    float shape = sin(theta * 6.0 + iTime) * 0.5 + 0.5;\n    shape *= smoothstep(0.3, 0.7, r);\n    // Mix colors based on position and time\n    vec3 finalColor = mix(color1, color2, shape);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1191.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Compute two different turbulence patterns\n    float t = turbulent(uv * 100.0 + vec2(iTime));\n    vec3 p = vec3(uv * 50.0, iTime * 0.5);\n    float s = turbulent(p);\n    \n    // Calculate a variation based on the product of the two turbulence values\n    float variation = t * s * 0.1;\n    \n    // Generate a base color in HSL space with time-dependent hue\n    vec3 hslColor = vec3(iTime * 0.5, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Modulate each RGB channel with the turbulence values and variation\n    vec3 finalColor = vec3(\n        clamp(rgbColor.r + t * 0.5, 0.0, 1.0),\n        clamp(rgbColor.g + s * 0.5, 0.0, 1.0),\n        clamp(rgbColor.b + variation * 0.5, 0.0, 1.0)\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1192.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 centeredUV = uv * 2.0 - 1.0;\n    float theta = atan2(centeredUV.y, centeredUV.x);\n    float r = length(centeredUV);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create multiple rings with different colors\n    float ringIndex = sin((theta + iTime) / 3.0 + r) * 10.0;\n    ringIndex = mod(ringIndex, 2.0 * PI);\n    \n    // Use HSL to RGB conversion for smooth color transitions\n    vec3 color = hsl2rgb(vec3(\n        fract(ringIndex / (2.0 * PI)) * 360.0,\n        1.0,\n        0.5\n    ));\n    \n    // Add noise and turbulence effect\n    float noiseValue = noise(vec2(r * 10.0, theta));\n    color *= sin(r * 10.0 + iTime) * 0.5 + 0.5;\n    color += noiseValue * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1193.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 centered = uv - 0.5;\n    \n    // Calculate distance from center\n    float r = length(centered);\n    \n    // Create pulsating circles using time\n    float circle = r + sin(iTime) * 0.5 + iTime * 0.5;\n    \n    // Generate color with shifting hues\n    vec3 color = hsl2rgb(vec3(\n        (circle * 10.0 + iTime) * 0.1,   // Hue\n        0.7,                              // Saturation\n        0.8                               // Lightness\n    ));\n    \n    // Create pulsating alpha based on distance and time\n    float alpha = sin(circle * pi);\n    \n    return vec4(color, alpha);\n}"
  },
  "data_1194.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = hsl(uv.x * 5.0 + iTime, 1.0, 0.5);\n    \n    float timeFactor = iTime * 0.5;\n    float mouseFactor = turbulent(vec2(uv.x, uv.y));\n    \n    color += sin(timeFactor + uv.x * 10.0) * 0.3;\n    color += sin(timeFactor + uv.y * 10.0 + PI/2.0) * 0.3;\n    \n    vec3 rgbLines = hsl2rgb(vec3(\n        sin(uv.x * 5.0 + timeFactor) * 0.5 + 0.5,\n        sin(uv.y * 5.0 + timeFactor + PI/2.0) * 0.5 + 0.5,\n        1.0\n    ));\n    \n    color = mix(color, vec3(1.0), rgbLines);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1195.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern by combining sine waves and turbulence\n    float t = iTime * 0.5;\n    vec2 st = uv - 0.5;\n    \n    // Add rotation effect\n    st.x += sin(iTime) * 0.3;\n    st.y += cos(iTime) * 0.3;\n    \n    // Create stripes pattern with turbulence\n    float pattern = sin(uv.x * 10.0 + t) * 0.5 + 0.5;\n    pattern += turbulent(vec2(st.x * 4.0, st.y * 4.0)) * 0.3;\n    \n    // Convert to HSL for smooth color transitions\n    vec3 hslColor = vec3(pattern * 360.0, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1196.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Calculate radius and angle\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add rotation based on time\n    theta += iTime * 0.5;\n    \n    // Create pulsating radial lines\n    int n = 16; // Number of lines\n    float pulse = sin(theta * float(n) + iTime * 2.0) * 0.5 + 0.5;\n    \n    // Create color wheel effect using HSL\n    vec3 hslColor = vec3(\n        theta / (2.0 * PI), // Hue based on angle\n        1.0,               // Saturation\n        pulse              // Lightness modulated by pulsation\n    );\n    \n    // Convert to RGB and multiply by radius for fading effect\n    vec3 color = hsl2rgb(hslColor) * (1.0 - r * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1197.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float a = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create pulsating effect using time\n    float pulse = sin(iTime * 0.5 + r * 2.0) * 0.5 + 0.5;\n    float radiusPulse = r * (1.0 + pulse * 0.3);\n    \n    // Create spiral pattern with color cycling\n    float angleOffset = iTime * 0.2;\n    float hue = fract((a / PI + angleOffset) * 0.5);\n    \n    // Add noise for extra complexity\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseValue = turbulent(noiseUV) * 0.3;\n    \n    // Combine all elements into final color\n    vec3 hslColor = vec3(hue, 1.0, 0.5 + noiseValue);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1199.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float t = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Add noise and turbulence\n    float noiseValue = turbulent(rotatedUv * 10.0) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(t * 0.2 + noiseValue),\n        0.7,\n        0.6\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add shape elements\n    float distanceFromCenter = length(rotatedUv);\n    float distanceFromCorner = length(abs(rotatedUv) - 1.0);\n    float shapeValue = sin(distanceFromCenter * 8.0 + t) * cos(distanceFromCorner * 4.0 + t);\n    \n    // Combine elements\n    vec3 finalColor = rgbColor * (noiseValue + shapeValue * 0.5);\n    finalColor *= sin(t * 2.0 + noiseValue * pi) * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_12.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 p = vec3(uv * 10.0 + iTime, iTime);\n    float n = noise(p);\n    float t = turbulent(p);\n    \n    float speed = 0.5;\n    float time = iTime * speed;\n    \n    vec3 color1 = hsl(0.5 + sin(time) * 0.2, 0.8, 0.6);\n    vec3 color2 = hsl(0.3 + cos(time) * 0.2, 0.7, 0.5);\n    \n    float mixAmount = fract(sin(time * 0.5) + t * 0.5);\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    return vec4(hsv2rgb(finalColor), 1.0);\n}"
  },
  "data_120.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x);\n    // Create swirling effect with time-based rotation\n    theta += iTime * 0.5;\n    \n    // Add turbulence to create dynamic patterns\n    vec3 noisePos = vec3(uv * 10.0 + iTime, 0.0);\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    \n    // Create expanding rings using sine waves\n    float ring = sin(r * 8.0 + iTime * 2.0) * 0.5 + 0.5;\n    \n    // Combine effects and create color transitions\n    vec3 color = hsl(\n        (theta / (2.0 * PI)) * 360.0,   // Hue based on angle\n        0.7 + turb * 0.3,              // Saturation with turbulence\n        0.5 + ring * 0.5               // Lightness with expanding rings\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1200.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates by a factor that changes with time\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create grid cells using integer division\n    vec2 cell = floor(st);\n    \n    // Calculate pulsation values for each cell\n    float pulse = sin(iTime * 0.5 + cell.x * pi) * 0.5 + 0.5;\n    pulse += sin(iTime * 0.7 + cell.y * pi) * 0.3;\n    \n    // Add noise to create organic movement\n    vec2 noiseSt = st + iTime;\n    float noiseVal = turbulent(noiseSt);\n    pulse += noiseVal * 0.2;\n    \n    // Create color variations using HSL\n    vec3 hslColor = vec3(\n        (cell.x + cell.y) * 0.1 + iTime * 0.5,\n        0.7 + pulse * 0.3,\n        0.5 + noiseVal * 0.2\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_1202.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base grid pattern using sine waves\n    vec2 st = uv * 10.0;\n    float grid = sin(st.x + iTime) * sin(st.y + iTime);\n    \n    // Add noise and turbulence for dynamic effect\n    vec3 noisePos = vec3(uv * 5.0, iTime * 0.1);\n    float turb = turbulent(noisePos);\n    \n    // Combine grid pattern with noise/turbulence\n    grid += turb * 0.5;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(iTime * 2.0, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Mix colors based on grid pattern\n    vec3 finalColor = mix(vec3(0.1), rgbColor, abs(grid));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1203.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add rotation over time\n    \n    // Create pulsating RGB shifts using sine functions with different phases\n    vec3 color = vec3(\n        sin(theta + iTime) * 0.5 + 0.5,\n        sin(theta + iTime * 0.7 + 2.0) * 0.5 + 0.5,\n        sin(theta + iTime * 0.9 + 4.0) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence for more dynamic effect\n    float noiseValue = noise(vec2(uv.x, uv.y) * 10.0 + iTime);\n    color += noiseValue * 0.3;\n    \n    // Create radial gradient effect\n    color *= r * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1204.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Remap UV to (-1,-1) to (1,1) range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add rotation based on time\n    float angle = iTime * 0.5;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    st = rotMatrix * st;\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create color components with sine waves and different offsets\n    vec3 color = vec3(\n        sin(r * 10.0 + iTime) + 0.5,\n        sin(r * 10.0 + iTime + 2.0) + 0.5, \n        sin(r * 10.0 + iTime - 2.0) + 0.5\n    );\n    \n    // Add some turbulence for extra detail\n    color += vec3(turbulent(st * 4.0)) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1205.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float angle = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(angle)*uv.x - sin(angle)*uv.y,\n        sin(angle)*uv.x + cos(angle)*uv.y\n    );\n    \n    // Create sine wave patterns with time offset\n    float waveX = sin(rotatedUv.x * 4.0 + iTime) * 0.5 + 0.5;\n    float waveY = sin(rotatedUv.y * 4.0 - iTime) * 0.5 + 0.5;\n    \n    // Add turbulence for dynamic pattern\n    vec2 noiseUV = rotatedUv * 0.5 + 0.5;\n    float turb = turbulent(noiseUV);\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.1, 1.0),  // Hue changes over time\n        0.7,                    // Saturation\n        0.5 + turb * 0.5        // Brightness varies with turbulence\n    );\n    \n    // Convert HSL to RGB and mix with wave patterns\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = rgbColor * vec3(waveX, waveY, 1.0) * (0.5 + turb * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1206.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 result;\n    \n    // Create polar coordinates from UV\n    float dx = uv.x - 0.5;\n    float dy = uv.y - 0.5;\n    float theta = atan2(dy, dx);\n    float r = length(vec2(dx, dy)) * 10.0;\n    \n    // Add time-based rotation and create multiple layers\n    theta += sin(iTime * 0.5 + theta) * 0.5;\n    theta += sin(theta * 3.0 + iTime) * 0.3;\n    theta += sin(theta * 5.0 - iTime * 2.0) * 0.2;\n    \n    // Create base pattern with noise\n    float pattern = sin(r + iTime) * 0.5 + 0.5;\n    pattern *= sin(theta * 4.0 + iTime * 2.0);\n    pattern += turbulent(uv * 10.0 + iTime) * 0.3;\n    \n    // Create color variations\n    vec3 color = hsl(\n        theta * 0.5 + iTime * 0.1,   // Hue varies with angle and time\n        r * 0.2 + 0.5,              // Saturation increases with radius\n        pattern * 0.6 + 0.4         // Lightness varies with pattern\n    );\n    \n    result = vec4(color, 1.0);\n    return result;\n}"
  },
  "data_1207.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to [-1, 1] range and center them\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add rotation based on time\n    float angle = iTime * 0.5;\n    vec2 rotated = vec2(\n        cos(angle) * st.x - sin(angle) * st.y,\n        sin(angle) * st.x + cos(angle) * st.y\n    );\n    \n    // Create a plasma effect using noise and turbulence\n    float noise1 = turbulent(rotated * 4.0);\n    float noise2 = turbulent(vec3(rotated * 8.0, iTime));\n    float noise3 = turbulent(rotated * 16.0 + vec2(iTime));\n    \n    // Combine noises for color components\n    float r = noise1 * 0.5 + 0.5;\n    float g = noise2 * 0.5 + 0.5;\n    float b = noise3 * 0.5 + 0.5;\n    \n    // Create smooth color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        (r + g + b) * 180.0,   // Hue based on combined noises\n        0.7,                   // Saturation\n        0.5                    // Lightness\n    ));\n    \n    // Add some movement to the colors\n    color *= hsl2rgb(vec3(\n        iTime * 60.0 + noise1 * 360.0,\n        0.5,\n        0.5\n    )) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1208.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate based on time\n    float t = iTime * 0.5;\n    \n    // Generate noise value with time offset\n    float n = noise(uv + vec2(sin(t), cos(t)));\n    \n    // Create base color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        sin(t * 0.7) * 0.5 + 0.5,   // Hue\n        1.0,                       // Saturation\n        0.6                        // Lightness\n    ));\n    \n    // Add flowing sine wave patterns\n    float pattern = sin(uv.x * 8.0 + t) * 0.5 +\n                   sin(uv.y * 4.0 + t * 0.7) * 0.3 +\n                   sin(length(uv) * 2.0 - t) * 0.2;\n    \n    // Combine noise and pattern with color\n    vec3 finalColor = color * (abs(n * 0.5 + 0.5)) *\n                     (sin(pattern * pi) * 0.5 + 0.5);\n    \n    // Add brightness and contrast\n    finalColor = pow(finalColor, vec3(2.2));\n    finalColor = mix(vec3(0.1), finalColor, 0.7);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_1209.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    // Create multiple ring centers with time-based offsets\n    const int numRings = 4;\n    float timeOffset = iTime * 0.5;\n    \n    vec3 colorSum = vec3(0.0);\n    \n    for (int i = 0; i < numRings; i++) {\n        // Calculate ring center with time-based movement\n        float angleOffset = PI * float(i) / float(numRings);\n        vec2 center = vec2(sin(angleOffset + timeOffset), cos(angleOffset + timeOffset)) * 0.5;\n        \n        // Calculate distance from current point to ring center\n        vec2 offsetSt = st - center;\n        float dist = length(offsetSt);\n        \n        // Create expanding rings using sine wave with increasing frequency over time\n        float ringSize = sin(iTime * 0.5 + float(i)) * 0.3 + 0.7;\n        float ringDistance = mod(dist, ringSize) / ringSize;\n        \n        // Use turbulence to add complexity to the pattern\n        vec2 noiseUV = (st + iTime) * 10.0;\n        float noiseValue = turbulent(noiseUV);\n        \n        // Create color variations using HSL\n        float hue = (angleOffset + timeOffset) * 3.0;\n        vec3 baseColor = hsl(hue, 0.7, 0.5);\n        vec3 ringColor = mix(baseColor, vec3(1.0), noiseValue * 0.5 + 0.5);\n        \n        // Additive blending for overlapping rings\n        colorSum += ringColor * (1.0 - abs(ringDistance - 0.5) * 2.0) * 0.4;\n    }\n    \n    // Convert to RGB and apply gamma correction\n    vec3 finalColor = hsl2rgb(colorSum);\n    finalColor = pow(finalColor, vec3(1.0 / 2.2));\n    \n    return vec4(finalColor, max(0.0, colorSum.r + colorSum.g + colorSum.b - 2.5));\n}"
  },
  "data_121.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create rotating sine wave pattern\n    float sa = sin(a + iTime * 3.0);\n    float ca = cos(a + iTime * 3.0);\n    \n    // Add turbulence and noise\n    float noiseVal = turbulent(vec2(r, a)) * 0.5 + 0.5;\n    float pattern = sin(r * 10.0 + iTime) * noiseVal * (sa * ca * 4.0);\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(a * 2.0 + iTime, 1.0), // Hue variation\n        0.7 + noiseVal * 0.3,      // Saturation\n        0.5 + pattern * 0.5       // Brightness modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1210.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of rotating squares\n    vec2 st = uv * 10.0; // Scale up for more cells\n    vec2 ipos = floor(st); // Integer position\n    vec2 fpos = fract(st); // Fractional position\n    \n    // Calculate rotation angle based on time and noise\n    float time = iTime * 0.5;\n    float noiseVal = noise(ipos + time) * 0.5 + 0.5;\n    float angle = (time + noiseVal * 2.0 * PI) * sin(fpos.x * PI);\n    \n    // Create rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    \n    // Transform coordinates\n    vec2 uvLocal = fpos - 0.5;\n    uvLocal = rot * uvLocal + 0.5;\n    \n    // Calculate color based on transformed coordinates and time\n    float hue = (uv.x * 10.0 + time) * 0.1;\n    float sat = sin(uv.y * PI + time) * 0.5 + 0.5;\n    float lig = abs(sin(time)) * 0.5 + 0.25;\n    \n    // Add turbulence for extra detail\n    vec3 color = hsl(hue, sat, lig);\n    color *= turbulent(uvLocal * 10.0) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_1211.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset UV coordinates for pattern size\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create a noise-based pattern using multiple octaves\n    float n1 = noise(st);\n    float n2 = noise(st + vec2(1.3, 4.7) + iTime*0.5);\n    float pattern = sin(n1 * 3.0 + n2) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        fract(pattern + iTime/2.0),   // Hue variation over time and space\n        0.7,                          // Saturation\n        0.6                           // Lightness\n    );\n    \n    // Convert HSL to RGB\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add some dynamic color variations using noise\n    vec3 colorVariation = vec3(\n        noise(vec3(st.x + iTime, st.y, 0.0)) * 0.5 + 0.5,\n        noise(vec3(st.x - iTime, st.y + 1.0, 0.0)) * 0.5 + 0.5,\n        noise(vec3(st.x + st.y + iTime*2.0, 0.0, 0.0)) * 0.5 + 0.5\n    );\n    \n    // Combine colors and add some pulsing effect\n    vec3 finalColor = rgbColor * colorVariation;\n    finalColor *= sin(iTime) * 0.5 + 0.75; // Add global pulsing\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_122.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Scale coordinates for more detailed pattern\n    vec2 st = uv * 10.0;\n    \n    // Add time-based movement\n    float time = iTime * 0.5;\n    \n    // Create shifting pattern using turbulence\n    float t = turbulent(vec3(st + time, time));\n    \n    // Use HSL color with varying hue and lightness\n    vec3 hslColor = vec3(\n        mod(time * 2.0, 1.0),  // Hue\n        0.7,                  // Saturation\n        0.5 + t * 0.5         // Lightness\n    );\n    \n    // Convert to RGB and output\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_123.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create hexagonal grid pattern\n    vec2 grid = vec2(r * cos(a), r * sin(a));\n    grid += noise(vec3(grid, iTime)) * 0.5;\n    \n    // Add turbulence for ethereal effect\n    float turb = turbulent(grid) * 0.5 + 0.5;\n    turb *= sin(iTime * 0.2 + a * 2.0);\n    \n    // Create vibrant color palette\n    vec3 color1 = hsl(a * 0.1 + iTime, 1.0, 0.5);\n    vec3 color2 = hsl(a * 0.1 + iTime + 2.0, 1.0, 0.5);\n    \n    // Combine colors with turbulence\n    vec3 finalColor = mix(color1, color2, turb);\n    \n    // Add fading trail effect\n    float fade = sin(iTime - r * 2.0) * 0.5 + 0.5;\n    finalColor *= fade;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_124.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec2 scale = vec2(10.0, 10.0);\n    \n    // Base noise pattern with animation\n    float n1 = noise(uv * scale + time);\n    \n    // Add higher frequency detail\n    float n2 = noise(uv * scale * 3.0 + time * 2.0);\n    float finalNoise = mix(n1, n2, 0.5);\n    \n    // Create color variations using HSL\n    vec3 color;\n    color.x = fract(time * 0.2 + uv.x * 2.0) * PI; // Hue variation\n    color.y = 0.7 + 0.3 * sin(uv.y * scale.y + time); // Saturation\n    color.z = 0.5 + 0.5 * finalNoise; // Lightness\n    \n    vec3 rgbColor = hsl2rgb(color);\n    \n    // Add movement to the pattern\n    float morphScale = 1.0 + 0.5 * sin(time) * cos(uv.x * PI);\n    vec2 distortedUV = uv * morphScale;\n    \n    // Create rotating pattern\n    float angle = time;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle),\n                         sin(angle), cos(angle));\n    vec2 rotatedUV = distortedUV * rotMatrix;\n    \n    return vec4(rgbColor, 0.8);\n}"
  },
  "data_125.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec3 color = vec3(0.0);\n    \n    // Create orbit traps using circles and lines\n    vec2 pos1 = uv - vec2(sin(time)*0.3, cos(time)*0.3);\n    vec2 pos2 = uv + vec2(sin(time)*0.3, cos(time)*0.3);\n    vec2 center = uv;\n    \n    // Add multiple traps with different sizes and colors\n    float d1 = length(pos1) < 0.4 ? 1.0 : 0.0;\n    float d2 = length(pos2) < 0.4 ? 1.0 : 0.0;\n    float d3 = abs(uv.x * 0.5 + uv.y) < 0.2 ? 1.0 : 0.0;\n    \n    // Accumulate colors from different traps\n    color += hsl(0.1, 0.8, 0.6) * d1;\n    color += hsl(0.3, 0.7, 0.5) * d2;\n    color += hsl(0.5, 0.9, 0.4) * d3;\n    \n    // Add some turbulence for dynamic effect\n    float turb = turbulent(uv + vec2(time)) * 0.1;\n    color *= 1.0 + turb;\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_126.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x);\n    \n    // Add time-based rotation and create expanding rings effect\n    theta += iTime * 0.5;\n    float ring = sin(r * 8.0 + iTime) * 0.5 + 0.5;\n    \n    // Create hexagonal pattern using polar coordinates\n    float angleStep = pi / 3.0;\n    float pattern = sin(theta * 6.0) * ring;\n    \n    // Add turbulence for dynamic effect\n    vec2 noisePos = uv * 10.0 + iTime;\n    float turb = turbulent(noisePos);\n    \n    // Combine effects and create color transitions using HSV\n    float hue = (theta / (2.0 * pi) + 0.5 * sin(r * 4.0 + iTime)) * 360.0;\n    vec3 hsvColor = vec3(hue, 1.0, 1.0);\n    vec3 rgbColor = hsv2rgb(hsvColor);\n    \n    // Final color with alpha\n    return vec4(rgbColor * (pattern + turb * 0.5), 1.0);\n}"
  },
  "data_127.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float angle = sin(iTime * 0.5 + 1.0);\n    vec2 rotatedUv = vec2(\n        uv.x * cos(angle) - uv.y * sin(angle),\n        uv.x * sin(angle) + uv.y * cos(angle)\n    );\n    \n    // Create sine wave pattern with time-based animation\n    float speed = 0.5;\n    float freq = 4.0;\n    vec3 color1 = hsl2rgb(vec3(\n        mod(uv.x * 100.0 + iTime * speed, 360.0) / 360.0,\n        0.7,\n        0.5\n    ));\n    \n    // Add turbulence and noise for dynamic patterns\n    vec2 noiseUv = rotatedUv * 5.0;\n    float noiseVal = noise(noiseUv);\n    float turbulentVal = turbulent(rotatedUv * 10.0 + iTime);\n    \n    // Combine patterns with color gradients\n    vec3 finalColor = mix(\n        hsl2rgb(vec3(\n            mod(uv.y * 100.0 - iTime * speed, 360.0) / 360.0,\n            0.7,\n            0.5\n        )),\n        color1,\n        abs(sin(iTime + uv.x * pi)) * 0.5 + 0.25\n    );\n    \n    // Add noise and turbulence effects\n    finalColor *= (noiseVal * 0.5 + 0.5) * (turbulentVal * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_128.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating geometric pattern using sine and cosine functions\n    float time = iTime * 0.5;\n    \n    // Generate moving patterns with noise and turbulence\n    vec3 colorBase = hsl2rgb(vec3(\n        (sin(uv.x * 10.0 + time) + cos(uv.y * 10.0 + time)) / 4.0 + 0.5,\n        0.7,\n        0.6\n    ));\n    \n    // Add turbulence for dynamic color shifts\n    float turb = turbulent(vec2(uv.x * 5.0, uv.y * 5.0) + time);\n    \n    // Combine colors with turbulence and time-based shifts\n    vec3 finalColor = mix(\n        colorBase,\n        hsl2rgb(vec3((uv.x + uv.y + time / 5.0) * 0.5, 0.8, 0.7)),\n        turb * 0.4\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_129.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based animation\n    float t = iTime * 0.5;\n    \n    // Add noise and turbulence\n    vec3 noisePos = vec3(uv, t);\n    float turb = turbulent(noisePos);\n    \n    // Generate color using HSL to RGB conversion with time-varying hues\n    vec3 hslColor = vec3(sin(t * 0.5) + 0.5, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine elements for the final effect\n    vec4 finalColor = vec4(rgbColor * (0.5 + turb * 0.5), 1.0);\n    \n    return finalColor;\n}"
  },
  "data_13.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.1;\n    \n    // Create a warping effect using multiple frequencies and noise\n    vec2 st = uv;\n    \n    // Add time-based distortion\n    float freq = length(sin(time));\n    st.x += sin(st.y * 3.14 + time) * 0.5;\n    st.y += cos(st.x * 3.14 + time * 0.5) * 0.5;\n    \n    // Add more complex warping using noise\n    float noiseVal = noise(vec2(sin(st.x), cos(st.y)));\n    \n    vec4 result = vec4(\n        sin(st.x * 3.14 + time) * 0.5,\n        cos(st.y * 3.14 + time * 0.5) * 0.5,\n        noiseVal,\n        1.0\n    );\n    \n    return result;\n}"
  },
  "data_130.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base noise pattern with time offset\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Generate multiple noise layers for complexity\n    float n1 = noise(st);\n    float n2 = turbulent(st * 2.0);\n    float n3 = turbulent(st * 4.0 + vec2(iTime));\n    \n    // Combine noise values with different frequencies\n    float value = (n1 * 0.5) + (n2 * 0.3) + (n3 * 0.2);\n    \n    // Create a color transition using HSL to RGB conversion\n    vec3 c = hsl2rgb(vec3(\n        iTime * 0.5 + value * 0.5,   // Hue: time-based shift with noise variation\n        0.7 + n2 * 0.3,             // Saturation: moderate saturation with noise\n        0.5 + n1 * 0.2              // Lightness: mid-tone with noise modulation\n    ));\n    \n    // Add depth by mixing colors based on different noise layers\n    c = mix(c, hsl2rgb(vec3(iTime * 0.7 + n2 * 0.5, 0.6, 0.4)), abs(n3) * 0.5);\n    \n    return vec4(c, 1.0);\n}"
  },
  "data_131.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal patterns\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 6.0; // Add time-based rotation\n    \n    // Create hexagonal tiling pattern using polar coordinates\n    a += sin(r * 5.0 + iTime) * 0.5;\n    vec2 q = vec2(r, a);\n    \n    // Use noise and turbulence for dynamic patterns\n    float noiseVal = noise(vec3(q.x, q.y, iTime)) * 0.5 + 0.5;\n    float turbulentVal = turbulent(vec2(q.x * 10.0, q.y));\n    \n    // Create pulsating color effect using HSL\n    vec3 color = hsl(\n        sin(iTime) * 0.5 + 0.5,   // Hue variation over time\n        0.7 + noiseVal * 0.3,     // Saturation with noise modulation\n        0.5 + sin(iTime * 2.0) * 0.5 + turbulentVal * 0.3  // Pulsating lightness\n    );\n    \n    // Combine all elements for final output\n    vec4 fragColor = vec4(color, 1.0);\n    return fragColor;\n}"
  },
  "data_132.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates from UV\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    // Create concentric circles using sine waves\n    float circle = sin(r * 10.0 + iTime * 2.0) * 0.5 + 0.5;\n    circle += sin(r * 30.0 + iTime * 4.0) * 0.2;\n    // Create RGB shifts that rotate over time\n    float timeAngle = iTime * 0.1;\n    vec3 colorShifts = vec3(\n        sin(timeAngle + 0.0) * 0.5 + 0.5,\n        sin(timeAngle + 2.094) * 0.5 + 0.5, // 2pi/3\n        sin(timeAngle + 4.188) * 0.5 + 0.5  // 4pi/3\n    );\n    // Combine circles with color shifts\n    vec3 finalColor = mix(vec3(0.0), colorShifts, circle);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_133.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating hexagonal grid pattern\n    vec2 st = uv * 5.0; // Scale up for more tiles\n    vec2 pos = floor(st + 0.5); // Get tile position\n    \n    // Convert to polar coordinates\n    float angle = atan2(uv.y, uv.x) + iTime * 0.5;\n    float radius = length(uv);\n    \n    // Create hexagonal grid effect\n    vec2 polar = vec2(radius, angle);\n    vec2 grid = floor(polar / vec2(1.0, pi/3.0));\n    \n    // Add noise and turbulence\n    float noiseVal = noise(vec3(grid + iTime, 0.0)) * 0.5;\n    float turbulentVal = turbulent(vec2(grid.x, grid.y + iTime));\n    \n    // Create pulsating color effect\n    vec3 color = hsl(\n        sin(iTime * 0.25) * 0.5 + 0.5,\n        0.7 + noiseVal * 0.3,\n        0.5 + turbulentVal * 0.5\n    );\n    \n    // Combine effects\n    vec3 finalColor = color * (1.0 - abs(noise(st * 2.0)));\n    finalColor += turbulent(vec2(uv.x, uv.y + iTime)) * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_134.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 fragColor;\n    \n    // Create time-varying position\n    vec2 pos = uv * 5.0 + sin(iTime) * 10.0;\n    \n    // Generate three overlapping sine wave layers with different frequencies\n    float wave1 = sin(pos.x * 3.0 + iTime) * 0.5 + 0.5;\n    float wave2 = sin(pos.y * 4.0 - iTime * 2.0) * 0.5 + 0.5;\n    float wave3 = sin((pos.x + pos.y) * 2.0 + iTime * 3.0) * 0.5 + 0.5;\n    \n    // Combine waves and add turbulence\n    float combined = (wave1 + wave2 + wave3) / 3.0;\n    combined += turbulent(uv * 4.0 + vec2(iTime)) * 0.3;\n    \n    // Create color cycling effect using HSL to RGB conversion\n    vec3 baseColor = hsl2rgb(vec3(\n        sin(iTime * 0.5) * 0.5 + 0.5,   // Hue variation over time\n        1.0,                             // Saturation\n        0.7                              // Lightness\n    ));\n    \n    // Mix colors with noise and waves\n    vec3 finalColor = mix(\n        baseColor,\n        vec3(1.0),                       // White for highlights\n        combined * 0.5 + 0.5             // Combine wave pattern with color cycling\n    );\n    \n    fragColor = vec4(finalColor, 1.0);\n    return fragColor;\n}"
  },
  "data_135.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base pattern using sine waves\n    vec2 st = uv * 10.0;\n    float time = iTime * 0.5;\n    \n    // Flowing sine wave patterns\n    float patternX = sin(st.x + time) * 0.5 + 0.5;\n    float patternY = sin(st.y + time * 0.7) * 0.5 + 0.5;\n    \n    // Create rotating color wheel effect\n    vec2 polar = vec2(\n        length(st - 5.0),\n        atan2(st.y - 5.0, st.x - 5.0)\n    );\n    float angle = polar.y + time;\n    \n    // Combine patterns and colors\n    vec3 color1 = hsl(patternX * 0.7 + 0.3, 0.8, 0.6);\n    vec3 color2 = hsl((patternY + sin(angle) * 0.5 + 0.5) * 0.7 + 0.3, 0.8, 0.6);\n    \n    // Add turbulence for extra detail\n    vec2 noiseUV = uv * 10.0;\n    float turb = turbulent(noiseUV) * 0.3;\n    \n    // Combine everything and output\n    return vec4(\n        (color1 + color2) * (1.0 + turb * 0.5),\n        1.0\n    );\n}"
  },
  "data_136.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Polar coordinates\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    \n    // Pulsating sine waves with multiple frequencies\n    float wave1 = sin(a * 5.0 + iTime * 2.0) * 0.5;\n    float wave2 = sin(a * 7.0 - iTime * 3.0) * 0.4;\n    float wave3 = sin(r * 8.0 + iTime * 1.5) * 0.3;\n    \n    // Combine waves with time modulation\n    float value = (wave1 + wave2 + wave3) * \n                  sin(r * 2.0 + iTime) * 0.5 + 0.5;\n    \n    // RGB shifts based on angle and radius\n    vec3 color = vec3(\n        sin(a + r * 0.5 + iTime * 0.7),\n        sin(a + r * 0.5 + iTime * 0.7 + 2.094),  // 2pi/3\n        sin(a + r * 0.5 + iTime * 0.7 + 4.188)   // 4pi/3\n    );\n    \n    // Add turbulence for more organic feel\n    float turb = turbulent(vec2(st.x*0.5, st.y*0.5)) * \n                 turbulent(vec2(iTime*0.2));\n    \n    // Combine everything and scale output\n    vec3 finalColor = (color + turb) * value * 1.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_137.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan(pos.y, pos.x);\n    // Create gear shape using sine wave pattern\n    float gear = sin(theta * 16.0) * 0.5 + 0.5;\n    gear = smoothstep(0.4, 0.6, gear);\n    \n    // Animate rotation and scale\n    float time = iTime * 0.2;\n    float rot1 = time;\n    float rot2 = -time + theta * 3.0;\n    // Create two interlocking gears with different sizes and rotations\n    vec2 p1 = vec2(cos(rot1) * r, sin(rot1) * r);\n    vec2 p2 = vec2(cos(rot2) * (r * 0.7), sin(rot2) * (r * 0.7));\n    \n    // Add turbulence for dynamic effect\n    float turb = turbulent(vec3(p1 * 5.0, iTime)) * 0.3;\n    gear += turb;\n    // Color cycling using HSL\n    vec3 color1 = hsl2rgb(vec3((iTime + theta) * 0.1, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3((iTime + theta + PI) * 0.1, 1.0, 0.6));\n    // Combine gears with mix\n    float gearA = smoothstep(0.4, 0.5, r);\n    float gearB = smoothstep(0.7, 0.8, r);\n    vec3 finalColor = mix(color1, color2, gearB) * (gearA + gearB);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_138.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base frequency\n    float time = iTime * 0.5;\n    \n    // Generate sine wave patterns with different frequencies\n    float v1 = sin(uv.x * 8.0 + time) * 0.5 + 0.5;\n    float v2 = sin(uv.y * 4.0 + time * 0.7) * 0.3 + 0.3;\n    \n    // Combine with noise for added complexity\n    vec2 noiseUV = uv * 10.0 + vec2(time, time);\n    float noiseVal = noise(noiseUV) * 0.5 + 0.5;\n    \n    // Mix the patterns together\n    float value = v1 + v2 + noiseVal;\n    value = mod(value, 1.0); // Keep within [0,1]\n    \n    // Create shifting hues based on position and time\n    vec3 color = hsl2rgb(vec3(\n        uv.x * 5.0 + time,   // Hue varies across screen and time\n        0.7,                // Saturation\n        value               // Lightness varies with the wave pattern\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_139.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating hexagon pattern using polar coordinates\n    vec2 st = uv * 10.0; // Scale up for more hexagons\n    float theta = atan2(st.y, st.x) + time; // Rotate over time\n    float r = length(st);\n    \n    // Hexagonal tiling pattern\n    float pattern = sin(theta * 6.0) * 0.5 + 0.5;\n    pattern = fract(pattern + sin(r * 0.1 + time));\n    \n    // Color shifting using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(time * 0.2 + st.x * 0.1),\n        0.7,\n        0.5 + 0.5 * sin(r * 0.5 + time)\n    ));\n    \n    // Add turbulence for dynamic effect\n    float noise = turbulent(uv * 10.0 + time);\n    color *= 1.0 + noise * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_14.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add time-based movement\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create base turbulence pattern\n    float t1 = turbulent(st);\n    \n    // Add another layer of turbulence for more complexity\n    float t2 = turbulent(st * 0.5 + iTime);\n    \n    // Combine turbulence values and scale for color range\n    float value = (t1 + t2) * 0.5;\n    \n    // Convert to HSL color space with time-based hue shift\n    vec3 hslColor = vec3(\n        fract(value + iTime),   // Hue\n        0.7,                   // Saturation\n        0.5 + value * 0.5      // Lightness modulation\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_140.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create geometric pattern using polar coordinates\n    float pattern = sin(theta * 6.0) * cos(r * 10.0 + iTime);\n    pattern = abs(pattern);\n    \n    // Mix in noise for added complexity\n    float noiseScale = r * 20.0;\n    float noiseValue = noise(vec2(noiseScale, theta));\n    pattern = mix(pattern, noiseValue, 0.5);\n    \n    // Create dynamic color shifts using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + r * 0.5),  // Hue\n        0.7 + 0.3 * sin(r * 10.0 + iTime),  // Saturation\n        0.5 + 0.5 * pattern  // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_141.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern with sine wave distortion\n    vec2 st = uv * 10.0;\n    \n    // Add time-based distortion to the coordinates\n    float xDistort = sin(st.x + iTime) * 0.5;\n    float yDistort = cos(st.y - iTime) * 0.5;\n    \n    // Create a moving grid pattern using sine waves\n    vec2 grid = vec2(\n        sin(st.x + iTime * 0.5) + xDistort,\n        cos(st.y - iTime * 0.3) + yDistort\n    );\n    \n    // Use turbulence to add more organic movement\n    float turb = turbulent(vec3(grid, iTime)) * 0.2;\n    \n    // Combine the distortions and create a color pattern\n    vec3 color = hsl(\n        mod(st.x + st.y + iTime, PI) / PI,\n        1.0,\n        0.5 + turb\n    );\n    \n    // Create light rays effect using distance from center\n    float dist = length(uv - vec2(0.5));\n    color *= smoothstep(0.7, 0.0, dist);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_142.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create undulating pattern using sine waves with time offset\n    float wave = sin(uv.x * 5.0 + iTime) * 0.5;\n    wave += sin(uv.y * 3.0 + iTime * 0.7 + 1.5708) * 0.5; // Add another perpendicular wave\n    \n    // Mix in some turbulence for organic movement\n    float turb = turbulent(uv * 4.0 + vec2(iTime));\n    \n    // Combine waves and turbulence to create shifting pattern\n    float pattern = (wave + turb) * 0.5 + 0.5;\n    \n    // Create rainbow effect by cycling through hues\n    vec3 color = hsl2rgb(vec3(\n        fract(pattern + iTime / 2.0) * 360.0,   // Hue that shifts over time\n        1.0,                                    // Full saturation\n        0.5                                     // Mid lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_143.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating checkerboard pattern by combining grid positions with rotation matrices\n    vec2 st = uv * 10.0; // Scale up for more cells\n    \n    // Add turbulence to create dynamic variations in the pattern\n    float t = iTime * 0.5;\n    vec2 pos = floor(st + turbulent(uv * 3.0 + t));\n    \n    // Create rotation matrix with time-varying angle\n    float angle = sin(t) * pi * 2.0;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle),\n                         sin(angle), cos(angle));\n                         \n    // Apply rotation to each grid cell position\n    vec2 rotatedPos = (pos - 0.5) * rotMatrix + 0.5;\n    \n    // Calculate color based on checkerboard pattern and time-varying hues\n    float hue = rotatedPos.x * 0.5 + rotatedPos.y * 0.5 + sin(turbulent(vec3(uv, t)) * 2.0);\n    vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Add noise to create more dynamic variations\n    float noiseVal = noise(vec3(st.x, st.y, t)) * 0.5 + 0.5;\n    color *= noiseVal;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_144.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates and normalize by aspect ratio\n    vec2 centerUV = (uv - 0.5) / max(uv.x, uv.y);\n    \n    // Calculate distance from center\n    float dist = length(centerUV);\n    \n    // Create expanding wave effect using time\n    float radius = mod(dist + iTime * 0.1, 1.0);\n    \n    // Convert distance to hue value (0-1 range)\n    vec3 colorHSL = vec3(radius, 1.0, 0.5); // HSL: hue, saturation, lightness\n    \n    // Convert HSL to RGB and return\n    return vec4(hsl2rgb(colorHSL), 1.0);\n}"
  },
  "data_145.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate coordinates over time\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Add noise and turbulence\n    float n1 = noise(st);\n    float n2 = turbulent(st);\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(\n        sin(uv.x * 4.0 + iTime) * 0.5 + 0.5,\n        cos(uv.y * 4.0 - iTime) * 0.5 + 0.5,\n        0.7\n    );\n    \n    // Create multiple cosine layers\n    float wave1 = cos(st.x * 5.0 + iTime * 2.0);\n    float wave2 = cos((st.y + st.x) * 10.0 - iTime * 3.0);\n    float wave3 = cos((st.x * 2.0 + st.y * 3.0) * 20.0 + iTime);\n    \n    // Combine waves and noise\n    float combined = (wave1 + wave2 + wave3) * 0.3;\n    combined += n1 * 0.5 + n2 * 0.2;\n    \n    // Shift RGB channels dynamically\n    vec3 rgbShifts = vec3(\n        sin(iTime * 0.5) * 0.5,\n        cos(iTime * 0.6) * 0.5,\n        sin(iTime * 0.7 + PI) * 0.5\n    );\n    \n    // Final color calculation\n    vec3 finalColor = hsl2rgb(vec3(\n        color.r + rgbShifts.r + combined * 0.2,\n        color.g + rgbShifts.g + combined * 0.2,\n        color.b + rgbShifts.b + combined * 0.2\n    )) * (1.0 + combined * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_146.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating pattern using polar coordinates\n    vec2 st = uv * 1.5; // Scale coordinates for better coverage\n    float angle = atan2(st.y, st.x) + time; // Rotate with time\n    \n    // Add noise and turbulence\n    float dist = length(st);\n    float noiseVal = noise(vec3(uv * 0.5 + time, time)) * 0.5;\n    \n    // Create color variations using HSL\n    vec3 color = hsl2rgb(vec3(\n        angle * 0.1 + time * 0.2,\n        0.7 + noiseVal * 0.3,\n        0.5 + turbulent(vec3(uv, time)) * 0.2\n    ));\n    \n    // Add distance-based modulation\n    color *= sin(dist * 4.0 - time) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_147.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a radial gradient from center\n    vec2 toCenter = uv - 0.5;\n    float dist = length(toCenter);\n    vec2 dir = normalize(toCenter);\n    \n    // Add sine wave distortion based on distance and time\n    float wave = sin(dist * 10.0 + iTime) * 0.3;\n    float wave2 = sin(iTime + uv.x * 5.0) * 0.2;\n    \n    // Create a rotating pattern using polar coordinates\n    vec2 polar = vec2(\n        dist * (dir.x + sin(iTime + dir.y * 10.0)),\n        dist * (dir.y + cos(iTime + dir.x * 10.0))\n    );\n    \n    // Add turbulence for more complex patterns\n    float turb = turbulent(polar * 5.0) * 0.3;\n    \n    // Combine all components into final color\n    vec3 color = hsl2rgb(vec3(\n        (dist + wave + turb) * 180.0,\n        0.7 + sin(iTime) * 0.3,\n        0.5 + cos(dist * 10.0 + iTime) * 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_148.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base displacement using sine waves\n    float displacement = sin(uv.x * 20.0 + iTime) * 0.5;\n    displacement += sin(uv.y * 10.0 + iTime * 0.5) * 0.3;\n    \n    // Add time-based color variation\n    vec3 color = hsl(\n        mod(iTime * 0.2 + displacement, 1.0),  // Hue\n        0.7,                                    // Saturation\n        0.6                                     // Lightness\n    );\n    \n    // Create secondary displacement for layered effect\n    float displacement2 = cos(uv.x * 15.0 - iTime) * 0.4;\n    displacement2 += sin(uv.y * 8.0 + iTime * 0.3) * 0.2;\n    \n    // Combine displacements and create color variation\n    float combinedDisplacement = (displacement + displacement2) * 0.5;\n    vec3 finalColor = hsl2rgb(vec3(\n        mod(iTime * 0.1 + combinedDisplacement, 1.0),  // Hue\n        0.8,                                           // Saturation\n        0.7 + turbulent(uv * 10.0 + iTime) * 0.1       // Lightness with turbulence\n    ));\n    \n    // Add noise and time-based transformations for more detail\n    float noiseValue = noise(uv * 20.0 + vec2(iTime));\n    finalColor += hsv2rgb(vec3(\n        mod(iTime * 0.15, 1.0),   // Hue\n        0.6,                      // Saturation\n        noiseValue * 0.2          // Value with noise modulation\n    ));\n    \n    return vec4(finalColor * (1.0 + sin(iTime) * 0.3), 1.0);\n}"
  },
  "data_149.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float a = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Create rotating sine wave pattern\n    a += sin(iTime * 0.5) * 3.0;\n    vec2 st = vec2(sin(a + iTime), cos(r * 10.0 + iTime));\n    \n    // Add noise and turbulence\n    float noiseVal = noise(st * 4.0 + iTime);\n    noiseVal += turbulent(st * 2.0 + iTime) * 0.5;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(a * 0.1, 0.7, 0.5);\n    color.r += sin(iTime * 0.4 + r * 2.0) * 0.5;\n    color.g += cos(iTime * 0.6 + r * 3.0) * 0.5;\n    color.b += sin(iTime * 0.8 + r * 4.0) * 0.5;\n    \n    // Combine noise with color\n    vec3 finalColor = mix(color, vec3(noiseVal), 0.3);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_15.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Twirling motion\n    float time = iTime * 0.5;\n    float angle = mod(time, PI);\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    st = rotation * (st * 1.5) + vec2(0.5, 0.5);\n    \n    // Morphing noise effect\n    vec2 pos = st;\n    float n = noise(pos * time);\n    \n    // Color transformation and shading\n    vec3 color = hsl2rgb(vec3(\n        mod(time * 4.0 + n, PI),  // Twirling hue\n        0.8,                       // High saturation\n        0.8                        // Bright value\n    ));\n    \n    // Add specular highlight\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    float spec = pow(max(dot(normalize(vec3(pos, 1.0)), light), 0.0), 4.0);\n    color += vec3(1.0) * spec;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_150.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create a flowing liquid effect using noise functions\n    vec2 st = uv * 3.0 - 1.0; // Scale and translate coordinates\n    \n    // Add some movement to the pattern\n    st.x += sin(time + st.y * 2.0) * 0.5;\n    st.y += cos(time * 0.7 + st.x * 2.0) * 0.5;\n    \n    // Create a color gradient based on position and noise\n    vec3 baseColor = hsl(0.6, 0.8, 0.4); // Dark blue\n    \n    // Add flowing liquid effect using turbulence\n    float flow = turbulent(st + time);\n    vec3 liquidColor = mix(baseColor, hsl(0.2, 0.7, 0.5), flow * 0.5 + 0.5);\n    \n    // Create a height-based color variation\n    float height = st.y * 0.5 + 0.5;\n    vec3 finalColor = mix(baseColor, liquidColor, height);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_151.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 centered = uv - 0.5;\n    float radius = length(centered);\n    float angle = atan2(centered.y, centered.x);\n    \n    // Add time-based rotation and expansion\n    angle += iTime * 0.1;\n    radius += sin(iTime) * 0.3 + 0.7;\n    \n    // Create multiple rotating wheels using a grid pattern\n    vec2 grid = fract(uv * 8.0);\n    float wheelRadius = length(grid - 0.5) * 0.6;\n    \n    // Combine rotation and expansion for final color transformation\n    float hue = angle * 0.1 + radius * 0.2 + iTime * 0.3;\n    vec3 color = hsl2rgb(vec3(hue, 0.7, 0.5));\n    \n    // Add subtle gradients using turbulence\n    float noiseValue = turbulent(uv * 4.0 + iTime);\n    color *= mix(1.0, 1.2, noiseValue);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_152.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Normalize coordinates to 0-1 range\n    vec2 st = (uv + 1.0) * 0.5;\n    \n    // Create a grid of squares\n    vec2 gridPos = fract(st * 5.0);\n    \n    // Calculate distance from center of each square\n    vec2 center = gridPos - 0.5;\n    \n    // Rotate coordinates based on time\n    float angle = iTime * 0.1 + noise(vec3(gridPos, 0.0)) * 0.5;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle),\n                         sin(angle), cos(angle));\n    vec2 rotated = rotMatrix * center;\n    \n    // Assign colors to each corner\n    vec3 colorA = hsl(0.0, 1.0, 0.5);\n    vec3 colorB = hsl(0.4, 1.0, 0.5);\n    vec3 colorC = hsl(0.8, 1.0, 0.5);\n    vec3 colorD = hsl(1.2, 1.0, 0.5);\n    \n    // Create smooth transitions between colors\n    vec3 finalColor;\n    if (rotated.x > 0.0 && rotated.y > 0.0) {\n        finalColor = colorA;\n    } else if (rotated.x < 0.0 && rotated.y > 0.0) {\n        finalColor = colorB;\n    } else if (rotated.x < 0.0 && rotated.y < 0.0) {\n        finalColor = colorC;\n    } else {\n        finalColor = colorD;\n    }\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(rotated, iTime * 0.1)) * 0.5 + 0.5;\n    finalColor *= turb;\n    \n    // Create smooth blending between colors\n    float distanceFromCenter = length(center);\n    float alpha = smoothstep(0.4, 0.6, distanceFromCenter);\n    \n    return vec4(mix(finalColor, hsl(0.0, 0.0, 1.0), alpha), 1.0);\n}"
  },
  "data_153.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    float r = length(st);\n    \n    // Create rotating geometric pattern using sine waves\n    float pattern = sin(theta) * cos(r * 4.0 + iTime) +\n                   cos(theta * 2.0) * sin(r * 6.0 - iTime) * 0.5 +\n                   sin(theta * 3.0 + iTime) * cos(r * 8.0) * 0.3;\n    \n    // Add noise texture\n    vec2 noiseScale = uv * 10.0;\n    float noiseVal = noise(noiseScale);\n    pattern += noiseVal * 0.3;\n    \n    // Normalize and create color transitions\n    pattern = (pattern + 1.0) / 2.0;\n    vec3 color = hsl2rgb(vec3(iTime * 0.1, 0.7, 0.5));\n    color *= sin(pattern * pi + iTime) * 0.5 + 0.5;\n    \n    // Combine with noise for final effect\n    float finalPattern = pattern * (noiseVal * 0.3 + 0.7);\n    vec3 finalColor = color * finalPattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_154.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    float time = iTime * 0.5;\n    \n    // Create flowing noise patterns\n    float noise1 = turbulent(uv * 2.0 + time) * 0.5;\n    float noise2 = turbulent(uv * 4.0 + time * 0.5) * 0.5;\n    float noise3 = turbulent(uv * 8.0 + time * 0.3) * 0.25;\n    \n    // Combine noise patterns with color shifts\n    float hue = (noise1 + noise2 + noise3) * 0.5 + time * 0.2;\n    float sat = sin(time * 0.8) * 0.5 + 0.5;\n    float lig = abs(sin(noise3 * pi)) * 0.6 + 0.4;\n    \n    color = hsl2rgb(vec3(hue, sat, lig));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_155.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position using sine waves\n    vec2 pos = sin(iTime * 0.5 + uv * 10.0) * 0.5 + 0.5;\n    \n    // Create two points for triangle vertices\n    vec2 p1 = sin(iTime + uv.yx * 10.0) * 0.4 + 0.5;\n    vec2 p2 = cos(iTime * 0.7 + uv.xy * 8.0) * 0.3 + 0.6;\n    \n    // Add noise to create organic movement\n    p1 += noise(vec3(uv * 4.0, iTime)) * 0.1;\n    p2 += noise(vec3(uv * 5.0, iTime + 1.0)) * 0.1;\n    \n    // Create vectors between points\n    vec2 v1 = p2 - p1;\n    vec2 v2 = uv - p1;\n    \n    // Calculate cross product for triangle winding\n    float cp = dot(v1, vec2(-v2.y, v2.x));\n    \n    // Calculate distance to lines\n    float d1 = length(uv - p1);\n    float d2 = length(uv - p2);\n    float d3 = abs(cp) / length(v1);\n    \n    // Combine distances with turbulence\n    float dist = (d1 + d2 + d3 * 0.5) * 0.3;\n    dist += turbulent(vec3(uv * 4.0, iTime)) * 0.2;\n    \n    // Normalize distance and create color\n    float hue = (dist * 0.5 + 0.5) * 0.7 + sin(iTime * 0.3);\n    vec3 color = hsl2rgb(vec3(hue, 0.8, 0.6));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_156.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave patterns\n    float time = iTime * 0.5;\n    \n    // Moving sine waves in both directions\n    vec2 st = uv * 10.0 + vec2(time, -time);\n    float sines = sin(st.x) * sin(st.y + time) * 0.5 + 0.5;\n    \n    // Rotating color palette using HSL\n    float hue = 0.5 + sin(iTime * 0.3) / 4.0;\n    vec3 color = hsl2rgb(vec3(hue, 1.0, sines));\n    \n    // Add noise for texture\n    vec2 noisePos = vec2(sin(time), uv.y);\n    float n = noise(noisePos * 5.0 + time) * 0.2;\n    \n    // Combine elements\n    color *= 1.0 - abs(n);\n    color += sin(sines * pi + time) * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_157.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and rotate coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    st *= mat2(cos(3.0 * iTime), sin(3.0 * iTime), \n               -sin(3.0 * iTime), cos(3.0 * iTime));\n    \n    // Polar coordinates\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 5.0;\n    \n    // Rotating triangle pattern\n    theta += 3.0 * iTime;\n    vec3 tri = vec3(\n        mod(theta + 120.0, 360.0),\n        mod(theta + 240.0, 360.0),\n        mod(theta, 360.0)\n    ) / 360.0;\n    \n    // Expanding rings\n    float ring = sin(r - iTime * 2.0) * 0.5 + 0.5;\n    ring += sin(r * 2.0 - iTime * 4.0) * 0.5;\n    \n    // Color transformation using HSL\n    vec3 color = hsl(\n        mod(theta / 60.0 + iTime, 1.0),\n        0.7,\n        ring * 0.8 + 0.2\n    );\n    \n    // Add turbulence for extra detail\n    float turb = turbulent(vec3(st.x, st.y, iTime)) * 0.5;\n    color *= 1.0 + turb * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_158.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a position variable centered at 0.0\n    vec2 pos = uv * 2.0 - 1.0;\n    \n    // Add time-based movement\n    float t = iTime * 0.5;\n    vec2 st = pos + vec2(sin(t + pos.x) * 0.3, cos(t + pos.y) * 0.3);\n    \n    // Create a noise-based pattern with turbulence\n    float n = noise(st * 4.0 + t) * 0.5 + 0.5;\n    n += turbulent(st * 2.0 + t) * 0.3;\n    \n    // Convert to HSL color space and back to RGB\n    vec3 color = hsl2rgb(vec3(\n        (n * 0.6 + 0.4) * 360.0,   // Hue\n        1.0 - abs(n - 0.5) * 2.0,  // Saturation\n        n                          // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_159.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating checkerboard pattern\n    float time = iTime * 0.5;\n    \n    // Add some turbulence to the UV coordinates\n    vec2 distortedUV = uv + turbulent(uv * 10.0 + time) * 0.1;\n    \n    // Rotate the coordinates\n    float angle = time;\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    mat2 rotationMatrix = mat2(cosTheta, -sinTheta, sinTheta, cosTheta);\n    vec2 rotatedUV = (distortedUV - 0.5) * rotationMatrix + 0.5;\n    \n    // Create checkerboard pattern\n    vec2 grid = floor(rotatedUV * 10.0);\n    float check = fract(sin(grid.x * 123.456 + grid.y * 789.123) * time);\n    \n    // Generate shifting hues using HSL to RGB conversion\n    vec3 colorBase = hsl2rgb(vec3(fract(time * 0.2 + grid.x * 0.1 + grid.y * 0.2), 0.6, 0.5));\n    vec3 finalColor = mix(colorBase, vec3(1.0), check * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_16.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime;\n    \n    // Add some turbulence\n    float noiseValue = turbulent(vec2(r, theta));\n    \n    // Use HSL for color transformation\n    vec3 colorHSL = hsl(noiseValue * 0.5 + 0.5, \n                       sin(theta) * 0.5 + 0.5,\n                       cos(r * 4.0) * 0.5 + 0.5);\n    \n    // Convert HSL to RGB\n    vec3 colorRGB = hsl2rgb(colorHSL);\n    \n    return vec4(colorRGB, 1.0);\n}"
  },
  "data_160.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Create multiple layers of particles\n    for (float i = 0.0; i < 5.0; i++) {\n        // Offset coordinates for each layer\n        vec2 pos = uv * 10.0 + vec2(i, i) * 0.5;\n        \n        // Add turbulent noise to create dynamic movement\n        float noiseVal = turbulent(vec3(pos, iTime));\n        \n        // Create color variations using HSL\n        vec3 hslColor = vec3(\n            fract(noiseVal + iTime * 0.2),\n            0.8,\n            0.5 + abs(sin(iTime * 0.3 + noiseVal)) * 0.5\n        );\n        \n        // Convert to RGB and add to final color with alpha blending\n        vec3 rgbColor = hsl2rgb(hslColor);\n        finalColor += mix(finalColor, rgbColor, 0.1);\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_161.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color with noise and time\n    vec3 baseColor = hsl2rgb(vec3(noise(uv * 10.0 + iTime), 0.6, 0.5));\n    \n    // Add rotational gradient effect\n    float angle = atan2(sin(iTime), cos(iTime)) + length(uv - 0.5);\n    vec3 gradientColor = hsl2rgb(vec3(angle * 180.0 / PI, 0.7, 0.6));\n    \n    // Add turbulence for flowing effect\n    float turb = turbulent(vec3(uv * 4.0, iTime) * 2.0);\n    baseColor += gradientColor * (turb * 0.5 + 0.5);\n    \n    // Create expanding circles pattern\n    vec2 center = uv - 0.5;\n    float dist = length(center);\n    float timeScale = iTime * 0.1;\n    float circle = step(sin(timeScale) * 0.5 + 0.5, dist);\n    \n    // Combine all elements and output\n    return vec4(baseColor * (circle * 0.3 + 0.7), 1.0);\n}"
  },
  "data_162.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing movement vectors using noise\n    vec3 flow1 = vec3(uv * 0.5 + iTime, 0.0);\n    vec3 flow2 = vec3(uv * -0.5 + iTime * 0.7, 1.0);\n    \n    // Generate turbulent patterns for both flows\n    float turb1 = turbulent(flow1 * 0.5);\n    float turb2 = turbulent(flow2 * 0.5);\n    \n    // Combine turbulence effects with UV coordinates\n    vec2 distortedUV = uv + (turb1 - 0.5) * 0.3 + (turb2 - 0.5) * 0.2;\n    \n    // Create color transitions using HSL to RGB conversion\n    float hue = iTime * 0.2 + length(distortedUV) * 0.5;\n    vec3 baseColor = hsl2rgb(vec3(hue, 1.0, 0.6));\n    \n    // Add depth variation using noise\n    float height = noise(vec3(uv * 0.5 + iTime, 0.0)) * 0.5 + 0.5;\n    \n    // Mix colors and add value variation\n    vec3 finalColor = mix(baseColor, hsl2rgb(vec3(hue + sin(iTime)*0.5, 1.0, 0.4)), height);\n    finalColor *= 0.7 + noise(vec3(uv * 0.2 + iTime*0.3, 0.0)) * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_163.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    \n    // Add rotation based on time\n    theta += iTime * 0.5;\n    \n    // Create a swirling effect by varying the radius with angle\n    vec2 swirlUV = vec2(\n        r * cos(theta + r * 0.5),\n        r * sin(theta + r * 0.5)\n    );\n    \n    // Add turbulence to create dynamic patterns\n    float noiseValue = turbulent(swirlUV * 10.0) * 0.5;\n    theta += noiseValue;\n    \n    // Create color gradient using HSL\n    vec3 hslColor = vec3(\n        theta / (2.0 * PI),   // Hue based on angle\n        0.7 + noiseValue * 0.3,  // Saturation with some noise variation\n        0.5 + sin(iTime) * 0.2  // Lightness varying over time\n    );\n    \n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_164.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Get cell position\n    vec2 pos = floor(st);\n    \n    // Generate noise values for each cell\n    float n = noise(pos + sin(iTime)*0.5);\n    \n    // Create color based on cell state and time\n    vec3 baseColor = hsl(\n        fract(n * 12.0 + iTime) * PI,   // Hue variation over time\n        0.7,                            // Saturation\n        0.5                             // Lightness\n    );\n    \n    // Add turbulence for more dynamic patterns\n    float turb = turbulent(st * 0.5 + vec2(iTime));\n    \n    // Combine color and turbulence\n    vec3 finalColor = baseColor * (0.5 + 0.5 * turb);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_165.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and translate coordinates\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create grid pattern using integer divisions\n    vec2 grid = floor(st);\n    \n    // Calculate distance from center of each cell\n    vec2 dx = fract(st - grid) - 0.5;\n    \n    // Animate waves with time\n    float waveX = sin(grid.x * pi + iTime * 2.0) * 0.5;\n    float waveY = sin(grid.y * pi + iTime * 3.0) * 0.5;\n    \n    // Combine waves and add turbulence\n    float value = sin(dx.x * pi + waveX) + sin(dx.y * pi + waveY);\n    value += turbulent(vec2(grid) + iTime);\n    \n    // Normalize value to [0,1] range for color mapping\n    float nValue = (value + 1.0) * 0.5;\n    \n    // Create RGB color cycling effect using HSL conversion\n    vec3 color = hsl2rgb(vec3(nValue * 360.0, 0.7, 0.5));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_166.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create rotating hexagon pattern using trigonometric functions\n    theta += iTime * 0.5; // Rotate over time\n    \n    // Add turbulence to create dynamic variations\n    float noiseVal = turbulent(vec3(theta, r, iTime)) * 0.5 + 0.5;\n    \n    // Create pulsing color effect using HSL conversion\n    vec3 hslColor = vec3(\n        theta * 180.0 / PI, // Hue based on angle\n        0.7,               // Saturation\n        noiseVal           // Lightness varies with noise and time\n    );\n    \n    // Convert to RGB and mix with another color layer\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add multiple rotating layers for more complexity\n    theta += iTime * 0.7;\n    r *= 0.6;\n    float noiseVal2 = turbulent(vec3(theta, r, iTime)) * 0.5 + 0.5;\n    vec3 hslColor2 = vec3(\n        (theta + PI) * 180.0 / PI, // Offset hue for different color\n        0.7,\n        noiseVal2\n    );\n    vec3 rgbColor2 = hsl2rgb(hslColor2);\n    \n    // Combine both layers with some blending\n    vec3 finalColor = (rgbColor + rgbColor2) * 0.6;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_167.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and tile the UV coordinates\n    vec2 st = fract(uv * 100.0);\n    \n    // Create a base noise pattern with turbulence\n    float n = noise(st + iTime);\n    float t = turbulent(st * 5.0 + iTime);\n    \n    // Combine noise patterns with some math operations\n    float pattern = sin(n * pi) * cos(t * pi) + \n                   sin((st.x + st.y) * pi) * 0.5;\n    \n    // Create a color from HSL values\n    vec3 color = hsl2rgb(vec3(\n        fract(pattern + iTime * 0.1),   // Hue\n        0.7,                            // Saturation\n        0.5 + sin(iTime) * 0.2         // Lightness with time variation\n    ));\n    \n    // Add some turbulence to the color for more dynamic effect\n    vec3 finalColor = color * (1.0 + turbulent(vec3(st.x, st.y, iTime)) * 0.3);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_168.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 q = uv - 0.5;\n    \n    // Calculate polar coordinates\n    float r = length(q);\n    float theta = atan2(q.y, q.x);\n    \n    // Create rotating patterns using multiple frequencies\n    theta += iTime * 0.5; // Slow rotation\n    \n    // Add turbulence and color variations\n    vec3 color = vec3(0.0);\n    \n    // Red channel - slow rotating wheel with radial waves\n    color.r = sin(theta + iTime) * 0.5 + 0.5;\n    color.r *= (1.0 - r * 2.0); // Fade to center\n    \n    // Green channel - faster rotating pattern with turbulence\n    color.g = sin(theta * 3.0 + iTime * 2.0) * 0.5 + \n              sin(r * 8.0 + iTime) * 0.5;\n    \n    // Blue channel - subtle rotating waves\n    color.b = cos(theta * 2.0) * 0.5 + 0.5;\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(q.x*0.1, q.y*0.1, iTime)) * 0.5 + 0.5;\n    color *= turb;\n    \n    return vec4(color * 1.2, 1.0);\n}"
  },
  "data_169.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates around center\n    vec2 rotated = uv - 0.5;\n    float angle = iTime * 0.5; // Rotation speed\n    rotated = vec2(\n        rotated.x * cos(angle) - rotated.y * sin(angle),\n        rotated.x * sin(angle) + rotated.y * cos(angle)\n    );\n    rotated += 0.5;\n    // Checkerboard grid pattern\n    float scale = 8.0;\n    float x = abs(fract(rotated.x * scale) - 0.5);\n    float y = abs(fract(rotated.y * scale) - 0.5);\n    \n    // Combine grid lines\n    float grid = smoothstep(0.0, 1.0, min(x, y));\n    // Color transition based on distance from center\n    vec2 centerDist = uv - 0.5;\n    float dist = length(centerDist);\n    vec3 color = vec3(\n        sin(dist * 8.0 + iTime) * 0.5 + 0.5,\n        cos(dist * 8.0 + iTime + 2.094) * 0.5 + 0.5, // 120 degrees offset\n        cos(dist * 8.0 + iTime - 2.094) * 0.5 + 0.5  // 120 degrees offset\n    );\n    // Mix colors with grid pattern\n    vec3 finalColor = mix(vec3(1.0), color, grid);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_17.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Transform coordinates with time for animation\n    float scale = 1.5 + sin(iTime * 0.5) * 0.5;\n    vec2 stTransformed = (st * scale) * 3.0;\n    \n    // Add rotation based on time\n    float angle = iTime * 4.0;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    stTransformed *= rot;\n    \n    // Use noise texture with transformed coordinates\n    vec2 noiseUV = (stTransformed + uv) * 0.5;\n    vec3 noiseColor = hsl2rgb(hsv2rgb(vec3(noise(uv * 10.0), 0.8, 0.7)));\n    \n    // Add turbulence for detail\n    float t = turbulent(stTransformed * 4.0);\n    \n    // Combine and colorize the effect\n    vec3 finalColor = hsv2rgb(vec3(\n        (noiseColor.r + noiseColor.g + noiseColor.b) / 3.0,\n        0.8,\n        0.9 + sin(t * 5.0 + iTime) * 0.1\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_170.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 center = vec2(0.5);\n    vec2 pos = uv - center;\n    float radius = length(pos);\n    float theta = atan(pos.y, pos.x);\n    \n    // Add time-based rotation\n    theta += 3.0 * iTime;\n    \n    // Create multiple layers of particles\n    const int numLayers = 3;\n    vec4 finalColor = vec4(0.0);\n    \n    for(int i = 0; i < numLayers; i++) {\n        float layerRadius = float(i+1) * 0.25;\n        float speed = float(numLayers - i) * 0.5;\n        \n        // Calculate position in current layer\n        theta += speed * iTime;\n        vec2 dir = vec2(cos(theta), sin(theta));\n        float dist = length(pos);\n        \n        // Add noise to create variation\n        float noiseScale = pow(2.0, float(i)) * 0.1;\n        float perturb = noise(vec3(uv * 8.0 + iTime, i)) * noiseScale;\n        \n        // Blend colors based on distance and noise\n        vec3 colorBase = hsl2rgb(vec3(120.0 + float(i)*60.0, 1.0, 0.5));\n        vec3 color = mix(colorBase, vec3(1.0), perturb * 0.5 + 0.5);\n        \n        // Add to final color with transparency\n        float alpha = max(0.0, 1.0 - abs(dist - layerRadius) / 0.1);\n        alpha *= (perturb + 1.0) * 0.5;\n        \n        finalColor += vec4(color, alpha);\n    }\n    \n    // Add some global noise for extra variation\n    float globalNoise = noise(vec3(uv * 2.0 + iTime, 0)) * 0.2;\n    finalColor.rgb *= 1.0 + globalNoise;\n    \n    return finalColor;\n}"
  },
  "data_171.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    // Create orbiting motion with time\n    theta += sin(iTime * 0.5) * 0.5;\n    \n    // Add turbulence for trail effect\n    vec3 color = vec3(0.0);\n    float t = iTime * 0.2;\n    \n    // Create multiple layers of points\n    for(float i = 0.0; i < 4.0; i++) {\n        float orbitRadius = (i + 1.0) * 0.5;\n        vec2 pos = vec2(cos(theta + t * i), sin(theta + t * i)) * orbitRadius;\n        \n        // Add noise and turbulence\n        float noiseVal = turbulent(pos * 10.0);\n        float dist = length(st - pos);\n        \n        // Create color transitions\n        vec3 warmColor = hsl2rgb(vec3(0.05, 0.8, 0.5 + noiseVal * 0.2));\n        vec3 coolColor = hsl2rgb(vec3(0.6, 0.8, 0.5 + noiseVal * 0.2));\n        \n        // Mix colors based on position\n        color += mix(warmColor, coolColor, mod(r + iTime, 1.0)) * \n                 smoothstep(0.0, 0.1, dist) * (1.0 - noiseVal * 0.5);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_172.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center and angle\n    float d = length(uv);\n    float a = atan2(uv.y, uv.x) / (2.0 * pi) + 0.5;\n    \n    // Create pulsing circular pattern\n    float radius = 0.5 + sin(iTime * 0.5) * 0.3;\n    \n    // Generate noise texture\n    float n = noise(vec3(uv, iTime));\n    \n    // Color transformations using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.6 + a * 0.4, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.3 + a * 0.5, 0.7, 0.8));\n    \n    // Combine colors and noise\n    vec3 finalColor;\n    if (d < radius) {\n        finalColor = mix(color1, color2, n);\n    } else {\n        finalColor = mix(vec3(0.1), color1 * 0.5, n);\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_173.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotational symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x);\n    float radius = length(st);\n    \n    // Create rotating pattern using time\n    float time = iTime * 0.5;\n    angle += time;\n    \n    // Add turbulence to create dynamic patterns\n    vec2 noiseUV = uv + vec2(time * 0.1);\n    float turb = turbulent(noiseUV * 4.0) * 0.5 + 0.5;\n    \n    // Create geometric pattern using sine waves\n    float pattern = sin(angle * 6.0 + time) * cos(radius * 8.0 - time) * 0.5 + 0.5;\n    pattern += turbulent(vec2(angle, radius)) * 0.3;\n    \n    // Mix colors with vibrant transitions\n    vec3 color1 = hsl2rgb(vec3(0.5 + sin(time) * 0.5, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.5 + cos(time) * 0.5, 1.0, 0.6));\n    vec3 finalColor = mix(color1, color2, pattern);\n    \n    // Add noise for texture\n    finalColor += vec3(turb * 0.2);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_174.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates centered at (0.5, 0.5)\n    vec2 centeredUV = uv - 0.5;\n    float radius = length(centeredUV);\n    \n    // Add pulsation effect using time\n    radius += sin(iTime * 2.0) * 0.5;\n    \n    // Calculate angle for color variation\n    float angle = atan2(centeredUV.y, centeredUV.x);\n    \n    // Create color based on distance from center and time\n    vec3 hsvColor = vec3(\n        mod(radius * 5.0 + iTime, 1.0),  // Hue varies with radius and time\n        0.8,                              // Saturation\n        sin(radius * 2.0) * 0.5 + 0.5     // Value varies with radius\n    );\n    \n    return vec4(hsv2rgb(hsvColor), 1.0);\n}"
  },
  "data_175.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-based animation component\n    float time = iTime * 0.5;\n    \n    // Generate base noise pattern\n    vec2 st = uv * 10.0;\n    float baseNoise = noise(st);\n    \n    // Add turbulence for more dynamic effect\n    float turb = turbulent(st * 0.5) * 0.5 + 0.5;\n    \n    // Create flowing color transitions\n    vec3 color = hsl2rgb(vec3(\n        (baseNoise + time) * 0.4 + 0.1,\n        sin(time * 0.7) * 0.5 + 0.5,\n        cos(time * 0.6) * 0.5 + 0.5\n    ));\n    \n    // Add movement and distortion to the pattern\n    vec2 velocity = vec2(\n        sin(time + baseNoise * 10.0),\n        cos(time + baseNoise * 10.0)\n    ) * 0.05;\n    \n    // Combine all elements for final effect\n    vec4 fragColor = vec4(color, 1.0);\n    fragColor.rgb *= mix(0.8, 1.2, turb);\n    fragColor.rgb += velocity.x * 0.3;\n    \n    return fragColor;\n}"
  },
  "data_176.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of triangles\n    vec2 grid = floor(uv * 10.0 + iTime); // Scale and animate grid\n    \n    // Calculate triangle edges using cross product\n    vec2 v1 = abs(grid - uv*2.0 + 0.5);\n    vec2 v2 = abs(grid - uv*2.0 - 0.5);\n    \n    // Create rotating color gradients\n    float angle = atan2(v1.y, v1.x) + iTime;\n    float radius = length(v1);\n    \n    // HSV color with rotating gradient\n    vec3 hsvColor = vec3(angle * 0.1, radius * 0.5 + 0.5, 1.0);\n    vec3 rgbColor = hsv2rgb(hsvColor);\n    \n    // Add pulsing effect\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    return vec4(rgbColor * pulse, 1.0);\n}"
  },
  "data_177.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 8.0 + iTime;\n    \n    // Create base sine wave patterns\n    float base = sin(st.x * 4.0 + iTime) * 0.5 + 0.5;\n    base += sin(st.y * 4.0 + iTime * 2.0) * 0.5;\n    \n    // Add noise and turbulence for complexity\n    vec2 noiseSt = st * 0.5 + vec2(iTime);\n    float n1 = noise(noiseSt) * 0.5 + 0.5;\n    float t1 = turbulent(vec3(st, iTime)) * 0.5 + 0.5;\n    \n    // Combine patterns with color shifts\n    vec3 color1 = hsl2rgb(vec3(n1 * 0.6 + 0.3, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(t1 * 0.6 + 0.3, 0.8, 0.5));\n    \n    // Mix layers with varying weights\n    vec3 finalColor = mix(color1, color2, t1);\n    finalColor *= base * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_178.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 pos = uv * 2.0 - 1.0;\n    \n    float time = iTime * 0.5;\n    float angle = cos(time) * length(pos);\n    angle += sin(time + length(uv)) * fract(atan2(pos.y, pos.x));\n    \n    float dist = length(pos);\n    vec3 color = hsl2rgb(vec3(dist * 4.0, 1.0 - time * 0.5, 1.0));\n    \n    float noiseVal = noise(vec2(angle, dist + time));\n    angle += noiseVal * 0.5;\n    \n    vec2 finalPos = vec2(cos(angle), sin(angle)) * (dist + noiseVal * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_179.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.1;\n    \n    // Time-based scaling and noise influence\n    vec2 scale = vec2(5.0 + sin(time * 0.5), 6.0 + cos(time * 0.3));\n    vec2 warpedUv = uv * scale.x + noise(uv * scale.y);\n    \n    // Calculate light position in an orbiting pattern\n    float lightAngle = time * 4.0;\n    vec2 lightPos = vec2(sin(lightAngle), cos(lightAngle)) * 5.0;\n    \n    // Distance from current point to light source\n    float dist = length(warpedUv - lightPos);\n    \n    // Hue based on distance, with smooth transition\n    float hue = dist * 0.1 + time * 0.2;\n    \n    // Create color using HSV and convert to RGB\n    vec3 colorHsv = vec3(hue, 0.7, 0.8);\n    vec3 finalColor = hsv2rgb(colorHsv);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_18.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 p = vec3(uv * 0.5 - 1.0, iTime * 0.2);\n    float t = turbulent(p);\n    \n    vec2 uv2 = uv + vec2(t, t * 0.5);\n    float n = noise(uv2) * 4.0;\n    \n    vec3 col = hsl2rgb(vec3(n * 0.5 + 0.5, \n                          fract(sin(uv.x * 10.0 + iTime) * 6.0), \n                          fract(cos(uv.y * 8.0 + iTime) * 4.0)));\n    \n    col *= vec3(1.0, 0.8, 1.2);\n    return vec4(col, 1.0);\n}"
  },
  "data_180.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 baseColor = hsl2rgb(vec3(\n        0.1 + noise(uv * 5.0) * 0.5,\n        0.7,\n        0.8\n    ));\n    \n    float time = iTime * 0.5;\n    vec2 st = uv;\n    \n    // Create flowing motion using turbulence\n    vec2 flowMap = vec2(\n        turbulent(vec2(st.x * 10.0 + time, st.y * 10.0)),\n        turbulent(vec2(st.x * 10.0 - time, st.y * 10.0))\n    );\n    \n    // Calculate velocity field\n    vec2 vel = flowMap * 0.1;\n    vec2 pos = st + vel;\n    \n    // Create surface normal based on velocity\n    vec3 norm = vec3(vel.x, vel.y, 0.5);\n    norm = normalize(norm);\n    \n    // Reflect light direction using normal vector\n    vec3 lightDir = vec3(1.0, 1.0, 1.0);\n    lightDir = normalize(lightDir);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    \n    // Calculate specular highlight\n    float spec = pow(max(dot(norm, reflectDir), 0.0), 32.0);\n    \n    // Mix colors and apply reflections\n    baseColor *= (0.7 + spec * 0.3);\n    return vec4(baseColor, 1.0);\n}"
  },
  "data_181.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Grid setup and reaction-diffusion variables\n    const float F = 0.1;\n    const float k = 0.05;\n    \n    // Initialize grid concentrations using noise texture\n    vec3 noiseTex = texture(iChannel0, uv).rgb;\n    float u = noiseTex.r * 2.0 - 1.0;\n    float v = noiseTex.g * 2.0 - 1.0;\n    \n    // Hexagonal grid transformation\n    vec2 x = (uv * 64.0) * 0.5; // Scale to fit within hexagon\n    \n    // Reaction-diffusion update step\n    vec2 du = vec2(\n        noise(x + vec2(1,0)) - noise(x),\n        noise(x + vec2(-1,0)) - noise(x)\n    );\n    \n    vec2 dv = vec2(\n        noise(x + vec2(0,1)) - noise(x),\n        noise(x + vec2(0,-1)) - noise(x)\n    );\n    \n    // Update concentrations\n    float newU = F * (1.0 - k * u) + du.x;\n    float newV = F * v + du.y - dv.x;\n    \n    // Convert to RGB using HSL\n    vec3 color = hsl2rgb(vec3(newU, newV, 0.5));\n    \n    // Add time-based offset for animation\n    color *= sin(iTime) * 0.5 + 1.0;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_182.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float t = iTime * 0.1;\n    \n    vec2 st = uv + vec2(t, sin(t));\n    \n    // Generate noise pattern\n    float n1 = noise(st);\n    float n2 = noise(uv + t + cos(t));\n    \n    // Combine noise patterns with smooth transitions\n    float d = smoothstep(0.0, 1.0, sin(n1 * pi)) * \n              smoothstep(0.0, 1.0, sin(n2 * pi));\n    \n    // Add depth and layers using multiple noise functions\n    n1 = noise(vec2(uv.x + t, uv.y + cos(t)));\n    d += smoothstep(0.0, 1.0, sin(n1 * pi)) * 0.5;\n    \n    // Create glowing effect with alpha based on distance to edge\n    float a = length(d - 0.3) * 2.0;\n    a = smoothstep(0.0, 1.0, a);\n    \n    // Generate shifting colors using HSL\n    vec3 color = hsl2rgb(vec3(sin(t) * 0.5 + 0.5, \n                              cos(t) * 0.5 + 0.5,\n                              sin(iTime * 0.2) * 0.3 + 0.7));\n    \n    // Apply glow intensity and mix with background\n    color *= vec3(1.0, 1.0, 1.0) * a;\n    \n    return vec4(color, a);\n}"
  },
  "data_183.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Flow parameters\n    float s = 0.1;\n    float speed = 0.5;\n    float scale = 0.3;\n    \n    // Create flowing pattern\n    vec2 flow = vec2(\n        sin(uv.y * scale + iTime * speed),\n        cos(uv.x * scale + iTime * speed)\n    );\n    \n    // Add noise for texture\n    float noiseVal = noise(uv * 5.0);\n    \n    // Combine flow and noise for color variation\n    vec3 hsv = vec3(\n        (flow.x + flow.y) * 0.5 + 0.5,  // Hue variation\n        0.8,                              // Saturation\n        0.7 + noiseVal * 0.2             // Value with noise\n    );\n    \n    // Convert HSV to RGB and add glow effect\n    vec3 color = hsv2rgb(hsv);\n    float glow = smoothstep(0.5, 1.0, length(uv));\n    color += vec3(glow) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_184.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0);\n    \n    // Animated vertical position for scanline effect\n    float scanPos = sin(iTime * 5.0) * 0.5 + 0.5;\n    \n    // Create horizontal sweeping lines\n    float lineSpeed = 3.0;\n    uv.y += fract(uv.x * lineSpeed + iTime * 2.0);\n    \n    // Add scanline influence to noise generation\n    vec2 noiseUV = uv * 10.0 + vec2(0.0, scanPos * 5.0);\n    float noiseValue = noise(noiseUV);\n    \n    // Animate color using HSL values\n    float hue = iTime * 0.5;\n    float saturation = 0.8;\n    vec3 hslColor = hsl2rgb(vec3(hue, saturation, 0.5 + sin(iTime) * 0.2));\n    \n    // Apply noise-based color shift\n    vec3 finalColor = mix(hslColor, hslColor * (noiseValue + 1.0), 0.7);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_185.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * iTime;\n    \n    // Get noise value from texture\n    float n = noise(st * 8.0);\n    \n    // Create color variations using HSV\n    vec3 color1 = hsv2rgb(vec3(\n        mod(iTime * 0.5, 1.0), \n        0.7 + sin(iTime) * 0.3, \n        0.6 + n * 0.4\n    ));\n    \n    // Add secondary color influence with time offset\n    vec3 color2 = hsv2rgb(vec3(\n        mod(iTime * 0.5 + 1.0, 1.0), \n        0.7 + sin(iTime + PI) * 0.3, \n        0.6 + n * 0.4\n    ));\n    \n    // Mix colors based on noise value\n    vec3 finalColor = mix(color1, color2, n);\n    \n    // Add dynamic brightness variation\n    float bright = sin(iTime * 2.0) * 0.5 + 0.5;\n    finalColor *= bright;\n    \n    // Add subtle motion blur effect using time offset\n    vec2 prevSt = uv * (iTime - 1.0);\n    float prevN = noise(prevSt * 8.0);\n    finalColor += hsv2rgb(vec3(\n        mod(iTime * 0.5, 1.0), \n        0.7 + sin(iTime) * 0.3, \n        0.6 + prevN * 0.4\n    )) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_186.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float t = iTime * 0.1;\n    \n    vec2 pos = uv;\n    pos.x += sin(t) * 0.5;\n    \n    float noise1 = noise(pos * 8.0);\n    float noise2 = noise((uv + vec2(sin(t), cos(t))) * 6.0);\n    \n    float wave = (noise1 + noise2) * 0.5;\n    wave = mod(wave + t, 1.0);\n    \n    vec3 color = hsv2rgb(vec3(\n        wave * 6.0,\n        0.7 + sin(wave * 4.0 + t) * 0.3,\n        0.8 + noise(uv * 5.0 - t) * 0.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_187.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Combine UV coordinates with time using sine and cosine functions\n    float a = sin(uv.x * 10.0 + iTime) + cos(uv.y * 5.0 - iTime);\n    float b = cos(uv.x * 5.0 - iTime) + sin(uv.y * 10.0 + iTime);\n    \n    // Add noise to create more complex patterns\n    vec2 noiseUV = uv * 5.0 + vec2(iTime, iTime * 0.5);\n    float n = noise(noiseUV);\n    \n    // Create a turbulent value that will influence the color pattern\n    float turb = turbulent(uv * 10.0 + vec2(iTime, iTime));\n    \n    // Generate HSL color based on combined values\n    vec3 hslColor;\n    hslColor.x = (a + b + n) * 0.5 + 0.5; // Hue between 0 and 1\n    hslColor.y = abs(sin(iTime * 0.2) * 0.5 + 0.5); // Saturation variation over time\n    hslColor.z = turb * 0.5 + 0.5; // Lightness based on turbulence\n    \n    // Convert HSL to RGB and return as fragment color\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_188.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Convert to polar coordinates\n    float d = length(st);\n    float a = atan2(st.y, st.x) - PI/2.0;\n    a = mod(a + 2.0 * PI, 2.0 * PI); // Angle from right direction\n    \n    // Generate ray positions with time offset\n    float rayCount = 16.0;\n    float rayAngle = sin(a * rayCount + iTime * 4.0) * 0.5;\n    \n    // Add noise displacement to rays for organic movement\n    vec2 noisePos = (st * 100.0 + iTime * 0.3) * 0.1;\n    float noiseVal = noise(noisePos);\n    rayAngle += noiseVal;\n    \n    // Calculate distance from current fragment to nearest ray\n    float dRay = abs(d - rayAngle);\n    \n    // Color transformation based on time and position\n    vec3 baseColor = hsl2rgb(vec3(0.5, 0.5, sin(iTime * 0.8 + a * 0.4) * 0.5 + 0.5));\n    \n    // Apply Gaussian falloff for glow effect\n    float glow = exp(-dRay * dRay * 0.1);\n    \n    // Combine color and glow with alpha\n    return vec4(baseColor * glow, glow);\n}"
  },
  "data_189.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * 5.0;\n    float time = iTime * 0.5;\n    \n    // Create rotating pattern\n    float angle = atan2(st.y - 0.5, st.x - 0.5);\n    angle += time;\n    \n    // Add noise and turbulence\n    float n1 = noise(vec3(st + time, 0.0)) * 0.5 + 0.5;\n    float t1 = turbulent(st * 2.0) * 0.5 + 0.5;\n    \n    // Combine elements for color\n    vec3 color = hsl2rgb(vec3(\n        (angle + time) / (2.0 * PI),\n        n1,\n        t1\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_19.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 t = vec2(sin(iTime * 0.5), cos(iTime * 0.5));\n    \n    mat2 m = mat2(\n        cos(t.x + t.y), -sin(t.x),\n        sin(t.x), cos(t.y)\n    );\n    \n    vec2 p = uv * 2.0 - 1.0;\n    p = m * p;\n    \n    float n = noise(p * iTime);\n    p += n * 0.5;\n    \n    float turb = turbulent(vec3(p, iTime * 0.5));\n    \n    vec3 color = hsv2rgb(vec3(\n        (t.x + turb) * 0.5,\n        0.7,\n        0.5 + sin(t.y + p.x * 2.0) * 0.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_190.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 pos = vec3(uv * 5., iTime * 0.1);\n    float t = turbulent(pos);\n    \n    vec2 noiseUV = (uv + noise(uv * 0.5)) * 0.5;\n    float n = noise(noiseUV * 4.) * 0.5 + 0.5;\n    \n    vec3 color = hsv2rgb(vec3(\n        t * 0.5 + 0.5, \n        0.8 + sin(iTime) * 0.2,\n        0.6 + n * 0.4\n    ));\n    \n    float d = length(uv - 0.5);\n    float a = smoothstep(0.3, 1., abs(sin(d * 5. + iTime)));\n    \n    return vec4(color * (0.2 + a), a);\n}"
  },
  "data_191.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = hsv2rgb(vec3(\n        iTime * 0.1 + sin(iTime) * 0.5,\n        0.7 + noise(uv * 0.5 + iTime) * 0.3,\n        0.8 + turbulent(uv * 4.0 - iTime * 2.0)\n    ));\n    \n    vec2 pos = uv;\n    float timeScale = iTime * 0.1;\n    \n    // Add flowing displacement\n    vec2 flow = noise(pos * 0.5 + iTime) * vec2(sin(timeScale), cos(timeScale)) * 0.3;\n    pos += flow;\n    \n    // Create molten effect with glow\n    float distanceFromEdge = length(vec2(1.0) - abs(pos));\n    color *= smoothstep(0.0, 0.5, distanceFromEdge);\n    \n    // Add glowing edges\n    vec3 glow = vec3(1.0, 0.8, 0.4) * exp(-distanceFromEdge * 2.0);\n    color += glow;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_193.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and center coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Time-based animation\n    float time = iTime * 0.5;\n    \n    // Grid pattern with moving squares\n    vec2 grid = floor(st * 8.0 + time) / 8.0;\n    vec2 squarePos = fract(grid);\n    \n    // Expanding circles from center\n    vec2 circleCenter = grid - 0.5;\n    float distance = length(circleCenter);\n    float circle = smoothstep(0.4, 0.6, distance + time * 0.1);\n    \n    // Color transitions using HSL\n    vec3 color1 = hsl(time + 0.0, 0.7, 0.5);\n    vec3 color2 = hsl(time + 0.33, 0.7, 0.5);\n    vec3 color3 = hsl(time + 0.66, 0.7, 0.5);\n    \n    // Mix colors based on position\n    vec3 finalColor = mix(color1, color2, squarePos.x) * (1.0 - circle) +\n                     mix(color2, color3, squarePos.y) * circle;\n    \n    // Add noise for texture\n    float noiseValue = noise(st * 4.0 + time);\n    finalColor *= 1.0 + noiseValue * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_194.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create animated UV coordinates\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Add some rotation to create movement\n    float angle = iTime * 0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    st = rot * st;\n    \n    // Use noise and turbulence to create a dynamic pattern\n    float n = turbulent(st);\n    vec3 color = hsl2rgb(vec3(\n        mod(n * 0.5 + iTime, 1.0),\n        0.7,\n        0.6\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_195.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 8.0 + iTime;\n    \n    // Create interweaving sine wave patterns\n    float wave1 = sin(st.x * 0.5 + iTime) * 0.5 + 0.5;\n    float wave2 = sin(st.y * 0.5 + iTime + PI/2.) * 0.5 + 0.5;\n    float wave3 = sin((st.x + st.y) * 0.3 + iTime + PI) * 0.5 + 0.5;\n    \n    // Mix RGB colors with time-based shifting\n    vec3 color1 = vec3(1.0, 0.2, 0.2); // Red\n    vec3 color2 = vec3(0.2, 1.0, 0.2); // Green\n    vec3 color3 = vec3(0.2, 0.2, 1.0); // Blue\n    \n    float mixFactor = sin(iTime * 0.5) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixFactor);\n    finalColor = mix(finalColor, color3, mixFactor * 0.5);\n    \n    // Combine waves and add noise for complexity\n    float value = (wave1 + wave2 + wave3) / 3.0;\n    value += turbulent(st * 4.0 + iTime) * 0.3;\n    \n    // Create final output color\n    vec3 result = finalColor * value;\n    \n    return vec4(result, 1.0);\n}"
  },
  "data_196.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating nebula effect with vibrant colors and radial motion\n    \n    // Calculate distance from center\n    float d = length(uv);\n    \n    // Base noise pattern\n    vec2 pos = uv * 10.0;\n    float n = noise(pos + iTime) * 0.5;\n    \n    // Add turbulence at different scales\n    float t1 = turbulent(pos * 3.0 + iTime * 2.0);\n    float t2 = turbulent(pos * 6.0 + iTime * 4.0);\n    \n    // Combine noise and turbulence\n    float c = (n + t1 * 0.5 + t2 * 0.2) * 0.5;\n    \n    // Add pulsation effect\n    c += sin(iTime * 3.0 + d * 4.0) * 0.3;\n    \n    // Convert to RGB with vibrant colors\n    vec3 col = hsl2rgb(vec3(\n        (length(uv * 5.0 + iTime)) * 0.4,\n        0.8,\n        c * 0.6 + 0.4\n    ));\n    \n    // Create radial gradient effect\n    vec3 finalColor = mix(col, vec3(0.0), smoothstep(1.5, 0.0, d));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_197.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv * 1.5); // Scale radius for better spiral shape\n    \n    // Add time-based rotation\n    theta += iTime * 0.1;\n    \n    // Create spiral arms pattern using sine function\n    float spiral = sin(theta * 6.0 + iTime) * exp(-r * r / 4.0);\n    spiral = pow(abs(spiral), 2.0); // Sharpen the spiral arms\n    \n    // Add turbulence for dynamic effect\n    vec3 noisePos = vec3(uv.x, uv.y, iTime * 0.1);\n    float turb = turbulent(noisePos * 5.0) * 0.5 + 0.5;\n    \n    // Create star particles using high-frequency noise\n    float stars = noise(uv * 100.0 + iTime) * 0.3;\n    stars = smoothstep(0.8, 1.0, stars);\n    \n    // Combine spiral arms and turbulence\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.5 + r * 2.0) * 0.5 + 0.5, // Hue variation\n        0.7 + turb * 0.3, // Saturation\n        0.1 + spiral * 0.4 + stars * 0.6 // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_198.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Transform UV coordinates to range (-1,1)\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create multiple sine wave layers with varying frequencies and amplitudes\n    float wave1 = sin(st.x * 6.0 + iTime * 2.0) * 0.5;\n    float wave2 = sin(st.y * 4.0 + iTime * 3.0) * 0.7;\n    float wave3 = sin((st.x + st.y) * 8.0 + iTime) * 0.6;\n    float wave4 = sin((st.x - st.y) * 12.0 + iTime * 5.0) * 0.4;\n    \n    // Combine waves with some offset and modulation\n    float combinedWaves = (wave1 + wave2 + wave3 + wave4) * 0.5;\n    \n    // Add turbulence for dynamic interference pattern\n    vec2 noiseCoords = st * 0.5 + iTime * 0.2;\n    float turbulence = turbulent(noiseCoords);\n    \n    // Create final pattern by combining waves and turbulence\n    float pattern = (combinedWaves + turbulence) * 0.5 + 0.5;\n    \n    // Convert to color using HSL for vibrant results\n    vec3 color = hsl2rgb(vec3(\n        pattern * 360.0,   // Hue varies with pattern\n        0.7 + pattern * 0.3,  // Saturation modulation\n        0.5                   // Fixed lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_199.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    vec2 rotatedUV = vec2(\n        cos(iTime)*uv.x - sin(iTime)*uv.y,\n        sin(iTime)*uv.x + cos(iTime)*uv.y\n    );\n    \n    // Add noise and turbulence for dynamic patterns\n    float noiseValue = noise(rotatedUV * 10.0);\n    float turbulentValue = turbulent(rotatedUV * 5.0 + iTime);\n    \n    // Create radial gradient effect\n    vec2 center = uv - 0.5;\n    float radius = length(center) * 2.0;\n    \n    // Combine elements for color input\n    vec3 colorInput = vec3(\n        noiseValue * 0.5 + 0.5,\n        turbulentValue * 0.5 + 0.5,\n        radius * 0.5 + 0.5\n    );\n    \n    // Convert to RGB with shifting hues\n    vec3 hslColor = vec3(\n        colorInput.x + sin(iTime) * 0.5,\n        colorInput.y * 0.7,\n        colorInput.z * 0.6 + 0.4\n    );\n    \n    // Apply HSL to RGB conversion and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_2.json": {
    "src": "\nvec4 Effect2(vec2 uv) {\n    float t = iTime * 0.1;\n    vec2 pos = uv * 5.0 - sin(t);\n    float wave = sin(pos.x * 3.14 + t) * cos(pos.y * 3.14 + t * 0.7);\n    float noiseVal = noise(vec2(wave, t));\n    vec3 color = hsv2rgb(vec3(wave * 0.5 + 0.5, 0.8, 0.6) + vec3(noiseVal * 0.1, noiseVal * 0.1, noiseVal * 0.1));\n    return vec4(color, 1.0);\n}"
  },
  "data_20.json": {
    "src": "\n//prompt: something wonderful \nvec4 Effect2(vec2 uv) {\n    // Create a circular pattern with time-based oscillations\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length(p);\n    \n    // Add noise and animation\n    float t = iTime * 0.25;\n    vec3 pos = vec3(p.x, p.y, t);\n    float cell = noise(pos * 0.5 + sin(t) * 0.1) *\n                noise(pos * 2.0 - cos(t * 2.0) * 0.2) +\n                noise(pos * 4.0 + t) * 0.5;\n    \n    // Create interference pattern\n    float interf = noise(vec3(p.x * 0.7 - t, p.y * 0.7 + t * 0.5, 0.0)) * 2.0 -\n                   noise(vec3(p.x * 0.9 + t * 0.5, p.y * 0.9 - t * 0.3, 1.0)) * 2.0;\n    \n    // Convert to color\n    vec3 color = hsl(abs(cell * 0.5 + interf) * 7.0,\n                     sin(t * 2.0 + d * 3.0) * 0.5 + 0.5,\n                     cos(t * 3.0 - d * 4.0) * 0.5 + 0.5);\n    \n    // Add distance falloff\n    color *= 1.0 - d * 0.3;\n    color = mix(color, vec3(0.0), max(0.0, 1.0 - d));\n    \n    return vec4(color, 1.0);\n}        \n"
  },
  "data_200.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += sin(iTime * 2.0) * 3.0;\n    // Create geometric pattern using sine functions\n    float pattern = sin(theta + sin(r * 10.0 + iTime)) * cos(r * 5.0 - iTime);\n    \n    // Add turbulence for dynamic effect\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float turbulentValue = turbulent(noiseUV);\n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(iTime) * 0.5 + 0.5,   // Hue\n        0.7,                      // Saturation\n        0.5 + turbulentValue * 0.2 // Lightness\n    );\n    // Convert HSL to RGB and mix with pattern\n    vec3 color = hsl2rgb(hslColor);\n    color *= abs(pattern) * 0.5 + 0.5;\n    return vec4(color, 1.0);\n}"
  },
  "data_201.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-based animation component\n    float time = iTime * 0.5;\n    \n    // Create flowing sine wave patterns with different frequencies\n    vec3 flow = sin(vec3(1.0, 2.0, 3.0) * uv.x + time) * 0.5 + 0.5;\n    \n    // Shift RGB channels with different phase offsets for color variation\n    vec3 colorShifts = sin(vec3(0.5, 1.0, 1.5) * time + vec3(0.0, 2.094, 4.188)) * 0.5 + 0.5;\n    \n    // Combine the patterns with noise for added complexity\n    vec2 noiseUV = uv * 10.0 + time;\n    float noiseValue = noise(noiseUV);\n    \n    // Create a turbulent effect using multi-octave turbulence\n    float turbulence = turbulent(vec3(uv, time));\n    \n    // Mix all components together with RGB shifts\n    vec3 finalColor = mix(flow, colorShifts, 0.5) * (1.0 + noiseValue * 0.5);\n    \n    // Convert to HSL and back for vibrant colors\n    return vec4(hsl2rgb(vec3(finalColor)), 1.0);\n}"
  },
  "data_202.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern using UV coordinates\n    vec2 grid = fract(uv * 20.0);\n    \n    // Generate noise values for each cell in the grid\n    float noiseValue = sin(iTime + grid.x * pi) * sin(iTime + grid.y * pi);\n    \n    // Calculate base color based on position and time\n    vec3 baseColor = hsl2rgb(vec3(\n        (grid.x + grid.y + iTime / 2.0) * 0.5, \n        1.0,\n        0.5\n    ));\n    \n    // Add noise to create variations in color\n    float pattern = sin(iTime + uv.x * 10.0) * sin(iTime + uv.y * 10.0);\n    vec3 finalColor = mix(baseColor, hsl2rgb(vec3(\n        (grid.x + grid.y + iTime / 2.0) * 0.5,\n        1.0,\n        0.7 + pattern * 0.3\n    )), abs(sin(iTime)));\n    \n    // Add edge detection to create a more defined grid look\n    vec2 edges = min(fwidth(grid), 0.01);\n    finalColor = mix(finalColor, vec3(0.0), edges.x + edges.y);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_203.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to range [0,1]\n    vec2 st = uv * 0.5 + 0.5;\n    \n    // Create a radial pattern\n    vec2 pos = st - 0.5;\n    float d = length(pos);\n    float angle = atan(pos.y, pos.x) + iTime * 0.5;\n    \n    // Create rotating color wheels using HSL colors\n    vec3 wheelColor = hsl(angle * 0.16 + 0.5, 0.7, 0.6);\n    \n    // Add pulsating rings with noise and turbulence\n    float ring = sin(d * 8.0 + iTime) * 0.5;\n    float turb = turbulent(vec3(st * 4.0, iTime * 0.1)) * 0.2;\n    float finalRadius = d + ring + turb;\n    \n    // Create color transitions\n    vec3 color = mix(wheelColor,\n                     hsl(finalRadius * 0.5 + 0.5, 0.8, 0.7),\n                     smoothstep(0.4, 1.0, finalRadius));\n    \n    // Add some noise variation\n    color += noise(vec3(st * 2.0, iTime)) * 0.1;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_204.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Initialize variables\n    float noiseValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 4.0;\n    \n    // FBM (Fractal Brownian Motion) noise accumulation\n    for(int octave = 0; octave < 5; octave++) {\n        // Add time offset to create movement\n        vec2 uvOffset = uv * frequency + iTime * 0.1;\n        \n        // Get noise value at current frequency\n        float n = noise(vec3(uvOffset, iTime)) * amplitude;\n        \n        // Accumulate noise values\n        noiseValue += n;\n        \n        // Update for next octave\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    \n    // Normalize noise value to [0,1] range\n    noiseValue = (noiseValue + 1.0) * 0.5;\n    \n    // Convert noise to color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        noiseValue * 360.0,   // Hue based on noise value\n        0.7,                 // Saturation\n        0.5 + noiseValue*0.5 // Lightness modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_205.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating pattern using sine functions\n    vec2 st = uv * 10.0 - 5.0;\n    st.x *= sin(time);\n    st.y *= cos(time);\n    \n    // Add turbulence for plasma effect\n    float noise1 = turbulent(st + time);\n    float noise2 = turbulent(st * 0.5 + time * 0.7);\n    \n    // Mix different noise layers\n    float mixNoise = (noise1 + noise2) * 0.5;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        sin(time * 0.5) * 0.5 + 0.5,   // Hue variation over time\n        0.7,                            // Saturation\n        mixNoise * 0.5 + 0.5            // Lightness based on noise\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_206.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base radial gradient\n    float d = length(uv - 0.5);\n    \n    // Add pulsing effect using sine wave\n    d += sin(iTime * 0.5 + d * 10.0) * 0.3;\n    \n    // Create color shifts over time\n    vec3 color = hsl(\n        sin(iTime * 0.2 + d * 4.0) * 0.5 + 0.5,  // Hue variation\n        0.8,                                      // Saturation\n        0.5                                       // Lightness\n    );\n    \n    // Add noise and turbulence for more dynamic effect\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float n = noise(noiseUV);\n    color += turbulent(vec3(uv * 4.0, iTime)) * 0.2;\n    \n    // Final color with alpha\n    return vec4(color, 1.0);\n}"
  },
  "data_207.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create hexagonal tiling pattern\n    vec2 q = uv * 3.0; // Scale up for more hexagons\n    q.x += turbulent(q + iTime); // Add dynamic movement\n    \n    // Convert to polar coordinates\n    float r = length(q);\n    float theta = atan2(q.y, q.x) / (pi * 2.0);\n    \n    // Create hexagonal grid pattern\n    vec2 grid = floor(vec2(r * cos(theta * pi), r * sin(theta * pi)) + 0.5);\n    \n    // Calculate distance from center of hexagon\n    vec2 center = fract(grid) - 0.5;\n    float dist = length(center);\n    \n    // Create color based on distance and time\n    vec3 hslColor = vec3(fract(iTime * 0.1 + grid.x * 0.1), 0.7, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add pulsing effect\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    rgbColor *= mix(0.5, 1.0, pulse);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_208.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n    \n    // Add time-based rotation and offset\n    a += iTime * 0.5;\n    pos = vec2(cos(a), sin(a)) * r;\n    \n    // Create concentric circles pattern with time modulation\n    float circles = sin(r * 10.0 + iTime) * 0.5 + 0.5;\n    circles *= turbulent(pos * 4.0);\n    \n    // Swirling color effect using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        (a * 0.5 + r * 0.1 + iTime) * 0.5,\n        0.7,\n        0.6\n    ));\n    \n    // Add noise and brightness variation\n    float noiseFactor = noise(pos * 4.0 + vec2(iTime)) * 0.3;\n    color *= (sin(r * 10.0 - iTime) * 0.5 + 0.5 + noiseFactor);\n    \n    // Create fading trail effect based on distance from center\n    float fade = smoothstep(1.0, 0.0, r);\n    color *= fade;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_209.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using HSL with time-varying hue\n    vec3 hslColor = hsl(uv.x * 5.0 + iTime, 1.0, 0.5);\n    \n    // Add flowing movement using noise and turbulence\n    vec2 pos = uv * 4.0;\n    pos.x += iTime * 0.5;\n    \n    float flow = turbulent(vec2(pos.x, pos.y)) * 0.3;\n    flow += turbulent(vec2(pos.x * 0.5, pos.y * 0.5) + vec2(123.456, 789.123)) * 0.2;\n    \n    // Create metallic effect with highlights and shadows\n    float highlight = noise(vec2(uv.x * 10.0 + iTime * 0.2, uv.y * 10.0)) * 0.5 + 0.5;\n    float shadow = noise(vec2(uv.x * 20.0 - iTime * 0.3, uv.y * 20.0)) * 0.5 + 0.5;\n    \n    // Combine all elements\n    vec3 color = hslColor * (flow + 0.7);\n    color *= mix(1.0, 0.3, shadow);\n    color += highlight * 0.4;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_21.json": {
    "src": "\n//prompt: something wonderful and detailed \nvec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0);\n    \n    // Generate multiple interference patterns using UV coordinates\n    float d1 = length(uv * 5.0 + iTime * 0.7);\n    float d2 = sin((uv.x * 8.0 + iTime) * 6.0) * cos((uv.y * 8.0 + iTime) * 6.0);\n    \n    // Create a checkerboard-like pattern with UV\n    vec2 coord = fract(uv * 4.0 + iTime * 0.5);\n    float check1 = step(0.5, coord.x) - step(0.5, coord.y);\n    float check2 = fract(coord.x * 3.0) - fract(coord.y * 3.0);\n    \n    // Combine patterns with noise\n    float noiseVal = noise(vec2(d1, d2)) * 0.8;\n    float pattern = sin(d1 + iTime * 0.5) * cos(d2 + iTime * 0.3) + noiseVal;\n    \n    // Calculate color channels based on combined patterns\n    color.r = abs(sin(pattern * 4.0 + d1)) * 0.8;\n    color.g = abs(cos(pattern * 4.0 + d2)) * 0.6;\n    color.b = pattern / 3.0 + noiseVal * 0.4;\n    \n    return vec4(color, 1.0);\n}\n        "
  },
  "data_210.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base noise value with time offset\n    float baseNoise = noise(uv * 5.0 + iTime);\n    \n    // Add some turbulence for more dynamic patterns\n    vec3 pos3D = vec3(uv * 10.0, iTime * 2.0);\n    float turb = turbulent(pos3D);\n    \n    // Combine noise and turbulence with time-based color shifts\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime + uv.x * 5.0) * 0.5 + 0.5,\n        sin(iTime + uv.y * 5.0) * 0.5 + 0.5,\n        baseNoise * 0.5 + turb * 0.5 + 0.5\n    ));\n    \n    // Add positional gradient effect\n    vec3 gradient = vec3(\n        sin(uv.x * pi + iTime),\n        cos(uv.y * pi + iTime * 0.5),\n        sin((uv.x + uv.y) * pi + iTime)\n    );\n    \n    color *= gradient;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_211.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create shifting mosaic pattern using noise and time\n    vec2 st = uv * 10.0 + iTime;\n    vec3 color = vec3(0.0);\n    \n    // Add chromatic aberration by offsetting UVs for each channel\n    vec2 offsets[3] = vec2[3](\n        vec2(-0.05, -0.05),\n        vec2(0.0, 0.0),\n        vec2(0.05, 0.05)\n    );\n    \n    // Create mosaic pattern with noise\n    for(int i = 0; i < 3; i++) {\n        vec2 offsetUV = fract(st + offsets[i]);\n        float n = turbulent(offsetUV * 10.0);\n        color[i] = n;\n    }\n    \n    // Add chromatic aberration effect based on distance from center\n    vec2 center = vec2(0.5, 0.5);\n    float dist = length(uv - center) * 2.0;\n    color = mix(color, vec3(1.0), smoothstep(0.0, 1.0, dist));\n    \n    // Add some turbulence to the pattern\n    float t = turbulent(vec3(st.x + iTime, st.y, 0.0)) * 0.5 + 0.5;\n    color *= t;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_212.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create layered sine patterns with different frequencies and amplitudes\n    float s1 = sin(a * 3.0 + iTime) * 0.5;\n    float s2 = sin(a * 5.0 - iTime * 2.0) * 0.4;\n    float s3 = sin(r * 8.0 + a * 2.0) * 0.3;\n    \n    // Combine sine layers and add turbulence\n    float pattern = (s1 + s2 + s3) * 0.5 + turbulent(vec2(a, r)) * 0.3;\n    \n    // Create color cycling effect using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + a / (2.0 * PI)), // Hue cycling over time and angle\n        1.0 - abs(pattern) * 0.5,            // Saturation based on pattern\n        0.7 + pattern * 0.3                 // Lightness modulation\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_213.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create sine wave patterns in both x and y directions\n    float sinX = sin(uv.x * 8.0 + iTime * 2.0);\n    float sinY = sin(uv.y * 8.0 + iTime * 3.0);\n    \n    // Combine the waves with some phase shifting\n    vec2 wave = vec2(sinX, sinY) * 0.5 + 0.5;\n    \n    // Add turbulence to create dynamic movement\n    float turb = turbulent(uv * 4.0 + iTime);\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        mod(iTime * 0.2 + wave.x * 1.5, 1.0),  // Hue\n        0.7 + turb * 0.3,                       // Saturation\n        0.5 + wave.y * 0.5                      // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_214.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise pattern with turbulence\n    vec3 noisePos = vec3(uv * 5.0 + iTime * 0.1, iTime * 0.1);\n    float t = turbulent(noisePos);\n    \n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.2 + 0.5, 1.0),   // Hue variation over time\n        0.7 + t * 0.3,                // Saturation\n        0.5 + sin(iTime * 0.4) * 0.5   // Brightness variation\n    );\n    \n    // Convert to RGB and add glow effect\n    vec3 color = hsl2rgb(hslColor);\n    float glow = sin(uv.y * pi * 2.0 + iTime) * 0.5 + 0.5;\n    color *= glow * 1.5;\n    \n    // Add turbulence-based variations\n    color += t * 0.3;\n    \n    // Soften edges\n    float edge = smoothstep(0.8, 1.0, length(uv));\n    color *= edge;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_215.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create a geometric pattern using sine waves and turbulence\n    float pattern = sin(theta * 8.0) * 0.5 + \n                   sin(theta * 16.0) * 0.3 +\n                   turbulent(vec3(st.x, st.y, iTime)) * 0.2;\n    \n    // Create dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.5 + theta * 0.1, 1.0), // Hue variation over time and space\n        0.7, // Saturation\n        0.5 + r * 0.4 // Lightness varies with radius\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_216.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position over time\n    vec2 pos = uv * 5.0 + iTime;\n    \n    // Create rotating pattern using sine waves\n    float wave1 = sin(pos.x * 0.5 + iTime) * 0.5 + 0.5;\n    float wave2 = sin(pos.y * 0.5 + iTime) * 0.5 + 0.5;\n    \n    // Combine patterns with rotation and scaling\n    vec2 rotatedUV = uv * 4.0 + vec2(sin(iTime)*3.0, cos(iTime)*3.0);\n    \n    // Add noise for texture\n    float noiseValue = noise(rotatedUV) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        sin(iTime * 0.2 + uv.x * 4.0) * 0.5 + 0.5,  // Hue\n        0.7,  // Saturation\n        noiseValue * (wave1 + wave2) * 0.5 + 0.5);    // Lightness\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_217.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using sine functions\n    float time = iTime * 0.5;\n    vec2 center = vec2(0.5);\n    vec2 st = uv - center;\n    \n    // Polar coordinates\n    float r = length(st);\n    float a = atan2(st.y, st.x) + sin(time) * 2.0;\n    \n    // Create rotating sectors with turbulence\n    a += turbulent(vec3(uv * 10.0, time)) * 0.5;\n    a = mod(a, PI/4.0); // Create 8 sectors\n    \n    // Color transformation using HSL shifts\n    vec3 hslColor = vec3(\n        sin(r * 20.0 + time) * 0.5 + 0.5,\n        sin(r * 10.0 + a * 2.0) * 0.5 + 0.5,\n        cos(r * 5.0 + time) * 0.5 + 0.5\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_218.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create pulsating effect using time and radius\n    float pulse = sin(iTime * 3.0 + r * 5.0) * 0.5 + 0.5;\n    \n    // Create color transitions based on angle and time\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.5 + iTime * 0.1,   // Hue varies with angle and time\n        0.7,                         // Saturation\n        pulse                        // Lightness varies with pulsing\n    ));\n    // Create radial gradient effect\n    float gradient = sin(r * 8.0 + iTime) * 0.5 + 0.5;\n    color *= gradient;\n    return vec4(color, 1.0);\n}"
  },
  "data_219.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 c = vec3(0.0);\n    float t = float(iTime) * 0.5;\n    \n    // Calculate distance from center and add some noise-based movement\n    float d = length(uv) + sin(t * 0.5 + length(uv) * 2.0) * 0.3;\n    \n    // Create a position vector for turbulence calculation\n    vec3 pos = vec3(uv * 8.0, t);\n    float m = turbulent(pos) * 0.5 + 0.5;\n    \n    // Add color variations using HSL to RGB conversion\n    c = hsl2rgb(vec3(\n        sin(d * 5.0 + t) * 0.5 + 0.5,   // Hue variation\n        1.0 - d * 0.6,                  // Saturation based on distance\n        m * 0.8 + 0.2                   // Brightness modulation\n    ));\n    \n    // Add pulsating glow effect\n    c *= sin(t * 3.0 + d * 5.0) * 0.5 + 0.7;\n    \n    return vec4(c, 1.0);\n}"
  },
  "data_22.json": {
    "src": "\n//prompt: something vibrant and organic, but twisted and geometric with veins\nvec4 Effect3(vec3 pos){\n    // Transform position with time-based rotations\n    mat3 rot = mat3(\n        cos(iTime), -sin(iTime), 0,\n        sin(iTime), cos(iTime), 0,\n        0, 0, 1\n    );\n    \n    vec3 p = pos * 2.0;\n    p = (rot * p) * 2.0; // Apply rotation\n    \n    // Create cellular pattern with veins\n    vec3 cell = abs(fract(p * 0.5 + iTime * 0.2) - 0.5);\n    float vein = length(cell);\n    \n    // Add turbulence and organic feel\n    p.x += sin(p.z * 4.0 + iTime) * 0.2;\n    p.y += cos(p.x * 3.0 + iTime) * 0.1;\n    p.z *= abs(sin(iTime * 0.5)) * 0.8 + 0.2;\n    \n    // Generate noise-based colors\n    vec3 hue = fract(p * 0.2 + iTime);\n    float n1 = turbulent(p * 4.0);\n    float n2 = turbulent(p * 2.0);\n    \n    // Create vibrant color transitions with geometric veins\n    vec3 color = hsl2rgb(vec3(\n        (n1 + p.x * 0.5) * 0.6,\n        (abs(sin(vein * 10.0)) * 0.7 + 0.3),\n        0.8 - abs(p.y) * 0.4\n    ));\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_220.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise patterns with time offset\n    float n1 = turbulent(vec3(uv * 5.0 + iTime, iTime));\n    float n2 = turbulent(vec2(uv * 8.0 - iTime * 2.0));\n    \n    // Compute rotational RGB shifts\n    vec3 rgbShifts = sin(vec3(0.0, 2.0944, 4.1888) + iTime); // Phased sine waves for rotation\n    \n    // Create color variations using HSL conversion\n    vec3 colorA = hsl(n1 * 0.5 + 0.5, sin(iTime * 0.5) * 0.5 + 0.5, 0.7);\n    vec3 colorB = hsl((n2 * 0.5 + 0.5), sin(iTime * 0.5 + PI) * 0.5 + 0.5, 0.6);\n    \n    // Mix colors with noise patterns\n    vec3 finalColor = mix(colorA, colorB, abs(n1 * 0.5 + 0.5));\n    \n    // Apply rotational shifts to RGB channels\n    mat3 rotationMatrix = mat3(\n        cos(iTime), -sin(iTime), 0.0,\n        sin(iTime), cos(iTime), 0.0,\n        0.0, 0.0, 1.0\n    );\n    finalColor = finalColor * rotationMatrix;\n    \n    // Add noise modulation\n    float modulation = turbulent(vec3(uv * 2.0 + iTime, iTime)) * 0.5 + 0.5;\n    finalColor *= mix(1.0, modulation, 0.7);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_221.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create rotating geometric pattern\n    float shape = sin(angle * 6.0); // Hexagonal symmetry\n    shape *= cos(radius * 8.0 - iTime * 2.0);\n    \n    // Generate color transitions using HSL\n    vec3 baseColor = hsl(\n        mod(iTime * 0.5 + angle * 2.0, 1.0), // Hue variation over time and space\n        0.7, // Saturation\n        0.6 // Lightness\n    );\n    \n    // Add noise texture\n    vec2 noiseCoords = vec2(radius * 4.0, iTime);\n    float noiseValue = turbulent(noiseCoords) * 0.5 + 0.5;\n    vec3 noiseColor = hsl(\n        mod(iTime * 0.3 + radius * 2.0, 1.0), // Different hue variation\n        0.5,\n        noiseValue\n    );\n    \n    // Combine shapes and colors\n    float blendFactor = abs(shape) * 0.5 + 0.5;\n    vec3 finalColor = mix(baseColor, noiseColor, blendFactor);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_222.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern based on UV coordinates\n    vec2 st = floor(uv * 16.0); // 16x16 grid\n    \n    // Calculate rotation angle over time\n    float time = iTime * 0.5;\n    float angle = mod(time + noise(vec3(st, time)) * 2.0, PI * 2.0);\n    \n    // Create a rotating square pattern\n    vec2 rotatedUV = uv - 0.5;\n    rotatedUV = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * rotatedUV;\n    rotatedUV += 0.5;\n    \n    // Calculate distance from center of squares\n    float d = length(rotatedUV - st / 16.0);\n    \n    // Create glow effect using distance falloff\n    float glow = 1.0 / (d + 1.0);\n    \n    // Generate dynamic colors using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(time * 0.5 + st.x * 0.1 + st.y * 0.2, 1.0), // Hue variation\n        0.7, // Saturation\n        0.5 // Lightness\n    ));\n    \n    // Add turbulence for dynamic color transitions\n    float turb = turbulent(vec3(uv * 8.0, time));\n    color *= vec3(1.0 + turb * 0.2);\n    \n    // Combine glow and color\n    vec3 finalColor = mix(vec3(0.0), color, glow);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_223.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create polar coordinates\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Multiple sine waves with different frequencies and phases\n    float wave1 = sin(a * 3.0 + iTime * 2.0) / r;\n    float wave2 = sin(a * 5.0 + iTime * 3.0 + PI) / r;\n    float wave3 = sin(a * 7.0 + iTime * 4.0 + PI*2.0) / r;\n    \n    // Combine waves with RGB offsets\n    vec3 color = vec3(wave1, wave2, wave3);\n    \n    // Add noise for extra detail\n    float noise = turbulent(st * 5.0 + iTime);\n    color += noise * 0.5;\n    \n    return vec4(clamp(color, 0.0, 1.0), 1.0);\n}"
  },
  "data_224.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 centered = uv - 0.5;\n    \n    // Create a distance field from center\n    float dist = length(centered);\n    \n    // Add some time-based movement\n    float time = iTime * 0.5;\n    \n    // Create a basic sine wave pattern\n    float baseSine = sin(dist * 4.0 + time) * 0.5 + 0.5;\n    \n    // Add another layer of sine waves with rotation\n    vec2 rotated = centered * mat2(cos(time), -sin(time), sin(time), cos(time));\n    float rotatedDist = length(rotated);\n    float rotatedSine = sin(rotatedDist * 8.0 + time) * 0.5 + 0.5;\n    \n    // Combine the patterns\n    float combined = (baseSine + rotatedSine) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(time * 2.0, 1.0),  // Hue\n        0.7,                   // Saturation\n        combined               // Lightness\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_225.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create base wave pattern with noise\n    vec3 waves = sin(uv.xyy * 10.0 + time) * 0.5 + 0.5;\n    waves += noise(vec3(uv, time)) * 0.4;\n    \n    // Add turbulence for more complex movement\n    float turb = turbulent(vec2(uv.x * 0.5 + time, uv.y * 0.5));\n    waves += sin(time + uv.y * 8.0) * 0.3;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(waves.x * 0.6 + 0.3, 0.7, 0.5);\n    color *= hsl2rgb(vec3(time * 0.1, 0.8, 0.9));\n    \n    // Combine effects for final output\n    return vec4(color * (waves.x + waves.y) * 0.6, 1.0);\n}"
  },
  "data_226.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 1.5; // Speed parameter\n    \n    // Create rotating hexagon pattern\n    vec2 pos = uv * 2.0 - 1.0;\n    float angle = atan(pos.y, pos.x) + time;\n    float radius = length(pos);\n    \n    // Add turbulence for expanding rings effect\n    float ringEffect = turbulent(vec3(pos * 5.0, time)) * 0.5;\n    float hexPattern = sin(6.0 * (angle - time)) * 0.5 + 0.5;\n    \n    // Combine patterns and add color transitions\n    float combined = min(hexPattern, ringEffect);\n    vec3 color = hsl2rgb(vec3(fract(time * 0.1), 1.0, 0.8));\n    \n    // Add noise to colors for dynamic effect\n    color += noise(vec3(pos * 4.0, time)) * 0.2;\n    \n    return vec4(combined * color + (1.0 - combined) * 0.2, 1.0);\n}"
  },
  "data_227.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating coordinate system\n    float t = iTime * 0.5;\n    vec2 rotUv = uv * mat2(cos(t), sin(t), -sin(t), cos(t));\n    \n    // Flowing sine waves with dynamic frequency and amplitude\n    float wave1 = sin(rotUv.x * 4.0 + t) * 0.5 + 0.5;\n    float wave2 = sin(rotUv.y * 4.0 + t * 0.7) * 0.5 + 0.5;\n    \n    // Combine waves with turbulence\n    vec3 noisePattern = vec3(\n        noise(vec3(uv * 10.0 + t, 0.0)) * 0.5 + 0.5,\n        noise(vec3(uv * 12.0 + t * 0.6, 0.0)) * 0.5 + 0.5,\n        noise(vec3(uv * 8.0 + t * 0.4, 0.0)) * 0.5 + 0.5\n    );\n    \n    // Dynamic color shifts using HSL\n    vec3 hslColor = vec3(\n        mod(t * 0.1 + turbulent(uv * 2.0), 1.0),\n        0.7,\n        0.8\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Mix patterns and colors\n    float intensity = (wave1 + wave2) * 0.5;\n    vec3 finalColor = mix(noisePattern, rgbColor, intensity);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_228.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create hexagonal grid using polar coordinates\n    float angleStep = PI / 3.0;\n    float cellSize = 0.1;\n    \n    // Calculate which hexagon the point is in\n    float angleMod = mod(theta, angleStep);\n    float radiusMod = r - floor(r / cellSize) * cellSize;\n    \n    // Create hexagonal pattern using distance field\n    float dist = abs(radiusMod - cellSize/2.0);\n    float pattern = smoothstep(0.0, 0.5*cellSize, dist);\n    \n    // Calculate color based on time and position\n    vec3 warmColor = hsl2rgb(vec3(0.0, 1.0, 0.5));   // Warm orange-red\n    vec3 coolColor = hsl2rgb(vec3(120.0, 1.0, 0.5)); // Cool cyan\n    \n    // Mix colors based on time and position\n    float mixAmount = sin(iTime + theta) * 0.5 + 0.5;\n    vec3 color = mix(warmColor, coolColor, mixAmount);\n    \n    // Add some noise for extra texture\n    float noiseValue = turbulent(vec2(theta, r)) * 0.1;\n    color *= 1.0 + noiseValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_229.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating radial pattern\n    float distance = length(uv);\n    float pulse = sin(iTime * 0.5 + distance * 10.0) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for organic feel\n    vec2 rotatedUV = uv * mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    float noiseValue = turbulent(rotatedUV * 10.0) * 0.5 + 0.5;\n    \n    // Create vibrant color transitions using HSL\n    vec3 hslColor = vec3(\n        distance * 240.0 + iTime * 60.0,   // Hue variation over time and space\n        0.8,                                // Saturation\n        pulse                               // Brightness modulation\n    );\n    \n    // Convert to RGB and mix with noise\n    vec3 color = hsl2rgb(hslColor) * (noiseValue + turbulent(rotatedUV * 5.0) * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_23.json": {
    "src": "\n//prompt: hidden complexity\nvec4 Effect2(vec2 uv) {\n    // Create a base pattern with hidden complexity\n    vec2 distortedUV = uv + 0.1 * sin(uv.x * 8.0 + iTime) + 0.1 * cos(uv.y * 7.0 + iTime);\n    \n    // Layered patterns\n    float pattern1 = abs(sin(distortedUV.x * 4.0)) + abs(cos(distortedUV.y * 4.0));\n    float pattern2 = abs(sin(iTime * 0.5 + distortedUV.y * 6.0) ) * \n                    abs(cos(iTime * 0.3 + distortedUV.x * 6.0));\n    \n    // Combine patterns with color\n    vec3 baseColor = vec3(0.1, 0.1, 0.2); // Dark base color\n    vec3 accentColor = vec3(0.3, 0.4, 0.5);\n    \n    float blendFactor = smoothstep(0.0, 1.0, pattern1 * 0.7 + pattern2 * 0.3);\n    vec3 finalColor = mix(baseColor, accentColor, blendFactor);\n    \n    // Add subtle radial pattern\n    vec2 polarUV = uv * 1.5 - 0.5;\n    float radius = length(polarUV) * 4.0 + iTime * 0.2;\n    float rings = abs(sin(radius)) * 0.3;\n    \n    finalColor += rings * accentColor * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}\n"
  },
  "data_230.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    // Add time-based rotation\n    float speed = 1.0; // Adjust this value to change rotation speed\n    angle += speed * iTime;\n    // Create smooth color transitions using HSL\n    vec3 hslColor;\n    hslColor.x = mod(angle / (2.0 * PI), 1.0); // Hue based on angle\n    hslColor.y = 0.7; // Saturation\n    hslColor.z = 0.5; // Lightness\n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_231.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a centered coordinate system\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add time-based movement\n    float time = iTime * 0.5;\n    \n    // Create two interweaving sine waves with different frequencies and phases\n    float wave1 = sin(st.x * 4.0 + time) * cos(st.y * 3.0 + time);\n    float wave2 = sin(st.y * 4.0 - time) * cos(st.x * 3.0 - time);\n    \n    // Combine the waves and add turbulence\n    float combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(vec2(st.x * 2.0, st.y * 2.0)) * 0.3;\n    \n    // Convert to HSL color with dynamic shifts\n    vec3 color = hsl(\n        mod(combined * 180.0 + time * 50.0, 360.0),  // Hue\n        0.7,                                         // Saturation\n        0.5                                          // Lightness\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_232.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create flower-like pattern with multiple petals\n    float petal = sin(a * 8.0 + iTime * 2.0); \n    float d = abs(r - 0.5 * (1.0 + 0.3 * petal));\n    \n    // Add turbulence for dynamic noise effect\n    vec3 noisePos = vec3(st.x, st.y, iTime);\n    float turb = turbulent(noisePos) * 0.2;\n    \n    // Combine shape and noise\n    float pattern = smoothstep(0.1, 0.2, d + turb);\n    \n    // Create color with time-based shifts\n    vec3 hslColor = vec3(\n        fract(iTime * 0.5 + a * 0.2), // Hue variation over time and position\n        0.7 + pattern * 0.3,          // Saturation\n        0.5 + turb * 0.2             // Lightness influenced by noise\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_233.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    float time = iTime * 0.5;\n    \n    // Create hexagonal grid pattern\n    vec2 st = uv * 10.0; // Scale up for multiple hexagons\n    vec2 pos = fract(st - time) * 2.0 - 1.0;\n    \n    // Convert to polar coordinates\n    float angle = atan(pos.y, pos.x);\n    float radius = length(pos);\n    \n    // Create rotating hexagonal pattern\n    angle += time * 0.25; // Rotate over time\n    \n    // Sample around the circle at different angles for hexagon effect\n    float sum = 0.0;\n    for(float i = 0.0; i < PI*2.0; i += PI/3.0) {\n        vec2 dir = vec2(cos(angle + i), sin(angle + i));\n        sum += dot(dir, pos);\n    }\n    \n    // Add pulsating effect\n    sum += sin(time * 4.0 + radius * 10.0) * 0.5;\n    \n    // Apply noise texture for dynamic variation\n    vec2 noiseScale = st * 0.1;\n    float noiseVal = noise(noiseScale);\n    sum = mix(sum, sum + noiseVal * 0.3, 0.5);\n    \n    // Color transformation with pulsating HSL values\n    vec3 hslColor = vec3(120.0/360.0, 0.7, 0.5 + sin(time) * 0.4);\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color * sum * 0.5 + 0.5, 1.0);\n}"
  },
  "data_234.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base pattern using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Add noise and turbulence\n    float noiseVal = turbulent(vec3(uv * 4.0, iTime));\n    vec3 color = hsl(theta * 0.1, r * 0.6 + 0.4, r * 0.8 + 0.2);\n    \n    // Mix in noise and add glow effect\n    color *= mix(vec3(0.5), vec3(1.0), smoothstep(0.7, 1.0, r));\n    color += noiseVal * 0.4;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_235.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a checkerboard pattern with dynamic movement\n    vec2 st = uv * 10.0; // Scale up for more cells\n    vec2 ipos = floor(st); // Get integer position\n    \n    // Add time-based movement to the pattern\n    float timeScale = sin(iTime * 0.5) * 0.5 + 0.5;\n    st += timeScale * 0.3; \n    \n    // Checkerboard condition using modulo operation\n    float check = mod(ipos.x + ipos.y, 2.0);\n    \n    // Create smooth color transitions using sine functions\n    vec3 color1 = hsl(0.6, 0.8, 0.5); // Blue base color\n    vec3 color2 = hsl(0.1, 0.8, 0.5); // Red base color\n    \n    // Smooth transition between colors using sine wave\n    float mixFactor = sin(iTime * 0.4 + uv.x * 2.0) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixFactor);\n    \n    // Apply checkerboard pattern\n    finalColor *= check == 0.0 ? 1.0 : 0.7; // Alternate brightness\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_236.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating diagonal pattern using time-based angle\n    float time = iTime * 0.5;\n    vec2 rotatedUV = uv * mat2(cos(time), sin(-time), sin(time), cos(time));\n    \n    // Scale and offset for diagonal stripes\n    vec2 scaledUV = rotatedUV * 8.0 + vec2(4.0, 4.0);\n    \n    // Create checkerboard pattern with noise modulation\n    float pattern = abs(sin(scaledUV.x) * sin(scaledUV.y));\n    pattern += turbulent(scaledUV * 0.5 + time) * 0.3;\n    \n    // Color transition using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(time * 0.1 + scaledUV.x * 0.1 + scaledUV.y * 0.1),\n        0.7,\n        0.5\n    ));\n    \n    // Add turbulence for dynamic effect\n    float wave = turbulent(scaledUV * 0.2 + vec2(0.0, time));\n    pattern += wave * 0.3;\n    \n    // Final color with alpha\n    return vec4(color * (pattern * 0.5 + 0.5), 1.0);\n}"
  },
  "data_237.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal pattern using angle and radius\n    a += iTime; // Rotate over time\n    float angle = mod(a + sin(r * 5.0 + iTime) * 0.5, PI * 2.0);\n    float segment = mod(angle / (PI/3.0), 1.0); // Divide into hex segments\n    \n    // Create pulsating color effect\n    vec3 color;\n    color.x = sin(iTime + r * 5.0) * 0.5 + 0.5; // Red component\n    color.y = sin(iTime + r * 5.0 + PI/2.0) * 0.5 + 0.5; // Green component\n    color.z = sin(iTime + r * 5.0 + PI) * 0.5 + 0.5; // Blue component\n    \n    // Add noise to create organic movement\n    float noiseVal = noise(vec2(r, a)) * 0.1;\n    segment += noiseVal;\n    \n    // Create hexagonal boundaries with pulsing effect\n    float border = smoothstep(0.4 + sin(iTime) * 0.3, 0.5 + sin(iTime) * 0.3, segment);\n    \n    // Mix colors for final output\n    vec3 finalColor = mix(vec3(1.0), color, border);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_238.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    vec2 st = uv - 0.5;\n    float d = length(st);\n    \n    // Polar coordinates\n    float theta = atan2(st.y, st.x) + iTime * 0.1;\n    \n    // Color wheel effect using HSL colors\n    vec3 colorWheel = hsl(theta / (2.0 * PI), 0.7, 0.6);\n    \n    // Pulsating ring effect\n    float pulse = sin(iTime * 0.5 + d * 10.0) * 0.5 + 0.5;\n    vec3 colorRing = hsl(0.5, 0.8, pulse);\n    \n    // Combine effects with turbulence\n    float turb = turbulent(vec2(theta / (2.0 * PI), d));\n    vec3 finalColor = mix(colorWheel, colorRing, abs(turb) * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_239.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Add rotation over time\n    theta += 0.5 * iTime;\n    \n    // Create kaleidoscope effect with 6-fold symmetry\n    theta = mod(theta, PI/3.0);\n    theta = fract(theta / (PI/3.0)) * (PI/3.0);\n    \n    // Create triangle pattern\n    float pattern = smoothstep(0.0, 1.0, sin(theta) * r + 0.5);\n    pattern += smoothstep(0.0, 1.0, sin(theta + 2.0*PI/3.0) * r + 0.5);\n    pattern += smoothstep(0.0, 1.0, sin(theta - 2.0*PI/3.0) * r + 0.5);\n    \n    // Add noise and turbulence\n    float noiseVal = turbulent(uv * 10.0 + iTime);\n    pattern = mix(pattern, noiseVal, 0.2);\n    \n    // Create color from pattern\n    vec3 color = hsl2rgb(vec3(\n        fract(theta/PI + 0.5*iTime),\n        0.7,\n        smoothstep(0.0, 1.0, r)\n    ));\n    \n    return vec4(color * pattern, 1.0);\n}"
  },
  "data_24.json": {
    "src": "\n//prompt:a fractal\nvec4 Effect2(vec2 uv) {\n    // Mandelbrot set fractal\n    vec2 c = (uv * 4.0 - 2.0); // Scale to (-2,2) range for better view\n    vec2 z = vec2(0.0);\n    \n    float maxIter = 100.0;\n    float iter = 0.0;\n    \n    while(iter < maxIter && length(z) <= 4.0) {\n        // Classic Mandelbrot formula: z = z^2 + c\n        vec2 nextZ = vec2(\n            z.x*z.x - z.y*z.y + c.x,\n            2.0 * z.x*z.y + c.y\n        );\n        z = nextZ;\n        iter++;\n    }\n    \n    // Color based on iteration count\n    float value = iter / maxIter;\n    \n    // Simple color palette using sine functions for smooth gradients\n    vec3 color = vec3(\n        sin(1.0 * value),\n        sin(2.0 * value + 0.5),\n        sin(3.0 * value + 1.0)\n    ) * 0.5 + 0.5; // Scale to [0,1] range\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_240.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Animate the pattern over time\n    theta += iTime * 0.5;\n    r += iTime * 0.5;\n    \n    // Create a grid of circles using polar coordinates\n    vec2 st = vec2(theta, r);\n    st.x *= 1.0 / (pi * 2.0); // Normalize angle to [0,1]\n    st.y *= 0.5; // Scale radius\n    \n    // Add some turbulence for variation\n    float turb = turbulent(uv * 3.0 + iTime) * 0.5;\n    \n    // Create color based on distance from center and time\n    vec3 color = hsl(theta * 2.0, 1.0, 0.5 + 0.5 * sin(r * 10.0 + iTime));\n    \n    // Mix in some turbulence for depth\n    color *= 1.0 + turb * 0.5;\n    \n    return vec4(color, 1.0 - length(uv) * 0.5);\n}"
  },
  "data_241.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based animation\n    float time = iTime * 0.5;\n    \n    // Add some movement to the UV coordinates using sine waves\n    vec2 pos = uv + sin(uv * 10.0 + time) * 0.3;\n    \n    // Generate noise and turbulence patterns\n    float noisePattern = noise(pos * 10.0 + sin(time) * 2.0);\n    float turbulentPattern = turbulent(pos * 5.0 + vec2(sin(time), cos(time)));\n    \n    // Create a color transition effect using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        time * 0.1,   // Hue\n        0.7 + noise(pos * 20.0) * 0.3, // Saturation with some noise variation\n        0.5 + sin(time * 0.5) * 0.5    // Brightness with time-based modulation\n    ));\n    \n    // Combine patterns and colors for the final effect\n    vec3 finalColor = mix(\n        color,\n        vec3(1.0, 1.0, 1.0),  // White glow\n        smoothstep(0.0, 1.0, noisePattern * turbulentPattern)\n    );\n    \n    // Add some depth and detail using pow function\n    finalColor = pow(finalColor, vec3(2.0));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_242.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form with rotation\n    vec2 polar = vec2(\n        atan2(uv.y - 0.5, uv.x - 0.5) + iTime * 0.5,\n        length(uv - 0.5)\n    );\n    \n    // Create hexagonal grid pattern\n    vec2 grid = floor(polar * 10.0 + vec2(0.5, 0.5));\n    float n = noise(grid);\n    \n    // Add noise to create organic shape variations\n    polar += vec2(n * 0.1, n * 0.3);\n    \n    // Create hexagonal pattern with inner details\n    float hex = sin(6.0 * polar.x) + cos(6.0 * polar.x);\n    float pattern = abs(hex) < 0.5 ? 1.0 : 0.0;\n    float inner = sin(12.0 * polar.x) < 0.5 ? 1.0 : 0.0;\n    \n    // Combine patterns and add glow effect\n    pattern *= inner;\n    float glow = smoothstep(0.4, 0.5, polar.y);\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        0.5 + sin(iTime * 0.1 + grid.x) * 0.5,\n        0.7,\n        0.8\n    ));\n    \n    return vec4(color * (pattern + glow * 0.5), 1.0);\n}"
  },
  "data_243.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create grid coordinates\n    vec2 st = floor(uv * 10.0);\n    \n    // Add noise to create shifting pattern\n    vec2 offset = vec2(noise(st + iTime), noise(st + iTime + 10.0));\n    \n    // Calculate color based on position and time\n    float hue = fract((st.x + st.y) * 0.1 + iTime * 0.5);\n    vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Add turbulence for dynamic effect\n    float turb = turbulent(uv * 10.0 + offset * 5.0);\n    color *= 1.0 + turb * 0.5;\n    \n    // Create square pattern with varying size\n    vec2 cell = fract(uv * 10.0) - 0.5;\n    float dist = length(cell);\n    float square = smoothstep(0.4, 0.6, dist);\n    \n    // Combine effects\n    color *= mix(vec3(0.8), vec3(1.0), square);\n    return vec4(color, 1.0);\n}"
  },
  "data_244.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create expanding plasma effect using time and radius\n    float timeScale = iTime * 0.5;\n    float baseColor = sin(r * 8.0 + timeScale) * 0.5 + 0.5;\n    // Independent color channel shifts\n    vec3 colors;\n    colors.r = sin(theta + timeScale * 2.0);\n    colors.g = sin(theta + timeScale * 1.5 + PI/2.0);\n    colors.b = sin(theta + timeScale + PI);\n    // Add turbulence for dynamic noise effect\n    float noiseScale = turbulent(vec3(uv * 4.0, iTime)) * 0.5;\n    \n    // Combine color channels with noise and base pattern\n    vec3 finalColor = hsl2rgb(vec3(\n        (baseColor + noiseScale) * 0.6,\n        1.0,\n        0.8\n    )) * colors;\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_245.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing patterns using cosine waves\n    vec2 st = uv * 5.0 + vec2(cos(iTime * 0.5), sin(iTime * 0.5));\n    \n    // Add turbulence for dynamic effect\n    float turb = turbulent(st * 0.5 + iTime);\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(\n        mod(iTime * 0.1 + turb, 1.0),  // Hue variation over time and space\n        0.7,                            // Saturation\n        0.5 + turb * 0.2               // Lightness modulation\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_246.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create hexagonal grid pattern using polar coordinates\n    vec2 polar = vec2(angle / (pi * 2.0), radius);\n    vec2 grid = floor(polar * 10.0); // Scale and quantize\n    \n    // Add turbulence for dynamic movement\n    float tx = turbulent(vec3(grid.x + iTime, grid.y, 0.0)) * 0.5;\n    float ty = turbulent(vec3(grid.x, grid.y + iTime * 0.7, 1.0)) * 0.5;\n    \n    // Calculate final color with RGB shifts\n    vec3 color = hsl2rgb(vec3(\n        (grid.x + tx) * 0.15,\n        (grid.y + ty) * 0.3 + 0.5,\n        0.7 + sin(iTime * 0.5 + grid.x * 0.2) * 0.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_247.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates for rotational symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create rotating sine wave pattern with multiple frequencies\n    float val = sin(a * 4.0 + iTime * 2.0) * 0.5 +\n                sin(a * 8.0 + iTime * 3.0) * 0.3 +\n                sin(a * 16.0 + iTime * 4.0) * 0.2;\n    \n    // Add turbulence for dynamic noise effect\n    val += turbulent(vec2(r, a)) * 0.1;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(val * 0.5 + 0.5, 0.8, 0.6));\n    \n    // Scale the color by the pattern value for brightness variation\n    color *= val * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_248.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create rotating sine wave pattern\n    float speed = 0.5;\n    float time = iTime * speed;\n    float rotation = sin(theta + time) * 0.5 + 0.5;\n    \n    // Combine radius and rotation for color variation\n    vec3 color = vec3(\n        sin(r * 10.0 + time) * 0.5 + 0.5,\n        sin(r * 8.0 + time + PI/2.0) * 0.5 + 0.5,\n        sin(r * 6.0 + time + PI) * 0.5 + 0.5\n    );\n    \n    // Add noise for texture\n    vec2 noiseUV = uv * 10.0;\n    float n = noise(noiseUV);\n    color += n * 0.3;\n    \n    // Convert to HSL and back to RGB for rotating colors\n    vec3 hslColor = vec3(\n        rotation,\n        sin(time) * 0.5 + 0.5,\n        cos(time) * 0.5 + 0.5\n    );\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_249.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave pattern\n    float time = iTime * 0.5;\n    float wave1 = sin(uv.y * 10.0 + time) * 0.5 + 0.5;\n    float wave2 = sin(uv.x * 10.0 - time) * 0.5 + 0.5;\n    \n    // Create rotating color gradient\n    vec2 polar = uv * 2.0 - 1.0;\n    float angle = atan2(polar.y, polar.x) + time;\n    float radius = length(polar);\n    \n    // Use HSL to RGB conversion for smooth color transitions\n    vec3 baseColor = hsl(angle * 0.5 + 0.5, 0.7, 0.6);\n    vec3 secondaryColor = hsl(angle * 0.5 + 0.2, 0.7, 0.4);\n    \n    // Add turbulence for dynamic effect\n    float turb = turbulent(uv * 10.0 + time) * 0.5 + 0.5;\n    \n    // Combine patterns and colors\n    vec3 color = mix(baseColor, secondaryColor, wave1 * wave2 * radius * 0.5);\n    color *= pow(wave1 * wave2 * turb, 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_25.json": {
    "src": "\n//prompt:a fractal\nvec4 Effect2(vec2 uv) {\n    // Mandelbrot fractal\n    vec2 c = (uv * 2.0 - 1.0) * vec2(1.5, 1.0);  // Scale and translate coordinates\n    \n    vec2 z = vec2(0.0);\n    float maxIterations = 100.0;\n    float iterations = 0.0;\n    \n    while (iterations < maxIterations && length(z) <= 2.0) {\n        vec2 nextZ = vec2(\n            z.x * z.x - z.y * z.y + c.x,\n            2.0 * z.x * z.y + c.y\n        );\n        z = nextZ;\n        iterations++;\n    }\n    \n    // Color based on iteration count\n    float colorValue = min(iterations / maxIterations, 1.0);\n    vec3 color = mix(vec3(0.4, 0.7, 0.4), vec3(0.9, 0.2, 0.2), colorValue);\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_250.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5 + sin(iTime) * 0.2;\n    \n    // Create hexagonal grid pattern\n    vec3 color = hsl(\n        fract(angle / (pi/3.0)) * 0.6 + 0.1,\n        0.7,\n        0.5 + 0.5 * sin(iTime + angle)\n    );\n    \n    // Add pulsating effect to radius\n    float pulse = sin(iTime * 2.0) * 0.3;\n    radius += pulse;\n    \n    // Create hexagonal mask\n    vec2 hexCoords = vec2(\n        cos(angle) * radius,\n        sin(angle) * radius\n    );\n    \n    // Add noise texture\n    float noiseValue = turbulent(hexCoords * 5.0 + iTime);\n    color *= hsl2rgb(vec3(\n        fract(iTime / 2.0),\n        1.0,\n        0.5 + noiseValue * 0.5\n    ));\n    \n    // Combine patterns and apply mask\n    float pattern = length(hexCoords) < 1.0 ? 1.0 : 0.0;\n    pattern *= smoothstep(0.8, 1.2, radius);\n    \n    return vec4(color * pattern, 1.0);\n}"
  },
  "data_251.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create hexagonal tiling pattern\n    vec2 q = uv * 5.0;\n    vec3 c = vec3(0.0);\n    \n    // Convert to polar coordinates for hexagonal mapping\n    float dist = length(q - 0.5);\n    float angle = atan2(q.y - 0.5, q.x - 0.5) + iTime * 0.1;\n    \n    // Create hexagonal grid pattern using sine and cosine functions\n    c += sin(vec3(1.0, 2.0, 3.0) * angle + vec3(0.0, 2.0, 4.0)) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for dynamic effect\n    vec3 noiseVal = vec3(noise(vec3(q.x, q.y, iTime)),\n                         noise(vec3(q.y, q.x, iTime + 1.0)),\n                         noise(vec3(q.x * 2.0, q.y * 2.0, iTime + 2.0)));\n    c += turbulent(vec3(q.x, q.y, iTime)) * 0.5;\n    \n    // Convert to HSL and back to RGB for color shifting\n    vec3 hslColor = vec3(angle * 0.15 + sin(iTime) * 0.2,\n                         0.7,\n                         0.6 + noiseVal.x * 0.2);\n    c = hsl2rgb(hslColor);\n    \n    // Add animation by shifting RGB channels over time\n    vec3 rgbShift = vec3(sin(iTime), sin(iTime + 2.0), sin(iTime + 4.0)) * 0.3;\n    c += rgbShift;\n    \n    return vec4(c, 1.0);\n}"
  },
  "data_252.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using UV coordinates and time\n    vec2 st = uv * 10.0 + sin(iTime) * 5.0;\n    \n    // Add noise to create organic patterns\n    float n1 = noise(st);\n    float n2 = turbulent(st + iTime);\n    \n    // Combine noise layers with geometric patterns\n    float pattern = (n1 + n2) * 0.5;\n    pattern += sin(st.x * 0.5 + iTime) * 0.3;\n    pattern += cos(st.y * 0.5 - iTime) * 0.3;\n    \n    // Create pulsating shapes using geometric functions\n    float distance = length(uv);\n    float angle = atan2(uv.y, uv.x);\n    float shape = sin(distance * 10.0 + iTime) * cos(angle * 4.0);\n    \n    // Combine pattern and shape with color transitions\n    vec3 color = hsl(\n        (pattern + shape) * 0.5 + 0.5,\n        0.7 + abs(sin(iTime)) * 0.3,\n        0.5 + cos(iTime) * 0.2\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_253.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    angle += iTime * 5.0;\n    \n    // Create kaleidoscopic effect by repeating angles\n    float sector = mod(angle * 3.0, PI * 2.0);\n    \n    // Generate triangle pattern using sine waves\n    vec2 triPos = vec2(sin(sector + iTime), cos(sector - iTime));\n    float triDistance = length(triPos) * radius;\n    \n    // Create flowing gradient background\n    vec3 bgColor = hsl2rgb(vec3(mod(angle * 0.5 + iTime, 1.0), 0.7, 0.8));\n    \n    // Add turbulence to create dynamic patterns\n    float turb = turbulent(vec3(uv * 0.5, iTime)) * 0.5;\n    bgColor += vec3(turb);\n    \n    // Create triangle color pattern\n    vec3 triColor = hsl2rgb(vec3(mod(angle * 0.3 + iTime, 1.0), 0.8, 0.9));\n    \n    // Combine background and triangles with mix based on distance\n    vec3 finalColor = mix(bgColor, triColor, step(0.5, radius) * (1.0 - turb));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_254.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise pattern with time offset\n    vec3 noise1 = vec3(noise(uv + iTime), noise(uv * 2.0 - iTime), noise(uv * 0.5));\n    \n    // Add turbulent movement\n    float turb = turbulent(vec3(uv, iTime * 0.1)) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.1) * 360.0,\n        0.7,\n        turb * 0.8 + 0.2\n    ));\n    \n    // Add depth and layers using multiple noise scales\n    float detail = (noise(uv * 4.0 + iTime) * 0.5 + 0.5) +\n                  (noise(uv * 2.0 - iTime) * 0.3);\n    \n    // Combine all elements for final color\n    vec3 finalColor = mix(color, vec3(1.0), detail * 0.6) *\n                     (turb * 1.5);\n                     \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_255.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create dynamic sine wave patterns with time-based animation\n    float time = iTime * 0.5;\n    \n    // Wave 1: Horizontal interweaving pattern\n    vec2 st1 = uv + vec2(sin(uv.y * 3.0 + time) * 0.2, cos(uv.x * 3.0 + time + PI) * 0.2);\n    float wave1 = sin(st1.x * 4.0 + time) * 0.5 + 0.5;\n    \n    // Wave 2: Vertical interweaving pattern\n    vec2 st2 = uv + vec2(cos(uv.y * 3.0 + time + PI/2.0) * 0.2, sin(uv.x * 3.0 + time + PI/2.0) * 0.2);\n    float wave2 = sin(st2.y * 4.0 + time + PI/2.0) * 0.5 + 0.5;\n    \n    // Combine waves with complementary colors\n    vec3 color1 = hsl2rgb(vec3(0.5, 0.7, wave1));\n    vec3 color2 = hsl2rgb(vec3(0.0, 0.7, wave2));\n    \n    // Mix colors based on wave patterns and add noise for texture\n    vec3 finalColor = mix(color1, color2, wave2);\n    finalColor += noise(uv * 4.0 + time) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_256.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 col = vec3(0.0);\n    float time = iTime * 0.5;\n    \n    // Generate multiple layers of lines\n    for(float i = 0.0; i < 3.0; i++) {\n        // Calculate line position and rotation\n        float angle = sin(time + i) * 0.5 + i * 0.2;\n        vec2 pos = vec2(sin(time + i * 0.7) * 0.5, cos(time + i * 0.3) * 0.5);\n        \n        // Create line pattern\n        float d = abs(length(uv - pos));\n        float w = 0.1 + sin(time + i) * 0.05;\n        float glow = smoothstep(w, 0.0, d);\n        \n        // Add noise and turbulence\n        vec3 noisePos = vec3(uv * 2.0 + time, time);\n        float turb = turbulent(noisePos) * 0.1;\n        glow *= 1.0 + turb;\n        \n        // Color transition\n        vec3 hslCol = vec3(120.0 + i * 60.0, 1.0, 0.5 + glow * 0.5);\n        col += hsl2rgb(hslCol) * glow;\n    }\n    \n    return vec4(col, 1.0);\n}"
  },
  "data_257.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing velocity based on time and UV coordinates\n    vec2 st = uv * 5.0;\n    float time = iTime * 0.5;\n    \n    // Add some noise to create natural-looking flow\n    vec2 velocity = vec2(\n        sin(st.x + time) * 0.5 + noise(vec3(uv, time)) * 0.1,\n        cos(st.y + time) * 0.5 + turbulent(vec2(uv)) * 0.2\n    );\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        mod(time * 0.1 + uv.x * 2.0, 1.0),  // Hue variation over time and space\n        0.7,                                  // Saturation\n        0.5                                   // Lightness\n    );\n    \n    // Add some noise to the color for more dynamic effect\n    float detail = turbulent(vec3(uv * 2.0 + velocity, time)) * 0.5;\n    color = hsl2rgb(vec3(\n        mod(color.r + detail * 0.1, 1.0),\n        color.g,\n        color.b\n    ));\n    \n    // Combine everything with some alpha for transparency effect\n    return vec4(color, 1.0 - length(velocity) * 0.5);\n}"
  },
  "data_258.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Convert to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    \n    // Create multiple layers of rotating shapes\n    float shape1 = sin(time * 0.5 + angle * 3.0) * 0.5 + 0.5;\n    float shape2 = sin(time * 0.7 + angle * 5.0) * 0.3 + 0.3;\n    \n    // Add noise for texture\n    float noiseValue = noise(vec2(uv.x * 10.0, uv.y * 10.0) + time);\n    float turbulence = turbulent(vec2(uv.x * 5.0, uv.y * 5.0));\n    \n    // Combine shapes and noise\n    float pattern = shape1 * shape2 * (1.0 - noiseValue * 0.5);\n    pattern += turbulence * 0.3;\n    \n    // Create color transitions\n    vec3 color1 = hsl2rgb(vec3(0.2 + time * 0.1, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.6 + time * 0.15, 1.0, 0.7));\n    \n    // Mix colors based on pattern\n    vec3 finalColor = mix(color1, color2, pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_259.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating radial pattern using noise and time modulation\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    \n    // Polar coordinates for radial effect\n    vec2 polar = vec2(length(st), atan2(st.y, st.x));\n    polar.y *= 0.5; // Reduce angle frequency\n    \n    // Time-based pulsation\n    float timePulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Create noise pattern with frequency modulation\n    vec2 noiseScale = vec2(10.0, 10.0);\n    float noiseValue = turbulent(polar * noiseScale + timePulse * 10.0);\n    \n    // Combine radial gradient and noise for color variation\n    float lightness = radius * 0.5 + 0.5;\n    vec3 color = hsl2rgb(vec3(0.6, 0.8, lightness));\n    color *= mix(1.0, 0.5, abs(noiseValue) * timePulse);\n    \n    // Add pulsating glow effect\n    float glow = smoothstep(0.7, 1.0, radius + sin(iTime) * 0.2);\n    color += vec3(glow * 0.4);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_26.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a position vector centered at 0.5\n    vec2 pos = uv - 0.5;\n    \n    // Calculate radius and angle in polar coordinates\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x);\n    \n    // Add some turbulence to create interesting patterns\n    float tr = turbulent(vec3(r * 10.0 + iTime, 0.0, 0.0)) * 0.5;\n    float ttheta = turbulent(vec3(theta * 10.0 + iTime, 0.0, 0.0)) * 0.5;\n    \n    // Create a color vector using HSL\n    vec3 color = hsl(\n        (iTime * 0.2 + theta * 0.5) * 180.0 / PI,\n        0.7 + tr * 0.3,\n        0.5 + ttheta * 0.5\n    );\n    \n    // Convert HSL to RGB and return as vec4 with alpha\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_260.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color with dynamic hue shift\n    vec3 color = hsl(\n        sin(iTime * 0.5 + uv.x * 10.0) * 0.5 + 0.5,  // Hue\n        0.7,  // Saturation\n        0.5   // Lightness\n    );\n    \n    // Add movement and noise to create plasma effect\n    vec2 st = uv * 4.0;\n    float timeOffset = iTime * 0.1;\n    \n    // Create moving pattern using noise\n    float noise1 = noise(vec3(st + timeOffset, 0.0)) * 0.5;\n    float noise2 = noise(vec3(st * 0.5 + timeOffset * 0.7, 0.0)) * 0.3;\n    \n    // Combine noise layers\n    float combinedNoise = noise1 + noise2;\n    \n    // Add turbulence for light ripples\n    vec2 rippleUV = uv * 8.0 + vec2(sin(iTime) * 2.0, cos(iTime) * 2.0);\n    float ripple = turbulent(rippleUV) * 0.4;\n    \n    // Combine all elements\n    color *= combinedNoise + 0.5;  // Modulate base color with noise\n    color += ripple;               // Add light ripples\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_261.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 pos = vec3(uv * 2.0 - 1.0, iTime * 0.5);\n    float t = iTime * 0.2;\n    \n    // Complex noise pattern with turbulence\n    float n = turbulent(pos + vec3(t)) * 0.5 + 0.5;\n    n += noise(vec3(uv * 4.0, t)) * 0.3;\n    \n    // Color based on position and noise\n    vec3 color = hsl2rgb(vec3(\n        (n * 0.6 + 0.3) * pi,\n        1.0 - abs(n - 0.5) * 2.0,\n        n * 0.3 + 0.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_262.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a kaleidoscope effect by mirroring coordinates\n    vec2 p = mod(uv * 10.0, 1.0);\n    p = abs(p - 0.5) * 2.0;\n    \n    // Add time-based animation\n    float t = iTime * 0.1;\n    \n    // Create sine wave pattern with shifting frequencies\n    float wave = sin(p.x * 10.0 + t) * cos(p.y * 10.0 - t);\n    \n    // Add turbulence for more dynamic patterns\n    vec2 noiseUV = uv * 5.0 + t;\n    float turb = turbulent(noiseUV);\n    \n    // Combine wave and turbulence effects\n    float pattern = (wave + turb) * 0.5 + 0.5;\n    \n    // Create shifting hues using HSL color space\n    vec3 color = hsl(pattern * 360.0, 1.0, 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_263.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create square pattern using polar coordinates\n    float angle = theta + sin(r * 5.0 + iTime) * 0.5;\n    vec2 rotatedUV = vec2(\n        cos(angle) * st.x - sin(angle) * st.y,\n        sin(angle) * st.x + cos(angle) * st.y\n    );\n    \n    // Add turbulence effect\n    float turb = turbulent(rotatedUV * 10.0 + iTime);\n    r += turb * 0.2;\n    \n    // Create color gradient with time-based hue shift\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.5, 1.0), // Hue that changes over time\n        0.7 + turb * 0.3,     // Saturation\n        0.5 + cos(iTime) * 0.5 // Lightness with pulsing effect\n    ));\n    \n    // Combine effects for final output\n    return vec4(color * (1.0 - r * 0.5), 1.0);\n}"
  },
  "data_264.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    float dist = length(uv);\n    \n    // Add pulsation based on time\n    float pulse = sin(iTime * 0.5) / 3.0;\n    dist += pulse;\n    \n    // Create color transition from red to blue\n    vec3 colorHSL = vec3(\n        (dist + sin(iTime) / 4.0) * 0.5,  // Hue: transitions between red and blue\n        0.8,                              // Saturation\n        mix(0.5, 0.7, dist)              // Lightness varies with distance\n    );\n    \n    // Add noise for extra texture\n    colorHSL += vec3(noise(uv * 10.0 + iTime), noise(uv * 10.0 + iTime + 1.0), noise(uv * 10.0 + iTime + 2.0)) * 0.1;\n    \n    return vec4(hsl2rgb(colorHSL), 1.0);\n}"
  },
  "data_265.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing patterns using sine waves with varying frequencies\n    float time = iTime * 0.5;\n    \n    // Complex wave pattern combining multiple frequencies\n    vec3 waves = vec3(\n        sin(uv.x * 8.0 + time) * cos(uv.y * 4.0 - time),\n        sin(uv.y * 6.0 + time * 0.7) * cos(uv.x * 5.0 - time * 0.3),\n        sin((uv.x + uv.y) * 12.0 + time) \n    );\n    \n    // Add noise and turbulence for organic feel\n    vec2 noiseUV = uv * 4.0 + vec2(time, time);\n    float t = turbulent(noiseUV);\n    \n    // Mix in RGB shifts with time variation\n    vec3 colorShifts = vec3(\n        sin(time * 0.7) * 0.5 + 0.5,\n        cos(time * 0.6) * 0.5 + 0.5,\n        sin(time * 0.8 + PI) * 0.5 + 0.5\n    );\n    \n    // Combine waves and noise with color shifts\n    vec3 finalColor = hsl2rgb(vec3(\n        (waves.x + t) * 0.5 + 0.5,\n        (waves.y + t) * 0.7 + 0.3,\n        (waves.z + t) * 0.4 + 0.6\n    )) * colorShifts;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_266.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create center point\n    vec2 center = vec2(0.5, 0.5);\n    \n    // Calculate vector from center to current fragment position\n    vec2 pos = uv - center;\n    \n    // Convert to polar coordinates\n    float angle = atan(pos.y, pos.x);\n    float radius = length(pos) * 2.0;\n    \n    // Add noise for dynamic effect\n    radius += noise(vec3(uv * 10.0 + iTime, 0.0)) * 0.1;\n    radius = abs(radius - 0.5);\n    \n    // Create color cycling using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + angle * 0.1) * 360.0,\n        0.7,\n        0.5 + sin(iTime + radius * 2.0) * 0.5\n    );\n    \n    // Convert HSL to RGB\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add rotation effect\n    float rot = iTime * 0.1;\n    vec2 rotatedPos = vec2(\n        cos(rot) * pos.x - sin(rot) * pos.y,\n        sin(rot) * pos.x + cos(rot) * pos.y\n    );\n    \n    // Create turbulence effect\n    float turb = turbulent(vec3(rotatedPos, iTime)) * 0.5;\n    \n    // Combine effects for final color\n    vec3 finalColor = rgbColor * (1.0 - turb) + vec3(turb);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_267.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for better pattern size\n    vec2 st = uv * 10.0;\n    \n    // Create two offset sine waves in X and Y directions\n    float waveX = sin(st.x + iTime) * 0.5 + 0.5;\n    float waveY = sin(st.y + iTime + PI/2.0) * 0.5 + 0.5;\n    \n    // Combine waves with some noise for complexity\n    float combined = (waveX + waveY) * 0.5;\n    combined += noise(vec2(st.x*0.5, st.y*0.5)) * 0.1;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        combined * 360.0 + iTime * 100.0,\n        0.7,\n        0.8\n    );\n    \n    // Add some turbulence for dynamic background\n    float turb = turbulent(vec2(st.x*0.5, st.y*0.5)) * 0.3;\n    color += turb;\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_268.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create rotating pattern with time-based rotation\n    theta += iTime * 3.0;\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(st * 5.0 + iTime, 0.0)) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        mod(theta * 8.0 + iTime, 2.0 * PI) / (2.0 * PI),  // Hue variation\n        1.0 - turb * 0.5,                                 // Saturation\n        0.7 + turb * 0.3                                  // Lightness\n    );\n    \n    // Convert to RGB and mix with radial gradient\n    vec3 rgbColor = hsl2rgb(hslColor);\n    float gradient = smoothstep(1.0, 0.0, r);\n    \n    // Combine effects\n    vec3 finalColor = mix(vec3(0.0), rgbColor, gradient * (1.0 + sin(iTime) * 0.5));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_269.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float angle = sin(iTime * 0.5) + 1.5;\n    vec2 rotatedUv = vec2(\n        uv.x * cos(angle) - uv.y * sin(angle),\n        uv.x * sin(angle) + uv.y * cos(angle)\n    );\n    \n    // Create fractal pattern using recursive transformations\n    vec2 originalUv = rotatedUv;\n    for (int i = 0; i < 5; i++) {\n        rotatedUv = abs(rotatedUv * 4.0 - 1.0);\n        rotatedUv += turbulent(vec3(rotatedUv, iTime)) * 0.2;\n    }\n    \n    // Calculate color based on transformed coordinates\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.5 + length(originalUv) * 2.0),\n        1.0,\n        0.5 + turbulent(vec2(rotatedUv)) * 0.5\n    ));\n    \n    // Add noise and depth to the color\n    float noiseValue = noise(vec3(rotatedUv, iTime));\n    color *= 0.8 + noiseValue * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_27.json": {
    "src": "\n//prompt: a sdf of a weird shape\nvec4 Effect2(vec2 uv) {\n    // Create a weird shape using signed distance function\n    vec2 distUV = uv * 10.0 + iTime;\n    \n    float gridX = sin(distUV.y * 5.0) / (sin(distUV.x * 3.0 + iTime) + 1.0);\n    float gridY = cos(distUV.x * 7.0) / (cos(distUV.y * 2.0 - iTime) + 1.0);\n    \n    float shape = sin(gridX * 3.0 + iTime * 2.0) * \n                 cos(gridY * 5.0 - iTime) +\n                 length(uv * 4.0) *\n                 (sin(length(uv) * 8.0) / 2.0);\n    \n    float noise = fract(sin(dot(uv, vec2(123.45, 678.9))) * 4321.0);\n    \n    shape = abs(shape + noise) * 0.5;\n    \n    return vec4(vec3(shape), 1.0);\n}        \n"
  },
  "data_270.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create a grid of points with sine wave modulation\n    float x = sin(st.x * 0.5 + iTime) * 0.5 + 0.5;\n    float y = sin(st.y * 0.5 + iTime + PI/2.) * 0.5 + 0.5;\n    \n    // Combine coordinates and add turbulence\n    vec3 color = hsl2rgb(vec3(\n        (x + y) * 0.5,   // Hue based on position\n        1.0 - turbulent(st.xyy * 0.5), // Saturation with turbulence\n        0.8 + sin(iTime) * 0.2 // Brightness variation over time\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_271.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create a basic sine wave pattern\n    vec2 st = uv * 10.0;\n    float sinWave = sin(st.x + time) * 0.5 + 0.5;\n    \n    // Add geometric pattern with polar coordinates\n    vec2 polar = uv * 2.0 - 1.0;\n    float radius = length(polar);\n    float angle = atan2(polar.y, polar.x) + time;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(time * 0.5) * 0.5 + 0.5,\n        0.7,\n        0.8\n    );\n    \n    // Add noise and turbulence for dynamic effect\n    float noiseVal = noise(vec2(uv.x * 10.0, time));\n    float turbulentVal = turbulent(vec3(uv, time));\n    \n    // Combine patterns and colors\n    vec3 color = hsl(hslColor.x, hslColor.y, hslColor.z);\n    color *= sinWave;\n    color += noiseVal * 0.2;\n    color += turbulentVal * 0.1;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_272.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying offset for movement\n    vec2 st = uv + sin(iTime * 0.5) * 0.1;\n    \n    // Add some turbulence at different scales\n    float t1 = turbulent(st * 3.0 + iTime);\n    float t2 = turbulent(st * 6.0 - iTime);\n    \n    // Combine the turbulence values with a mix of time and position\n    float noiseFactor = (t1 * 0.5 + t2 * 0.5) * 0.5 + 0.5;\n    \n    // Create an eerie color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.2) * 0.6 + 0.4,   // Hue variation over time\n        noiseFactor * 0.7 + 0.3,       // Saturation based on noise\n        noiseFactor * 0.5 + 0.25       // Lightness based on noise\n    ));\n    \n    // Add some radial movement and depth\n    vec2 toCenter = st - vec2(0.5);\n    float distFromCenter = length(toCenter) * 4.0;\n    color *= sin(distFromCenter - iTime) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_273.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Add time-based rotation and pulsation\n    theta += iTime * 0.5;\n    r *= 0.7 + sin(iTime) * 0.3;\n    \n    // Create a noise pattern with turbulence\n    vec2 noiseScale = vec2(4.0, 4.0);\n    float n1 = noise(st * noiseScale + iTime);\n    float n2 = turbulent(vec3(st * 2.0, iTime));\n    \n    // Combine noise layers and create color gradients\n    float gradient = (1.0 - cos(r)) * 0.5;\n    vec3 color = hsl(theta * 0.5 + 0.5, 0.7 + n1 * 0.2, 0.5 + sin(iTime) * 0.3);\n    \n    // Add pulsating effect\n    float pulse = sin(iTime * 2.0) * 0.3;\n    color *= 1.0 + pulse;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_274.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Distort UV coordinates with sine waves\n    vec2 distortedUV = uv + 0.3 * sin(5.0 * uv + iTime);\n    \n    // Create a grid pattern using mod\n    vec2 grid = mod(distortedUV * 10.0, 1.0);\n    \n    // Add rotation based on time and position\n    float angle = iTime * 0.2 + length(grid - 0.5) * 2.0;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle),\n                         sin(angle), cos(angle));\n    vec2 rotatedGrid = (grid - 0.5) * rotMatrix + 0.5;\n    \n    // Create color variations using HSL\n    vec3 hslColor = vec3(\n        mod(length(rotatedGrid - 0.5) * 10.0 + iTime, 1.0),\n        0.7,\n        0.6 + 0.4 * sin(iTime)\n    );\n    \n    // Convert to RGB and add turbulence effect\n    vec3 rgbColor = hsl2rgb(hslColor);\n    float turb = turbulent(vec3(rotatedGrid, iTime));\n    rgbColor *= 1.0 + 0.5 * turb;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_275.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    vec2 center = uv - 0.5;\n    float angle = sin(iTime * 0.5) * pi;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotated_uv = rot * center + 0.5;\n    // Checkerboard pattern with dynamic color cycling\n    vec2 scaled_uv = rotated_uv * 10.0;\n    vec2 cell = floor(scaled_uv);\n    float sum_xy = cell.x + cell.y;\n    \n    // Dynamic RGB shifts based on time and position\n    vec3 color_even = vec3(\n        sin(iTime + sum_xy) * 0.5 + 0.5,\n        sin(iTime + sum_xy + 2.0) * 0.5 + 0.5,\n        sin(iTime + sum_xy + 4.0) * 0.5 + 0.5\n    );\n    \n    vec3 color_odd = vec3(\n        sin(iTime + sum_xy + 1.0) * 0.5 + 0.5,\n        sin(iTime + sum_xy + 3.0) * 0.5 + 0.5,\n        sin(iTime + sum_xy + 5.0) * 0.5 + 0.5\n    );\n    \n    // Combine colors based on checkerboard pattern\n    float is_even = mod(sum_xy, 2.0);\n    vec3 final_color = mix(color_odd, color_even, is_even);\n    return vec4(final_color, 1.0);\n}"
  },
  "data_276.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create grid of circles\n    vec2 st = uv * 10.0; // Scale up for more circles\n    vec2 grid = floor(st);\n    \n    // Calculate distance from center\n    vec2 offset = fract(st) - 0.5;\n    float dist = length(offset);\n    \n    // Time-based expansion\n    float time = iTime * 0.1;\n    float radius = 0.3 + noise(vec3(grid, time)) * 0.2;\n    \n    // Check if inside circle\n    float alpha = 0.0;\n    if (dist < radius) {\n        // Calculate color with rainbow hues\n        float hue = dist * 6.0 + time * 6.0; // Rainbow effect\n        vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5));\n        \n        // Add noise for texture\n        color *= 1.0 + noise(vec3(uv * 100.0, time)) * 0.5;\n        \n        // Calculate alpha based on distance and time\n        float t = smoothstep(0.0, 1.0, (time - dist) / 2.0);\n        alpha = t;\n        \n        return vec4(color, alpha);\n    }\n    \n    return vec4(0.0);\n}"
  },
  "data_277.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for more detailed pattern\n    vec2 st = uv * 10.0;\n    \n    // Add time-based animation\n    float time = iTime * 0.5;\n    \n    // Create undulating sine wave patterns\n    float waveX = sin(st.x + time) * 0.5 + 0.5;\n    float waveY = sin(st.y + time * 0.7) * 0.5 + 0.5;\n    \n    // Combine waves with turbulence for more dynamic effect\n    vec2 noiseSt = st + vec2(turbulent(vec3(st.x, time, 0.0)), turbulent(vec3(time, st.y, 0.0)));\n    float value = sin(noiseSt.x * pi) * cos(noiseSt.y * pi);\n    \n    // Create vibrant color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        (waveX + waveY + value) * 360.0,   // Hue variation\n        0.8,                                // Saturation\n        0.5 + sin(time) * 0.4             // Brightness variation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_278.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Add rotation over time\n    theta += iTime * 0.5;\n    \n    // Create geometric pattern using sine waves\n    float pattern = sin(theta + iTime) * 0.5 + 0.5;\n    pattern *= sin(r * 10.0 + iTime);\n    \n    // Add noise for shimmering effect\n    vec2 noiseUV = uv + vec2(iTime * 0.1, 0.0);\n    float noiseValue = noise(noiseUV * 10.0) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 baseColor = hsl(theta * 0.5 + 0.5, 0.7, 0.6);\n    vec3 secondaryColor = hsl(r * 0.3 + iTime * 0.2, 0.8, 0.7);\n    \n    // Mix colors based on pattern and noise\n    vec3 finalColor = mix(baseColor, secondaryColor, noiseValue);\n    finalColor = hsv2rgb(finalColor);\n    \n    // Combine everything for the final effect\n    float intensity = pattern * noiseValue;\n    return vec4(finalColor * intensity, 1.0);\n}"
  },
  "data_279.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a position vector with time offset\n    vec3 pos = vec3(uv * 2.0 - 1.0, iTime * 0.5);\n    \n    // Add some turbulence to create flowing effect\n    float t = turbulent(pos * 4.0 + vec3(0.0, 0.0, iTime));\n    t += turbulent(pos * 2.0 + vec3(0.0, 0.0, iTime)) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        sin(iTime * 0.1) * 0.5 + 0.5,\n        0.7 + t * 0.3,\n        0.6 + abs(sin(iTime)) * 0.2\n    );\n    \n    // Add noise to create liquid-like patterns\n    vec2 st = uv * 4.0;\n    float n1 = noise(st);\n    float n2 = noise(st + vec2(0.5, 0.5));\n    float n3 = noise(st + vec2(1.0, 1.0));\n    \n    // Combine noise layers with different weights\n    float liquid = (n1 * 0.4) + (n2 * 0.3) + (n3 * 0.2);\n    liquid += t * 0.5;\n    \n    // Final color transformation\n    vec3 finalColor = hsl2rgb(vec3(\n        color.r,\n        color.g + liquid * 0.3,\n        color.b + liquid * 0.4\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_28.json": {
    "src": "\n//prompt: a fractal\nvec4 Effect2(vec2 uv) {\n    // Recursive fractal pattern using sine functions\n    float scale = 1.0;\n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i < 8; i++) {\n    float value = sin(uv.x * scale + iTime) *\n    sin(uv.y * scale + iTime) *\n    sin((uv.x + uv.y) * scale + iTime);\n    \n    if(value > 0.0) {\n    color += vec3(1.0, 0.5, 0.2) / pow(2.0, float(i));\n    } else {\n    color -= vec3(0.2, 0.5, 1.0) / pow(2.0, float(i));\n    }\n    \n    scale *= 2.0;\n    }\n    \n    return vec4(abs(color * 2.0), 1.0);\n}\n        "
  },
  "data_280.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates and convert to polar\n    vec2 st = uv - 0.5;\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 3.0; // Scale radius\n    \n    // Create rotating pattern with time\n    theta += iTime * 0.5 + sin(iTime) * 0.2;\n    \n    // Add concentric circles with noise modulation\n    float circleMod = mod(r, 1.0);\n    float noiseMod = turbulent(vec3(st.x*2.0, st.y*2.0, iTime)) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.15 + iTime * 0.1,\n        0.7 + noiseMod * 0.3,\n        0.8 - mod(r, 1.0) * 0.4\n    ));\n    \n    // Add fading trails effect using time-based noise\n    float trail = sin(theta * 5.0 + iTime) * exp(-r * 0.2);\n    color += vec3(trail * 0.6);\n    \n    // Mix in some radial variation\n    color *= 1.0 - smoothstep(0.8, 1.0, r / 3.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_281.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale for better pattern distribution\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create rotating polar coordinates\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    float r = length(st);\n    \n    // Create gradient with sine wave modulation\n    float gradient = sin(r * 8.0 + iTime) * 0.5 + 0.5;\n    gradient += sin(theta * 3.0 + iTime * 2.0) * 0.3;\n    \n    // Add noise for texture\n    vec2 noiseScale = st * 4.0 + iTime;\n    float noiseVal = turbulent(noiseScale);\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(theta * 2.0, 0.7, 0.6);\n    vec3 color2 = hsl(sin(iTime) * pi + theta, 0.8, 0.5);\n    vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, gradient));\n    \n    // Add noise influence\n    finalColor *= 1.0 + noiseVal * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_282.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for better noise pattern visibility\n    vec2 st = uv * 50.0;\n    \n    // Create flowing movement using sine wave patterns\n    float dirX = sin(iTime) * 0.5 + 0.5;\n    float dirY = cos(iTime) * 0.5 + 0.5;\n    \n    // Add turbulence to create organic flow patterns\n    float turb = turbulent(st * 0.1);\n    \n    // Combine movement and turbulence for final color offset\n    vec3 colorOffset = mix(vec3(dirX, dirY, 0.0), vec3(turb), 0.5);\n    \n    // Create pulsating colors using HSL conversion\n    float hue = iTime * 0.2 + sin(iTime * 2.0) * 0.5;\n    vec3 hslColor = vec3(hue, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine everything for final output\n    return vec4(rgbColor * colorOffset, 1.0);\n}"
  },
  "data_283.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float scale = 10.0;\n    vec2 grid = floor(uv * scale) / scale;\n    \n    // Create rotating tessellation pattern\n    float angle = iTime * 0.5;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedUV = (uv - 0.5) * rot + 0.5;\n    \n    // Generate color variations using noise and turbulence\n    float noise1 = noise(vec3(grid, iTime * 0.1));\n    float noise2 = turbulent(rotatedUV * 4.0);\n    \n    // Create dynamic color transitions\n    vec3 color1 = hsl(0.5 + noise1 * 0.5, 0.8, 0.6);\n    vec3 color2 = hsl(0.3 + iTime * 0.1, 0.7, 0.5);\n    \n    // Mix colors based on position and time\n    vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, noise2));\n    \n    // Add gradient effect\n    float gradient = length(uv - 0.5) * 0.5 + 0.5;\n    finalColor = mix(finalColor, vec3(gradient), 0.3);\n    \n    return vec4(hsl2rgb(finalColor), 1.0);\n}"
  },
  "data_284.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base pattern with layered sine functions\n    vec2 st = uv * 5.0 + iTime;\n    float base = sin(st.x) * cos(st.y);\n    \n    // Add rotating element\n    float angle = iTime * 0.5;\n    vec2 rotatedUv = uv * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    // Layered sine patterns with time offset\n    float pattern1 = sin(rotatedUv.x * 4.0 + iTime) * 0.5;\n    float pattern2 = cos(rotatedUv.y * 3.0 + iTime * 0.7);\n    float combined = (pattern1 + pattern2) * 0.5;\n    \n    // Add turbulence for more dynamic effect\n    vec3 noisePos = vec3(uv * 4.0, iTime * 0.1);\n    float turb = turbulent(noisePos) * 0.5;\n    \n    // Combine all elements\n    float finalValue = combined + turb;\n    \n    // Create color cycling using HSL\n    vec3 hslColor = vec3(finalValue * 0.5 + 0.5, 1.0, 0.7);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_285.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal tiling\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create hexagonal grid by quantizing polar coordinates\n    float angleSteps = 6.0; // Number of angles for hexagons\n    float radiusSteps = 8.0; // Number of rings\n    \n    // Quantize angle and radius into discrete steps\n    float quantizedTheta = floor(theta / (pi * 2.0 / angleSteps)) * (pi * 2.0 / angleSteps);\n    float quantizedR = floor(r * radiusSteps) / radiusSteps;\n    \n    // Convert back to cartesian coordinates for hexagon centers\n    vec2 center = vec2(cos(quantizedTheta), sin(quantizedTheta)) * quantizedR;\n    \n    // Calculate pulsing values based on time and position\n    float pulse = sin(iTime + quantizedR * 10.0 + quantizedTheta * 5.0) * 0.5 + 0.5;\n    \n    // Create color based on hexagon position and pulsing\n    vec3 hslColor = vec3(\n        mod(quantizedTheta / (pi * 2.0) * 360.0, 360.0), // Hue based on angle\n        1.0, // Full saturation\n        pulse // Lightness based on time\n    );\n    \n    // Convert HSL to RGB and apply smooth gradient\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Create distance field for hexagons with smooth edges\n    float dist = length(st - center);\n    float edgeSmooth = smoothstep(0.1, 0.2, dist);\n    \n    // Final color with pulsing effect\n    vec3 finalColor = mix(vec3(0.0), rgbColor, edgeSmooth);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_286.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    \n    // Create rotating sine wave pattern\n    float time = iTime * 0.5;\n    radius *= 0.75;\n    angle += time;\n    \n    // Add multiple frequency components for complexity\n    float wave1 = sin(radius * 4.0 + angle * 2.0);\n    float wave2 = sin(radius * 8.0 + angle * 3.0 + time * 2.0);\n    float wave3 = sin(radius * 16.0 + angle * 5.0 + time * 3.0);\n    \n    // Combine waves and add turbulence\n    float intensity = (wave1 + wave2 + wave3) * 0.3;\n    intensity += turbulent(vec2(st.x, st.y) * 4.0 + time);\n    \n    // Create dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(time * 0.25),\n        0.7,\n        0.5 + intensity * 0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine color with turbulence for final effect\n    float noiseValue = noise(vec3(st.x, st.y, time)) * 0.5;\n    vec3 finalColor = mix(rgbColor, vec3(1.0), noiseValue);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_287.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float r = length(uv);\n    \n    // Create pulsing effect using time\n    float pulse = sin(iTime * 0.5 + r * 10.0) * 0.5;\n    \n    // Create circular pattern with pulsing radius\n    float circ = mod(r + pulse, 1.0);\n    \n    // Add turbulence for dynamic effect\n    vec2 st = uv * 8.0;\n    float turb = turbulent(st);\n    \n    // Mix colors using HSL to RGB conversion\n    vec3 color = hsl(circ * 0.5 + iTime*0.5, 1.0, circ * 0.5 + 0.5);\n    \n    // Add turbulence effect to color\n    color = mix(color, vec3(0), turb * 0.2);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_288.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + sin(iTime * 0.5) * 3.0;\n    \n    // Create rotating geometric patterns using sine waves\n    float pattern = sin(theta * 8.0 + iTime) * 0.5 + 0.5;\n    pattern += turbulent(vec2(r * 10.0, theta)) * 0.4;\n    \n    // Calculate color components with pulsating hues\n    vec3 color;\n    color.x = sin(theta * 4.0 + iTime * 2.0) * 0.5 + 0.5;\n    color.y = cos(r * 16.0 - iTime * 3.0) * 0.5 + 0.5;\n    color.z = pattern * (sin(iTime) * 0.5 + 0.5);\n    \n    // Convert to HSL and back to RGB for vibrant colors\n    vec3 hslColor = vec3(\n        mod(theta * 4.0 + iTime, 2.0),\n        1.0,\n        sin(r * 8.0 + iTime) * 0.5 + 0.5\n    );\n    \n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_289.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add time component\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create a base color using HSL\n    vec3 color = hsl(0.5, 1.0, 0.5);\n    \n    // Add dynamic noise and turbulence effects\n    float t = turbulent(st) * 0.5 + 0.5;\n    color = mix(color, hsv2rgb(vec3(turbulent(st * 2.0), 1.0, 1.0)), t);\n    \n    // Create a secondary color layer with different parameters\n    vec3 color2 = hsl(0.3, 1.0, 0.7);\n    float t2 = turbulent(st + 1.0) * 0.5 + 0.5;\n    color2 = mix(color2, hsv2rgb(vec3(turbulent(st * 2.0 + 1.0), 1.0, 1.0)), t2);\n    \n    // Combine the two colors with some blending\n    vec3 finalColor = mix(color, color2, 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_29.json": {
    "src": "\n//prompt: something awesome\nvec4 Effect2(vec2 uv) {\n    // Create rotating polar pattern\n    vec2 polar = uv * 2.0 - 1.0;\n    float radius = length(polar);\n    float angle = atan(polar.y, polar.x) + iTime * 0.5;\n    \n    // Generate three concentric rings with different frequencies\n    float a = sin(radius * 8.0 + angle * 2.0) * 0.5 + 0.5;\n    float b = sin(radius * 6.0 + angle * 3.0) * 0.5 + 0.5;\n    float c = sin(radius * 4.0 + angle * 4.0) * 0.5 + 0.5;\n    \n    // Create color from three layers\n    vec3 color = vec3(\n    a * 0.6 + b * 0.3,\n    b * 0.4 + c * 0.5,\n    a * 0.2 + c * 0.8\n    );\n    \n    // Add glow effect at edges\n    float glow = smoothstep(1.0, 0.9, radius);\n    color = mix(color, vec3(1.0), glow * 0.4);\n    \n    return vec4(clamp(color, 0.0, 1.0), 1.0);\n}\n"
  },
  "data_290.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset UV coordinates for grid pattern\n    vec2 st = uv * 5.0 + vec2(1.0);\n    \n    // Calculate hexagon center positions using sine and cosine patterns\n    vec2 pos = vec2(\n        sin(st.x * 0.5 + iTime) + cos(st.y * 0.5),\n        cos(st.x * 0.5 - iTime) + sin(st.y * 0.5)\n    );\n    \n    // Add turbulence for dynamic movement\n    float turb = turbulent(pos * 0.5 + vec2(iTime, 0.0)) * 0.5 + 0.5;\n    \n    // Calculate rotation angle based on time and position\n    float angle = sin(iTime * 3.0 + pos.x * 2.0) * 0.5;\n    vec2 rotatedPos = vec2(\n        cos(angle) * (pos.x - 0.5) - sin(angle) * (pos.y - 0.5),\n        sin(angle) * (pos.x - 0.5) + cos(angle) * (pos.y - 0.5)\n    ) + 0.5;\n    \n    // Create color variations using HSL to RGB conversion\n    vec3 color = hsl(\n        sin(iTime * 0.2 + rotatedPos.x * 2.0) * 0.5 + 0.5,\n        cos(iTime * 0.3 + rotatedPos.y * 2.0) * 0.5 + 0.5,\n        0.7\n    );\n    \n    // Combine turbulence with color for final output\n    return vec4(color * turb, 1.0);\n}"
  },
  "data_291.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base noise pattern with time variation\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Generate multi-scale noise patterns\n    float n1 = noise(st);\n    float n2 = noise(st * 0.5 + 3.0*iTime);\n    float n3 = noise(st * 0.25 - 2.0*iTime);\n    \n    // Create RGB color shifts using HSL conversion\n    vec3 colors;\n    colors.r = hsl(n1 * 0.4 + 0.6, 0.8, 0.5).r;\n    colors.g = hsl(n2 * 0.4 + 0.2, 0.7, 0.6).g;\n    colors.b = hsl(n3 * 0.4 + 0.8, 0.6, 0.7).b;\n    \n    // Mix colors with turbulence\n    float turb = turbulent(vec3(uv * 10.0, iTime));\n    vec3 finalColor = mix(colors.rbg, colors.gbr, turb);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_292.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation effects\n    float r = length(uv);\n    float a = atan2(uv.y, uv.x);\n    \n    // Add time-based rotation\n    a += iTime * 0.5;\n    \n    // Create pulsating edges using turbulence\n    float pulse = turbulent(vec3(r, a, iTime)) * 0.5 + 0.5;\n    \n    // Combine polar coordinates with noise for dynamic patterns\n    vec2 st = uv * 10.0; // Scale up for more detail\n    float pattern = noise(st) * 0.5 + 0.5;\n    \n    // Create color transitions based on angle and time\n    vec3 color = hsl(a * 0.1, 0.7, 0.6);\n    \n    // Add pulsating effect to colors\n    color *= pulse;\n    \n    // Mix in noise pattern for texture\n    color = mix(color, vec3(pattern), 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_293.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating nebula effect with layered sine waves\n    \n    // Coordinate system centered at (0,0)\n    vec2 st = uv * 10.0 - 5.0;\n    \n    // Time-based pulsation\n    float time = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Layered sine waves with noise\n    float wave1 = sin(st.x * 0.5 + iTime) * 0.3;\n    float wave2 = sin(st.y * 0.5 + iTime * 0.7) * 0.3;\n    float noise1 = turbulent(st * 0.5);\n    float noise2 = turbulent(st * 0.7 + 100.0);\n    \n    // Combine waves and noise\n    float pattern = wave1 + wave2 + noise1 * 0.2 + noise2 * 0.3;\n    \n    // Color transformation with time\n    vec3 color = hsl(\n        sin(iTime) * 0.5 + 0.5,   // Hue variation over time\n        0.7 + pattern * 0.3,      // Saturation modulation\n        0.5 + noise1 * 0.2       // Lightness modulation\n    );\n    \n    // Add rotation to create dynamic movement\n    float angle = iTime;\n    vec2 rotated = vec2(\n        st.x * cos(angle) - st.y * sin(angle),\n        st.x * sin(angle) + st.y * cos(angle)\n    );\n    \n    // Final color with pulsation effect\n    vec3 finalColor = hsl2rgb(vec3(\n        0.5 + pattern * 0.1,   // Base hue\n        0.7 + noise1 * 0.3,    // Saturation\n        0.3 + time * 0.7      // Pulsating lightness\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_294.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to create a grid of 8x8 tiles\n    vec2 st = uv * 8.0;\n    \n    // Get tile coordinates (integer part)\n    vec2 tile = floor(st);\n    \n    // Get position within the current tile (fractional part)\n    vec2 pos = fract(st);\n    \n    // Use noise to create random values for each tile\n    float noiseVal = noise(tile + 1.0); // Add 1 to avoid (0,0) which might be black\n    \n    // Create time-based color shifts using sine function\n    float hueShift = sin(iTime * 0.5 + noiseVal * 2.0) * 0.5 + 0.5;\n    \n    // Create a base color for the tile using HSL\n    vec3 baseColor = hsl(hueShift, 1.0, 0.5);\n    \n    // Add some variation to the tiles using turbulence\n    float turb = turbulent(tile + iTime * 0.2);\n    \n    // Mix colors based on position within the tile and noise value\n    vec3 finalColor = mix(baseColor, hsl(hueShift + 0.3, 1.0, 0.5), pos.x * pos.y * 4.0);\n    finalColor *= 1.0 + turb * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_295.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using sine waves with different frequencies\n    vec3 color = sin(vec3(\n        uv.x * 5.0 + iTime,\n        uv.y * 4.0 + iTime * 0.5,\n        1.0\n    )) * 0.5 + 0.5;\n    \n    // Add multiple sine layers for more complex transitions\n    color += sin(vec3(\n        uv.x * 2.0 + iTime * 2.0,\n        uv.y * 3.0 + iTime * 1.5,\n        1.0\n    )) * 0.3;\n    \n    // Add turbulent noise for extra detail and randomness\n    vec2 noiseUV = uv * 4.0 + vec2(iTime);\n    float turbulence = turbulent(noiseUV) * 0.3;\n    color += turbulence;\n    \n    // Create a pulsing effect using time-based modulation\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    color *= pulse;\n    \n    // Convert to HSL for better color control and mix with another sine layer\n    vec3 hslColor = hsl(\n        sin(uv.x * 2.0 + iTime) * 0.4 + 0.5,\n        sin(uv.y * 2.0 + iTime * 0.7) * 0.6 + 0.3,\n        0.8\n    );\n    \n    // Combine both color approaches with some blending\n    color = mix(color, hslColor, 0.4);\n    \n    // Add final noise layer for subtle texture\n    vec2 finalNoiseUV = uv * 10.0 + vec2(iTime * 0.3);\n    float finalTurbulence = turbulent(finalNoiseUV) * 0.1;\n    color += finalTurbulence;\n    \n    // Ensure colors stay within valid range and return as vec4\n    return vec4(clamp(color, 0.0, 1.0), 1.0);\n}"
  },
  "data_296.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv);\n    \n    // Create a moving tunnel effect by offsetting the angle with time\n    angle += iTime * 0.5;\n    \n    // Add perspective projection for depth effect\n    vec3 pos = vec3(\n        cos(angle) * radius,\n        sin(angle) * radius,\n        radius * 2.0 + iTime * 0.1\n    );\n    \n    // Add noise and turbulence to create organic patterns\n    float noiseVal = turbulent(pos);\n    float noise2D = turbulent(uv * 5.0 + vec2(iTime));\n    \n    // Create color transitions using HSL colors\n    vec3 colorA = hsl(0.6, 1.0, 0.5);   // Blue-ish base color\n    vec3 colorB = hsl(0.3, 1.0, 0.7);   // Greenish accent color\n    \n    // Mix colors based on noise values and create pulsating effect\n    vec3 finalColor = mix(\n        hsl2rgb(colorA),\n        hsl2rgb(colorB),\n        abs(noiseVal * 0.5 + 0.5)\n    );\n    \n    // Add pulsating glow effect\n    float brightness = sin(iTime) * 0.5 + 0.7;\n    finalColor *= brightness;\n    \n    // Create depth fog effect\n    float depthFog = smoothstep(1.0, 2.0, radius);\n    finalColor = mix(finalColor, vec3(0.0), depthFog);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_297.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create hexagonal grid coordinates\n    vec2 q = uv * 10.0; // Scale up for more cells\n    \n    // Offset every other row to create hexagonal tiling\n    vec2 offset = vec2(mod(q.y, 2.0), 0.0);\n    vec2 pos = abs(q - offset) + vec2(0.5);\n    \n    // Calculate hexagon center and distance from center\n    vec2 center = floor(pos) + vec2(0.5);\n    vec2 toCenter = pos - center;\n    float dist = length(toCenter);\n    \n    // Create pulsing effect using time and noise\n    float hue = iTime * 0.1 + noise(center.xy * 0.1) * 0.5;\n    hue += sin(iTime * 0.2 + pos.x * 0.3) * 0.3;\n    \n    // Convert to HSL color with pulsing hue\n    vec3 hslColor = vec3(hue, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add distance-based shading\n    float shade = smoothstep(0.4, 0.6, dist);\n    rgbColor *= mix(vec3(1.0), vec3(0.5), shade);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_298.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale coordinates\n    vec2 st = (uv - 0.5) * 12.0;\n    \n    // Add time-based rotation\n    float t = iTime * 0.3;\n    float ct = cos(t);\n    float stt = sin(t);\n    \n    // Rotate coordinates\n    vec2 rotated = vec2(\n        st.x * ct - st.y * stt,\n        st.x * stt + st.y * ct\n    );\n    \n    // Create sine wave pattern with time offset\n    float wave1 = sin(rotated.x + iTime) * 0.5;\n    float wave2 = sin(rotated.y + iTime * 0.7);\n    \n    // Combine waves and add noise\n    float value = (wave1 + wave2) * 0.5 + noise(vec3(st, iTime)) * 0.3;\n    \n    // Create pulsating color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(iTime * 0.5 + value * 2.0) * 0.5 + 0.5,\n        abs(sin(iTime * 0.3 + value)) * 0.7 + 0.3,\n        0.6 + noise(vec3(st, iTime)) * 0.1\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_299.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to -1.0 to 1.0 range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create dynamic sine wave patterns with time offset\n    float waveA = sin(st.x * 5.0 + iTime) * cos(st.y * 3.0 + iTime/2.0);\n    float waveB = sin(st.x * 4.0 - iTime) * cos(st.y * 6.0 - iTime/2.0);\n    \n    // Add noise to create organic variations\n    vec2 noiseSt = st * 5.0;\n    float noiseA = noise(noiseSt + vec2(iTime, 0.0)) * 0.5;\n    float noiseB = noise(noiseSt + vec2(-iTime, 0.0)) * 0.5;\n    \n    // Combine waves with noise\n    waveA += noiseA;\n    waveB += noiseB;\n    \n    // Create color transitions using HSL\n    vec3 colorA = hsl(0.5 + sin(iTime) * 0.4, 1.0, 0.5);\n    vec3 colorB = hsl(0.5 + cos(iTime) * 0.4, 1.0, 0.5);\n    \n    // Mix colors based on wave patterns\n    vec3 finalColor = mix(colorA, colorB, pow(abs(waveA), 2.0));\n    finalColor += mix(colorB, colorA, pow(abs(waveB), 2.0)) * 0.5;\n    \n    // Apply tonal adjustments\n    finalColor *= 1.0 - abs(st.x) * 0.5;\n    finalColor = clamp(finalColor, 0.0, 1.0);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_3.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float t = iTime * 0.2;\n    vec2 pos = uv * 3.0 - sin(t);\n    float waveX = sin(pos.x * 6.28 + t) * 0.5 + 0.5;\n    float waveY = cos(pos.y * 6.28 + t * 0.4) * 0.5 + 0.5;\n    float wave = waveX + waveY;\n    vec3 color = hsv2rgb(vec3(wave, 0.7, 0.5));\n    return vec4(color, 1.0);\n}"
  },
  "data_30.json": {
    "src": "\n//prompt: something wonderful\nvec4 Effect2(vec2 uv) {\n    // Create flowing patterns with time\n    vec2 flow = uv + 0.5 * sin(uv * 10.0 + iTime);\n    \n    // Generate colorful interference pattern\n    float patternX = sin(flow.x * 8.0 + iTime * 2.0);\n    float patternY = cos(flow.y * 6.0 - iTime * 3.0);\n    \n    // Combine patterns with radial gradient\n    vec2 center = uv - 0.5;\n    float radius = length(center) * 10.0;\n    \n    // Create vibrant color transitions\n    vec3 color = mix(\n    vec3(0.4, 0.6, 1.0), // Blue-cyan\n    vec3(1.0, 0.2, 0.8), // Magenta\n    sin(patternX + patternY + radius) * 0.5 + 0.5\n    );\n    \n    return vec4(color, step(0.95, abs(sin(iTime / 2.0))));\n}\n        "
  },
  "data_300.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of squares\n    vec2 pos = floor(uv * 10.0) / 10.0;\n    \n    // Calculate rotation based on time and position\n    float time = iTime * 2.5;\n    vec2 center = pos + 0.05;\n    vec2 offset = uv - center;\n    \n    // Apply rotation matrix\n    float angle = time + dot(pos, vec2(100.0));\n    vec2 rotatedOffset = vec2(\n        offset.x * cos(angle) - offset.y * sin(angle),\n        offset.x * sin(angle) + offset.y * cos(angle)\n    );\n    \n    // Check if inside the square\n    float maxDist = max(abs(rotatedOffset.x), abs(rotatedOffset.y));\n    bool inside = maxDist < 0.05;\n    \n    // Create dynamic color transitions using HSL\n    vec3 baseColor = hsl2rgb(vec3(0.5 + 0.5 * sin(time + pos.x * 100.0), 1.0, 0.8));\n    \n    // Add turbulence effect\n    float turb = turbulent(pos * 5.0 + time);\n    vec3 finalColor = baseColor * (1.0 + turb * 0.5);\n    \n    if (!inside) {\n        finalColor = vec3(0.0);\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_301.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 polar = uv * 2.0 - 1.0;\n    float radius = length(polar);\n    float angle = atan(polar.y, polar.x) + iTime * 0.5;\n    \n    // Create radial gradient with pulsing effect\n    float gradient = sin(radius * 8.0 + iTime) * 0.5 + 0.5;\n    vec3 color = hsl2rgb(vec3(\n        mod(angle * 0.1 + iTime, 1.0),  // Hue variation over time and angle\n        0.7 + sin(radius * 4.0) * 0.3,   // Saturation variation with radius\n        0.5 + gradient * 0.5           // Lightness variation with gradient\n    ));\n    \n    // Add pulsating border effect\n    float border = sin(angle * 2.0 + iTime * 2.0) * 0.1;\n    color += vec3(border);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_302.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * pi/6.0; // Add rotation\n    \n    // Create hexagonal pattern using polar coordinates\n    float angle = theta / (pi/3.0); // Hexagon has 6-fold symmetry\n    float d = abs(length(vec2(r, r - 1.0)));\n    \n    // Add turbulence for dynamic effect\n    vec3 noisePos = vec3(st.x + iTime * 0.5, st.y + iTime * 0.5, iTime);\n    float turb = turbulent(noisePos) * 0.2;\n    \n    // Create pulsating color effect\n    float hue = fract(iTime * 0.1 + sin(r * 3.0 + theta));\n    vec3 color = hsl(hue, 1.0, 0.5);\n    \n    // Mix colors based on distance from center and turbulence\n    vec3 finalColor = mix(color, vec3(1.0), smoothstep(0.8, 1.2, r + turb));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_303.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Create hexagonal pattern by multiplying angle by 6 (for six-fold symmetry)\n    angle *= 6.0;\n    \n    // Add time-based rotation\n    float timeRotation = iTime * 0.5;\n    angle += timeRotation;\n    \n    // Use turbulence to create varying rotation speeds based on position and time\n    vec3 noiseInput = vec3(uv * 10.0, iTime);\n    float speedVariation = turbulent(noiseInput) * 2.0 + 1.0;\n    angle *= speedVariation;\n    \n    // Create color variations using HSL to RGB conversion\n    vec3 hslColor = vec3(angle * 0.15, 0.7, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add some radial variation to the colors\n    rgbColor *= radius * 0.5 + 0.5;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_305.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Create orbiting points with expanding waves\n    float time = iTime * 0.5;\n    \n    // Point 1: rotating around center\n    vec2 p1 = vec2(\n        sin(time + angle) * 0.7,\n        cos(time + angle) * 0.7\n    );\n    float d1 = length(st - p1);\n    float wave1 = sin(d1 * 8.0 - time * 4.0) * 0.5;\n    \n    // Point 2: rotating in opposite direction\n    vec2 p2 = vec2(\n        cos(time + angle) * 0.7,\n        sin(-time + angle) * 0.7\n    );\n    float d2 = length(st - p2);\n    float wave2 = sin(d2 * 8.0 + time * 4.0) * 0.5;\n    \n    // Combine waves and add noise\n    float combinedWave = (wave1 + wave2) * 0.5;\n    combinedWave += turbulent(vec3(st, time)) * 0.3;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        angle * 0.5 + time,\n        0.7,\n        0.5 + combinedWave * 0.5\n    ));\n    \n    // Add distance falloff and blend points\n    float distFalloff = smoothstep(1.0, 0.0, radius);\n    color *= distFalloff;\n    \n    // Combine multiple points for richer effect\n    vec2 p3 = vec2(\n        sin(time + angle * 2.0) * 0.5,\n        cos(time + angle * 2.0) * 0.5\n    );\n    float d3 = length(st - p3);\n    float wave3 = sin(d3 * 12.0 - time * 6.0) * 0.3;\n    \n    vec3 color2 = hsl2rgb(vec3(\n        angle * 0.7 + time,\n        0.8,\n        0.5 + wave3 * 0.5\n    ));\n    \n    float distFalloff2 = smoothstep(1.0, 0.0, radius);\n    color2 *= distFalloff2;\n    \n    // Final color combination\n    vec3 finalColor = mix(color, color2, 0.4) * 1.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_306.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Create rotating pattern by adding time-based rotation\n    angle += iTime * 0.5;\n    \n    // Add pulsating effect using sine wave with increasing frequency\n    radius *= sin(iTime * 3.0 + angle) * 0.5 + 1.0;\n    \n    // Use noise to create dynamic color shifts\n    vec2 noiseUV = vec2(angle, radius);\n    float noiseValue = noise(noiseUV * 10.0);\n    \n    // Create RGB shift effect using HSL colors\n    vec3 hslColor = vec3(\n        fract(iTime * 0.5 + noiseValue) * 360.0,\n        0.7,\n        0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add pulsating intensity using turbulent noise\n    float intensity = turbulent(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    rgbColor *= intensity;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_307.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Create a grid of points with noise offset\n    vec2 st = uv * 10.0;\n    vec2 pos = floor(st + 0.5) + noise(vec2(floor(st))) * 0.5;\n    \n    // Animate position over time with sine wave pattern\n    float time = iTime * 0.5;\n    pos.y += sin(time + pos.x) * 0.3;\n    \n    // Calculate distance from current fragment to particle center\n    vec2 toParticle = pos - st;\n    float dist = length(toParticle);\n    \n    // Create glowing effect with turbulence\n    float glow = exp(-dist * 5.0) * (1.0 + turbulent(vec3(pos, time)) * 0.5);\n    \n    // Add color variation using HSL\n    vec3 hslColor = vec3(0.6 + sin(time + pos.x) * 0.2, 0.8, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    finalColor += glow * rgbColor;\n    \n    // Add some background color\n    finalColor += vec3(0.05);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_308.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create rotating sine wave pattern\n    a += iTime * 0.5;\n    float sa = sin(a + iTime) * 4.0;\n    \n    // Add noise and turbulence\n    vec3 noise1 = vec3(noise(vec3(uv * 2.0, iTime)), \n                       noise(vec3(uv * 3.0, iTime)),\n                       noise(vec3(uv * 4.0, iTime)));\n    float turb = turbulent(vec2(a, r)) * 0.5 + 0.5;\n    \n    // Create color transitions\n    vec3 color1 = hsl2rgb(vec3((sa + a) * 0.1, 0.7, 0.8));\n    vec3 color2 = hsl2rgb(vec3(iTime * 0.2, 0.6, 0.9));\n    \n    // Combine patterns and colors\n    float blend = sin(r * 5.0 + iTime) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, blend);\n    finalColor *= turb;\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_309.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 0.5 + 0.5;\n    // Create rotating color wheel effect\n    theta += iTime * 0.5; // Rotate over time\n    \n    // Use HSL colors for smooth transitions\n    vec3 hslColor;\n    hslColor.x = (theta / (2.0 * PI) + 0.5) * 0.6; // Hue based on angle\n    hslColor.y = 1.0; // Full saturation\n    \n    // Add noise and turbulence for dynamic variations\n    float noiseValue = turbulent(vec3(r, iTime, 0.0)) * 0.2;\n    hslColor.z = r + noiseValue; // Brightness varies with radius and noise\n    \n    // Convert HSL to RGB\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add smooth transitions using another layer of noise\n    float transitionNoise = abs(noise(vec2(r * 10.0, iTime))) * 0.5;\n    rgbColor += transitionNoise;\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_31.json": {
    "src": "\n//prompt: a fractal\nvec4 Effect2(vec2 uv) {\n    const float max_iter = 100.0;\n    \n    // Initialize complex number z and constant c\n    vec2 z = (2.0 * uv - 1.0);\n    vec2 c = vec2(-0.4, 0.6); // Julia set constant\n    \n    float iter = 0.0;\n    while(iter < max_iter) {\n    // Complex multiplication and addition: z^2 + c\n    z = vec2(z.x*z.x - z.y*z.y, 2.0 * z.x*z.y) + c;\n    \n    if(length(z) > 2.0) break;\n    iter += 1.0;\n    }\n    \n    // Color based on iteration count\n    float t = iter / max_iter;\n    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_310.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Add time-based movement and scale coordinates\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create flowing sine wave pattern with dynamic frequency\n    float wave1 = sin(st.x * 0.5 + iTime * 2.0);\n    float wave2 = sin(st.y * 0.7 - iTime * 3.0);\n    \n    // Add noise for organic texture\n    vec2 noisePos = st * 0.5;\n    float noiseVal = noise(noisePos) * 0.5 + 0.5;\n    \n    // Combine waves and noise with turbulence\n    float pattern = (wave1 + wave2) * 0.5 + noiseVal * turbulent(st);\n    \n    // Create dynamic color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.1 + st.x * 0.2),   // Hue variation over time and space\n        0.7,                                // Saturation\n        0.5 + pattern * 0.4                // Brightness modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_311.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create rotating geometric patterns using sine functions\n    float pattern1 = sin(theta * 3.0 + iTime * 2.0); // Frequency 3\n    float pattern2 = sin(theta * 5.0 - iTime * 1.5); // Frequency 5\n    float pattern3 = sin(theta * 7.0 + iTime * 2.0); // Frequency 7\n    \n    // Combine patterns with different weights\n    float combined = (pattern1 * 0.4) + (pattern2 * 0.3) + (pattern3 * 0.2);\n    \n    // Create a shape based on the combined pattern\n    float shape = smoothstep(0.5, 1.0, r + combined * 0.5);\n    \n    // Generate color using HSL to RGB conversion with time-based hue shift\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.5) * 0.5 + 0.5, // Hue variation\n        1.0, // Saturation\n        0.5 // Lightness\n    ));\n    \n    // Add noise and turbulence for more dynamic effect\n    float noiseValue = noise(vec3(uv * 10.0, iTime)) * 0.2;\n    color *= mix(1.0, 1.0 + noiseValue, turbulent(vec3(uv, iTime)) * 0.5);\n    \n    // Blend colors based on distance from center\n    vec3 finalColor = mix(color, vec3(1.0), shape);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_312.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and rotate coordinates\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create rotating sine wave pattern\n    float sinX = sin(st.x + iTime * 2.0);\n    float sinY = sin(st.y + iTime * 3.0);\n    float pattern = (sinX + sinY) * 0.5;\n    \n    // Add turbulence for dynamic effect\n    vec2 noiseUV = uv * 100.0;\n    float turb = turbulent(noiseUV);\n    pattern += turb * 0.3;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + st.x * 0.2),\n        0.7,\n        0.5 + abs(pattern) * 0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Output the final color\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_313.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating coordinate system\n    float time = iTime * 0.5;\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add rotation based on time\n    mat2 rot = mat2(cos(time), sin(time), \n                    -sin(time), cos(time));\n    vec2 rotatedUV = rot * st;\n    \n    // Create layered sine waves with different frequencies\n    float wave1 = sin(rotatedUV.x * 4.0 + time) * 0.5;\n    float wave2 = sin(rotatedUV.y * 6.0 + time * 0.7) * 0.3;\n    float wave3 = sin((rotatedUV.x + rotatedUV.y) * 8.0 + time * 1.2) * 0.2;\n    \n    // Combine waves and add noise\n    float combinedWaves = wave1 + wave2 + wave3;\n    combinedWaves += noise(vec2(time, rotatedUV.x)) * 0.1;\n    combinedWaves += noise(vec2(rotatedUV.y, time)) * 0.15;\n    \n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        fract(time * 0.2 + combinedWaves) * 360.0,\n        0.7 + abs(sin(time * 0.5)) * 0.3,\n        0.5 + combinedWaves * 0.2\n    );\n    \n    // Convert to RGB and add turbulence\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= turbulent(vec3(rotatedUV, time)) * 0.5 + 0.5;\n    \n    // Final color with geometric transformations\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(sin(time + rotatedUV.x) * 0.5 + 0.5),\n        abs(wave1)\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_314.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create swirly pattern by manipulating UV coordinates\n    vec2 center = vec2(0.5, 0.5);\n    vec2 pos = uv - center;\n    float radius = length(pos);\n    float angle = atan2(pos.y, pos.x) + iTime * 1.5;\n    \n    // Add turbulence for dynamic patterns\n    float turb = turbulent(vec3(uv * 4.0, iTime * 0.5)) * 0.5 + 0.5;\n    radius *= 1.0 + turb * 0.2;\n    \n    // Create vibrant color gradients using HSL\n    vec3 color = hsl2rgb(vec3(\n        (angle * 0.5 + iTime) * 0.1,\n        0.7 + sin(iTime * 0.5) * 0.3,\n        0.8 + turb * 0.2\n    ));\n    \n    // Add sine wave motion and RGB shifts\n    float timeFactor = sin(iTime * 2.0 * pi);\n    color.r += sin(angle * 2.0 + timeFactor * 2.0) * 0.3;\n    color.g += sin(angle * 3.0 + timeFactor * 1.5) * 0.3;\n    color.b += sin(angle * 4.0 + timeFactor * 1.0) * 0.3;\n    \n    // Combine everything for final output\n    return vec4(color, 1.0);\n}"
  },
  "data_315.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create a lattice of hexagons using polar coordinates\n    float x = sin(theta) + turbulent(vec3(r, theta, iTime)) * 0.5;\n    float y = cos(theta - pi/6.0) + turbulent(vec3(r, theta, iTime + 1.0)) * 0.5;\n    // Calculate distance from center and time-based color shift\n    float dist = length(vec2(x, y));\n    float timeShift = (iTime + dist) / 20.0;\n    \n    // Create gradient fill using HSL colors\n    vec3 color = hsl(\n        sin(timeShift * pi * 2.0) * 0.5 + 0.5,\n        1.0,\n        sin(r * 4.0 - iTime) * 0.5 + 0.5\n    );\n    // Add rotation and turbulence effects\n    color = hsl(\n        timeShift * pi * 2.0 + theta / 6.0,\n        1.0,\n        (sin(r * 4.0 - iTime) * 0.5 + 0.5) + sin(theta) * 0.2\n    );\n    return vec4(color, 1.0);\n}"
  },
  "data_316.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create square wave patterns\n    vec2 st = uv * 8.0 - 4.0;\n    st.x = sign(sin(st.x + time)) * 0.5 + 0.5;\n    st.y = sign(sin(st.y * 2.0 - time)) * 0.5 + 0.5;\n    \n    // Add movement\n    vec2 pos = uv * 4.0 + vec2(time, 0.0);\n    float wave = sin(pos.x) + cos(pos.y);\n    \n    // Combine patterns with turbulence\n    float pattern = (st.x + st.y) * 0.5;\n    pattern += turbulent(uv * 16.0 + time) * 0.3;\n    \n    // HSV color transformation\n    vec3 hsvColor = vec3(pattern * 2.0, 0.7, 0.5);\n    vec3 rgbColor = hsv2rgb(hsvColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_317.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv * 1.5); // Scale UV for better ring spacing\n    \n    // Add time-based rotation and pulsing\n    angle += iTime * 0.2;\n    radius += sin(iTime) * 0.3;\n    \n    // Create orbiting rings pattern using sine function with increasing frequency\n    float pattern = sin(radius + angle * 5.0);\n    pattern = abs(pattern); // Make it symmetric\n    \n    // Add chromatic aberration by offsetting colors differently\n    vec3 color;\n    color.r = pattern * (1.0 + sin(iTime + angle * 2.0));\n    color.g = pattern * (1.0 + cos(iTime + angle * 2.0 + PI/3.0));\n    color.b = pattern * (1.0 + sin(iTime + angle * 2.0 + PI*2.0/3.0));\n    \n    // Add pulsating color evolution using HSL\n    vec3 hslColor = vec3(\n        mod(angle * 5.0 + iTime, 2.0) / 2.0, // Hue variation\n        1.0, // Saturation\n        0.5 + 0.5 * sin(iTime + radius * 2.0) // Pulsing lightness\n    );\n    color = hsl2rgb(hslColor);\n    \n    // Add turbulence for extra texture\n    vec3 noisePattern = vec3(turbulent(uv * 10.0 + iTime));\n    color *= 1.0 + noisePattern * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_318.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing liquid effect using noise functions\n    \n    // Add time-based animation\n    float t = iTime * 0.5;\n    \n    // Scale UV coordinates for better noise pattern\n    vec2 st = uv * 3.0 + t;\n    \n    // Layered noise with different scales and speeds\n    float n1 = noise(st);\n    float n2 = noise(st * 0.7 + t * 0.5);\n    float n3 = turbulent(vec3(st, t));\n    \n    // Combine noise layers\n    float liquid = (n1 + n2 + n3) * 0.3;\n    \n    // Add color transformation using HSL to HSV conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(liquid * 5.0 + t, 1.0),   // Hue variation\n        0.7 + liquid * 0.3,          // Saturation\n        0.5 + liquid * 0.5           // Brightness\n    ));\n    \n    // Add turbulence for more detail\n    vec2 uvTurb = uv + turbulent(uv * 10.0) * 0.1;\n    float turb = turbulent(vec3(uvTurb, t)) * 0.3;\n    \n    // Final color with alpha\n    return vec4(color + turb, 1.0);\n}"
  },
  "data_319.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates around center with time-based rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = iTime * 0.5;\n    mat2 rot = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 rotatedUV = rot * st;\n    // Add noise and turbulence\n    float noiseValue = turbulent(rotatedUV * 4.0 + iTime) * 0.5 + 0.5;\n    float pattern = sin(length(rotatedUV) * 8.0 + iTime) * 0.5 + 0.5;\n    // Create geometric patterns with rotating colors\n    vec3 color = hsl(\n        mod(iTime * 0.2 + noiseValue * 2.0, 1.0),  // Hue variation over time and noise\n        0.7 + pattern * 0.3,                       // Saturation modulation\n        0.5 + sin(length(rotatedUV) * 4.0 + iTime) * 0.5  // Brightness variation\n    );\n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_32.json": {
    "src": "\n//prompt: a fractal\nvec4 Effect2(vec2 uv) {\n    // Mandelbrot fractal\n    const float maxIterations = 20.0;\n    vec2 c = (uv - 0.5) * 3.0; // Scale and center the coordinates\n    vec2 z = vec2(0.0);\n    \n    float iterations = 0.0;\n    while (iterations < maxIterations && length(z) <= 2.0) {\n    vec2 nextZ = vec2(\n    z.x*z.x - z.y*z.y + c.x,\n    2.0*z.x*z.y + c.y\n    );\n    z = nextZ;\n    iterations++;\n    }\n    \n    // Color based on iteration count\n    float colorVal = length(z) > 2.0 ? iterations / maxIterations : 0.0;\n    \n    vec3 color = vec3(\n    sin(colorVal * 3.0 + 1.0),\n    sin(colorVal * 5.0 + 2.0),\n    sin(colorVal * 7.0 + 3.0)\n    );\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_320.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequency with time component\n    float base_time = 0.5 * iTime;\n    \n    // Calculate color channels with different phase shifts\n    vec3 color = vec3(\n        sin(base_time + uv.x * 10.0 + uv.y * 5.0),\n        sin(base_time + 2.0 + uv.x * 8.0 + uv.y * 6.0),\n        sin(base_time + 4.0 + uv.x * 7.0 + uv.y * 9.0)\n    );\n    \n    // Add noise to create more dynamic effect\n    float noise_val = noise(vec2(uv.x * 5.0, uv.y * 5.0) + base_time);\n    color += vec3(noise_val * 0.1);\n    \n    // Scale and offset to get values between 0-1\n    color = (color * 0.5) + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_321.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Mouse position (assuming normalized coordinates from 0 to 1)\n    vec2 mouse = vec2(0.5, 0.5); // Replace with actual mouse input\n    \n    // Time-based animation\n    float time = iTime * 0.5;\n    \n    // Layered sine waves for plasma effect\n    vec3 color = vec3(0.0);\n    float freq = 1.0;\n    for(int i=0; i<4; i++) {\n        freq *= 2.0;\n        color += sin(uv.x * freq + time) * \n                 sin(uv.y * freq + time) *\n                 vec3(0.5, 0.7, 1.0);\n    }\n    \n    // Add noise and turbulence\n    vec2 st = uv * 8.0;\n    float turb = turbulent(st + time);\n    color += vec3(turb) * 0.5;\n    \n    // Mouse interaction\n    vec2 mouseDir = uv - mouse;\n    float dist = length(mouseDir);\n    color *= sin(dist * 4.0 + time) * 0.5 + 0.5;\n    \n    // Color shift over time\n    vec3 hsvColor = vec3(\n        mod(time * 0.1, 1.0), \n        0.7,\n        length(color) * 0.5 + 0.5\n    );\n    color = hsv2rgb(hsvColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_322.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add rotation based on time\n    theta += 0.5 * iTime;\n    // Create spiral pattern using turbulence\n    float spiral = turbulent(vec3(r * 5.0 + theta, r * 3.0 - theta, 0.0)) * 0.5 + 0.5;\n    \n    // Color based on angle and radius\n    vec3 color = hsl2rgb(vec3(\n        (theta * 0.15 + iTime * 0.1) * 360.0,\n        0.7 + spiral * 0.3,\n        0.5 + sin(r * 4.0 - iTime) * 0.2\n    ));\n    // Create circular mask for galaxy shape\n    float mask = smoothstep(1.0, 0.98, r);\n    return vec4(color * mask, 1.0);\n}"
  },
  "data_323.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating pattern using sine functions\n    vec2 st = uv * 10.0;\n    st.x += sin(time + st.y * 2.0) * 0.5;\n    st.y += cos(time + st.x * 2.0) * 0.5;\n    \n    // Add turbulence for plasma effect\n    float turb = turbulent(st);\n    \n    // Dynamic color shifts using HSL\n    vec3 color = hsl(\n        0.5 + sin(time * 0.5) / 4.0,   // Hue variation over time\n        0.8,                            // Saturation\n        0.5 + turb * 0.5               // Lightness modulation\n    );\n    \n    // Add another layer of turbulence for more detail\n    color += hsl2rgb(vec3(\n        0.7,\n        0.6,\n        0.4 + turbulent(st * 5.0) * 0.6\n    )) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_324.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base noise pattern with time offset\n    float noiseValue = noise(uv * 5.0 + vec2(iTime, iTime));\n    \n    // Generate dynamic color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1, 1.0),  // Hue that changes over time\n        0.7,                    // Saturation\n        0.5 + noiseValue * 0.4  // Lightness with noise variation\n    ));\n    \n    // Add turbulence for more dynamic movement\n    float turb = turbulent(uv * 3.0 + vec2(iTime));\n    \n    // Combine noise and turbulence effects\n    color *= mix(1.0, 0.5, abs(turb) * 0.5 + 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_325.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Flowing gradient base pattern with time-based transformation\n    vec2 st = uv * 10.0 + vec2(sin(iTime), cos(iTime)) * 5.0;\n    \n    // Cellular noise pattern with time offset\n    float n = noise(st * 0.5 + vec2(0.0, iTime * 0.5));\n    n += noise(st * 0.25 + vec2(iTime, 0.0)) * 0.5;\n    \n    // Color transformation using HSL for vibrant colors\n    vec3 color = hsl(\n        sin(n * 180.0 + iTime) * 180.0,\n        1.0,\n        0.5 + turbulent(uv * 2.0 + iTime) * 0.5\n    );\n    \n    // Add flowing gradient effect\n    vec3 gradient = mix(\n        hsl2rgb(vec3(60.0, 1.0, 0.5)),\n        hsl2rgb(vec3(240.0, 1.0, 0.5)),\n        uv.y\n    );\n    \n    // Combine patterns with time-based modulation\n    color = mix(color, gradient, sin(iTime) * 0.5 + 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_326.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for a grid effect\n    vec2 st = uv * 10.0;\n    \n    // Get integer grid position\n    vec2 pos = floor(st);\n    \n    // Calculate time-based pulsing factor\n    float t = iTime * 0.5;\n    \n    // Add noise to create organic movement\n    float noiseVal = noise(pos + t) * 0.5 + 0.5;\n    \n    // Create pulsing effect using sine wave and noise\n    float pulse = sin(t + pos.x + pos.y) * noiseVal;\n    \n    // Calculate color based on position and time\n    vec3 baseColor = hsl2rgb(vec3(pos.x * 0.1, pos.y * 0.1, 0.5));\n    \n    // Add pulsing effect to color\n    vec3 finalColor = baseColor * (0.5 + 0.5 * sin(t + pulse));\n    \n    // Add turbulence for extra detail\n    float turb = turbulent(vec2(st) + t);\n    finalColor *= 1.0 + turb * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_327.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise pattern with time variation\n    float noise1 = turbulent(uv * 5.0 + iTime);\n    float noise2 = turbulent(uv * 3.0 + iTime * 0.5);\n    \n    // Generate color components using HSL colors\n    vec3 color1 = hsl(noise1 * 0.6 + 0.4, 0.8, 0.5);\n    vec3 color2 = hsl((noise2 * 0.6 + 0.4) + iTime * 0.1, 0.7, 0.6);\n    \n    // Combine colors with time-based blending\n    vec3 finalColor = mix(color1, color2, sin(iTime * 0.5) * 0.5 + 0.5);\n    \n    // Add pulsating glow effect using alpha channel\n    float glow = turbulent(uv * 2.0 + iTime) + length(uv) * 0.5;\n    finalColor *= clamp(glow, 0.0, 1.0);\n    \n    return vec4(finalColor, clamp(glow * 0.5 + 0.5, 0.0, 1.0));\n}"
  },
  "data_328.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv - 0.5;\n    float d = length(st);\n    \n    // Create circular pattern with time-based animation\n    float f = sin(iTime * 0.5 + d * 10.0) * cos(iTime * 0.7 + d * 5.0);\n    \n    // Add noise and turbulence for more complex patterns\n    vec2 noiseScale = st * 50.0;\n    float turb = turbulent(noiseScale);\n    \n    // Mix colors with smooth transitions\n    vec3 color1 = hsl2rgb(vec3(0.5 + sin(iTime) * 0.4, 0.7, 0.6));\n    vec3 color2 = hsl2rgb(vec3(0.2 + cos(iTime) * 0.4, 0.8, 0.5));\n    \n    // Combine patterns and colors\n    float mixVal = smoothstep(0.3, 0.7, d);\n    vec3 finalColor = mix(color1, color2, mixVal);\n    \n    // Add turbulence effect\n    finalColor *= 1.0 + turb * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_329.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create orbiting effect using time and rotation\n    a += sin(iTime * 0.5 + a) * 0.5;\n    r += cos(iTime + a * 3.0) * 0.1;\n    // Add noise for texture\n    vec2 noisePos = vec2(r, a);\n    float n = noise(noisePos * 0.5 + iTime);\n    // Create color transitions using HSL\n    vec3 color;\n    color.x = fract(iTime * 0.2 + r * 0.5) * 0.7 + 0.3; // Hue\n    color.y = 1.0; // Saturation\n    color.z = abs(n * 0.5 + 0.5); // Lightness\n    // Convert HSL to RGB and add noise effect\n    vec3 rgbColor = hsl2rgb(color);\n    rgbColor *= (1.0 - n * 0.5);\n    // Create geometric pattern based on radius\n    float shape = sin(r * 8.0 + iTime) * 0.5 + 0.5;\n    rgbColor *= mix(0.3, 1.0, shape);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_33.json": {
    "src": "\n//prompt: a wavy grid\n\nvec4 Effect2(vec2 uv) {\n    // Apply some distortion to the coordinates\n    vec2 distortedUV = uv + 0.5 * sin(uv * 10.0 + iTime);\n    \n    // Create grid lines with warping effect\n    float horizontal = abs(sin(distortedUV.y * 10.0));\n    float vertical = abs(sin(distortedUV.x * 10.0));\n    \n    // Combine and color the grid\n    vec3 color = mix(\n        vec3(0.2, 0.5, 1.0), // Blue-ish for horizontal lines\n        vec3(1.0, 0.3, 0.3), // Red-ish for vertical lines\n        step(0.9, horizontal + vertical)\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_330.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Calculate radius and angle\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create moving pattern using time\n    float time = iTime * 0.5;\n    \n    // Add noise and turbulence\n    float noiseVal = turbulent(vec3(r + time, theta, 0.0));\n    \n    // Color based on angle with RGB shifts\n    vec3 color = hsl2rgb(vec3(theta * 180.0 / PI + noiseVal * 50.0, 0.7, 0.6));\n    \n    // Create concentric circles effect\n    float circle = sin(r * 10.0 + time) * 0.5 + 0.5;\n    \n    // Combine effects\n    color *= circle;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_331.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale for better pattern visibility\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Time-based rotation angle\n    float time = iTime * 0.5;\n    mat2 rot = mat2(cos(time), sin(time), \n                    -sin(time), cos(time));\n                    \n    // Apply rotation and scale\n    vec2 transformed = st * rot * 1.5;\n    \n    // Create wave patterns with sine functions\n    float patternX = abs(sin(transformed.x * 0.7 + time)) - 0.5;\n    float patternY = abs(sin(transformed.y * 0.7 + time)) - 0.5;\n    \n    // Combine patterns and create geometric shapes\n    vec2 shape = vec2(patternX, patternY);\n    float distance = length(shape);\n    \n    // Add movement with another frequency\n    transformed += sin(time * 0.3) * 0.5;\n    float pattern2 = abs(sin(length(transformed) * 4.0 + time)) - 0.5;\n    \n    // Combine both patterns for complex shapes\n    float finalPattern = distance + pattern2 * 0.7;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(finalPattern * 0.6 + 0.5, \n                     1.0 - abs(finalPattern), \n                     0.5);\n                     \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_332.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates and convert to polar\n    vec2 centered = uv - 0.5;\n    float r = length(centered);\n    float theta = atan2(centered.y, centered.x) + iTime * 0.5; // Rotate over time\n    \n    // Create color wheel effect with pulsing\n    float hue = theta / (2.0 * PI) + sin(iTime * 0.7) * 0.3;\n    float saturation = r * 0.8 + 0.2;\n    float lightness = 0.5 + turbulent(vec2(r, iTime * 0.1)) * 0.3;\n    \n    // Add pulsing effect to radius\n    float pulse = sin(iTime) * 0.3;\n    r = min(1.0, r + pulse);\n    \n    // Create radial gradient with noise\n    vec3 color = hsl2rgb(vec3(hue, saturation, lightness));\n    color *= 1.0 - r * 0.7; // Darken towards edges\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_333.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float angle = sin(iTime * 0.5 + pi) * 0.5 + 0.5;\n    vec2 q = uv - 0.5;\n    q = vec2(q.x * cos(angle) - q.y * sin(angle),\n             q.x * sin(angle) + q.y * cos(angle)) + 0.5;\n    // Create sine wave patterns at different scales\n    float wave1 = sin(q.x * 20.0 + iTime) * 0.5 + 0.5;\n    float wave2 = cos(q.y * 20.0 + iTime * 0.5) * 0.5 + 0.5;\n    float wave3 = sin((q.x + q.y) * 15.0 + iTime * 0.7);\n    \n    // Combine waves with noise and turbulence\n    float pattern = (wave1 + wave2 + wave3) / 3.0;\n    pattern += noise(q * 4.0 + iTime) * 0.3;\n    pattern += turbulent(q * 8.0 + iTime) * 0.2;\n    // Convert to HSL color space\n    vec3 hslColor = vec3(\n        fract(iTime / 3.0 + pattern * 0.5),  // Hue\n        0.8,                                  // Saturation\n        mix(0.4, 0.7, sin(pattern * pi) * 0.5 + 0.5)  // Lightness\n    );\n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_334.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form centered at middle of screen\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float a = atan(pos.y, pos.x) + iTime; // Add time for rotation\n    \n    // Create swirling effect by modifying angle and radius\n    a += sin(r * 5.0 + iTime) * 0.5;\n    \n    // Create pulsating rings using radius and time\n    float ring = sin(r * 10.0 + iTime * 2.0);\n    ring = (ring + 1.0) * 0.5; // Scale to 0-1 range\n    \n    // Create color transitions using HSL colors\n    vec3 baseColor = hsl(a * 0.5, 0.7, 0.6);\n    vec3 secondaryColor = hsl((a + PI) * 0.5, 0.7, 0.4);\n    \n    // Combine colors with pulsating rings\n    vec3 color = mix(baseColor, secondaryColor, ring);\n    \n    // Add noise for extra texture\n    float noiseValue = noise(vec2(a * 0.1, r * 0.1)) * 0.2;\n    color += noiseValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_335.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Node grid spacing and size\n    const float nodeSize = 0.1;\n    const float glowIntensity = 1.5;\n    \n    // Get mouse position from texture coordinates\n    vec2 mouse_pos = uv * 2.0 - 1.0; // Convert to [-1,1] range\n    \n    // Calculate nearest grid points\n    vec2 ipos = floor(uv * 10.0);\n    vec2 pos = (ipos + noise(ipos)) / 10.0;\n    \n    // Node color and pulsing\n    float distance_to_mouse = length(uv - mouse_pos);\n    float node_falloff = 1.0 / (distance_to_mouse + 1.0);\n    float pulse = sin(iTime * 2.0 + pos.x * 5.0) * 0.5 + 0.5;\n    \n    // Node glow effect\n    vec3 hsl_color = vec3(\n        fract(pos.x * 5.0 + iTime * 0.5),\n        0.8,\n        pulse * node_falloff * 0.6 + 0.4\n    );\n    vec3 rgb_color = hsl2rgb(hsl_color);\n    \n    // Draw lines between nodes\n    float lineIntensity = 0.0;\n    \n    // Right neighbor connection\n    vec2 pos_right = (ipos + vec2(1.0, 0.0) + noise(ipos + vec2(1.0, 0.0))) / 10.0;\n    vec2 line_right = mix(pos, pos_right, 0.5);\n    float dist_right = length(uv - line_right) * 3.0;\n    \n    // Up neighbor connection\n    vec2 pos_up = (ipos + vec2(0.0, 1.0) + noise(ipos + vec2(0.0, 1.0))) / 10.0;\n    vec2 line_up = mix(pos, pos_up, 0.5);\n    float dist_up = length(uv - line_up) * 3.0;\n    \n    // Combine line effects\n    lineIntensity += smoothstep(1.0, 0.0, dist_right) * 0.8;\n    lineIntensity += smoothstep(1.0, 0.0, dist_up) * 0.8;\n    \n    // Final color combination\n    vec3 final_color = rgb_color * (node_falloff * glowIntensity + lineIntensity);\n    \n    return vec4(final_color, 1.0);\n}"
  },
  "data_336.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create rotating circular patterns using polar coordinates\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x) + iTime * 0.5;\n    \n    // Add noise and turbulence to create dynamic shapes\n    float pattern1 = sin(theta + iTime) * r;\n    float pattern2 = turbulent(vec3(uv * 4.0, iTime)) * 0.5 + 0.5;\n    \n    // Create gradient overlays using HSL colors\n    vec3 color1 = hsl(r * 0.7 + iTime * 0.2, 0.8, 0.6);\n    vec3 color2 = hsl(theta * 0.4 + iTime * 0.3, 0.7, 0.5);\n    \n    // Combine patterns and colors\n    float blend = min(pattern1, pattern2);\n    color = mix(color1, color2, blend);\n    \n    // Add noise overlay for extra detail\n    color *= hsl2rgb(vec3(noise(uv * 8.0 + iTime) * 0.5 + 0.5, 1.0, 1.0));\n    \n    // Brightness and contrast adjustments\n    color = (color - 0.5) * 1.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_337.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a time-based wave pattern\n    float time = iTime * 0.5;\n    float wave1 = sin(st.x * 10.0 + time) * 0.5;\n    float wave2 = cos(st.y * 10.0 - time) * 0.3;\n    \n    // Combine waves with turbulence\n    float noiseValue = turbulent(vec2(st.x * 5.0, st.y * 5.0)) * 0.5 + 0.5;\n    float pattern = wave1 + wave2 + noiseValue;\n    \n    // Create RGB shifts using HSL colors\n    vec3 color = hsl(\n        mod((st.x * 0.5 + time/2.0), 1.0),\n        0.7,\n        0.6\n    );\n    \n    // Convert to RGB and mix with pattern\n    vec3 rgbColor = hsl2rgb(color);\n    float finalPattern = (sin(pattern * 4.0) + 1.0) * 0.5;\n    \n    // Combine everything for the final effect\n    vec3 finalColor = rgbColor * finalPattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_338.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a time-varying sine wave pattern\n    float waveX = sin(st.x * 5.0 + iTime) * 0.5 + 0.5;\n    float waveY = sin(st.y * 5.0 + iTime * 0.5) * 0.5 + 0.5;\n    \n    // Combine waves and add noise\n    float value = (waveX + waveY) * 0.5;\n    value += noise(st * 10.0 + vec2(iTime)) * 0.3;\n    \n    // Create shifting RGB colors using HSL conversion\n    vec3 color = hsl(value * 360.0, 1.0, 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_339.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave patterns with time offset\n    float time = iTime * 0.5;\n    \n    // Create x and y based sine waves with different frequencies\n    float waveX = sin(uv.x * 8.0 + time) * 0.5 + 0.5;\n    float waveY = sin(uv.y * 4.0 - time) * 0.5 + 0.5;\n    \n    // Mix waves and add noise for turbulence\n    vec2 mixUV = uv + vec2(waveX, waveY) * 0.3;\n    float noiseVal = noise(mixUV * 10.0);\n    \n    // Create color transitions using HSL\n    vec3 colorA = hsl(0.5 + noiseVal * 0.4, 0.8, 0.6);\n    vec3 colorB = hsl(0.2 + noiseVal * 0.4, 0.7, 0.8);\n    \n    // Combine colors with turbulence\n    float blend = turbulent(vec2(uv.x * 2.0 + time, uv.y)) * 0.5 + 0.5;\n    vec3 finalColor = mix(colorA, colorB, blend);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_34.json": {
    "src": "\n//prompt: a spiral\nvec4 Effect2(vec2 uv) {\n    // Center the coordinates and scale to [-1, 1] range\n    vec2 centeredUV = uv * 2.0 - 1.0;\n    \n    // Calculate polar coordinates\n    float r = length(centeredUV);\n    float theta = atan(centeredUV.y, centeredUV.x);\n    \n    // Spiral equation: r = a + b*theta\n    float a = 0.5;\n    float b = 0.2;\n    float spiralR = a + b * (theta + iTime); // Add time for animation\n    \n    // Create pattern based on distance from spiral\n    float pattern = abs(sin(r * 5.0 - theta * 3.0));\n    \n    // Color the spiral\n    vec3 color = mix(\n    vec3(1.0, 0.2, 0.3), // Pink for one side of the spiral\n    vec3(0.2, 0.8, 1.0), // Blue for the other side\n    step(0.5, pattern)\n    );\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_340.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base pattern using noise\n    float time = iTime * 0.5; // Scale time for slower animation\n    \n    // Combine UV coordinates with time to create movement\n    vec2 st = uv * 10.0 + vec2(time, time); // Scale and offset coordinates\n    \n    // Use noise functions to create a flowing pattern\n    float n1 = noise(st);\n    float n2 = noise(vec3(st.x, st.y, time)); // Add time as third dimension\n    \n    // Mix the two noise values with some scaling\n    float mixVal = (n1 + n2 * 0.5) * 0.5 + 0.5; // Scale to 0-1 range\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mixVal * 360.0, // Hue varies with noise\n        0.7,            // Saturation\n        0.5             // Lightness\n    ));\n    \n    // Add turbulence for more dynamic patterns\n    float turb = turbulent(st) + turbulent(vec2(time)) * 0.5;\n    color *= 1.0 + turb * 0.3; // Scale and add to color\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_341.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying frequency\n    float t = iTime * 0.5;\n    \n    // Generate horizontal and vertical patterns with phase shifts\n    vec3 lines = vec3(\n        sin(uv.x * 8.0 + t) + 0.5,\n        cos(uv.y * 8.0 - t) + 0.5,\n        sin(uv.x * 4.0 + uv.y * 4.0 + t*2.0)\n    );\n    \n    // Add diagonal patterns with varying frequencies\n    lines += vec3(\n        sin(uv.x * 16.0 - uv.y * 8.0 + t) * 0.5,\n        cos(uv.x * 8.0 + uv.y * 16.0 - t) * 0.5,\n        sin(uv.x * 24.0 + uv.y * 24.0 + t*3.0)\n    );\n    \n    // Create smooth transitions between lines\n    float brightness = max(\n        smoothstep(0.9, 1.0, abs(lines.x)),\n        smoothstep(0.9, 1.0, abs(lines.y))\n    ) * max(\n        smoothstep(0.95, 1.0, abs(lines.z)),\n        0.2\n    );\n    \n    // Generate color based on time and position\n    vec3 color = hsl2rgb(vec3(\n        mod(t * 0.1 + uv.x * 4.0 + uv.y * 6.0, 1.0),\n        0.7,\n        0.5 + brightness * 0.5\n    ));\n    \n    // Add noise for subtle variations\n    color *= 1.0 + noise(vec3(uv, t)) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_342.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a flowing liquid metal effect with dynamic light reflections\n    \n    // Base noise for height map\n    float height = turbulent(uv * 5.0 + iTime * 0.1);\n    \n    // Moving light position\n    vec3 lightPos = vec3(sin(iTime * 0.5) * 2.0, cos(iTime * 0.5) * 2.0, 3.0);\n    \n    // Calculate normals from height map\n    float dx = dFdx(height);\n    float dy = dFdy(height);\n    vec3 normal = normalize(vec3(-dx, -dy, 1.0));\n    \n    // Light direction\n    vec3 lightDir = normalize(lightPos - vec3(uv * 2.0 - 1.0, height));\n    \n    // View direction (camera at origin looking along negative z)\n    vec3 viewDir = normalize(vec3(0.0, 0.0, -1.0));\n    \n    // Calculate reflection vector\n    vec3 reflectDir = reflect(-lightDir, normal);\n    \n    // Phong lighting components\n    float ambient = 0.2;\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 16.0) * 0.5;\n    \n    // Dynamic color based on height and time\n    vec3 baseColor = hsl2rgb(vec3(\n        (height + sin(iTime)) * 180.0,\n        0.7,\n        0.5\n    ));\n    \n    // Add emissive effect where light hits the surface\n    float emissive = max(dot(normal, lightDir), 0.0) * 2.0;\n    \n    // Combine all components\n    vec3 finalColor = baseColor * (ambient + diffuse) + \n                     mix(vec3(1.0), baseColor, 0.7) * specular +\n                     baseColor * emissive;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_343.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a basic circular shape for the plasma ball\n    vec2 center = vec2(0.5);\n    float dist = length(uv - center);\n    float circle = 1.0 - smoothstep(0.4, 0.6, dist);\n    // Add dynamic color shifts using HSL colors\n    float time = iTime * 0.5;\n    vec3 hslColor = vec3(\n        fract(time + dist * 2.0) * 360.0,\n        1.0,\n        0.7\n    );\n    // Add surface ripples using noise functions\n    float rippleScale = 4.0;\n    float rippleSpeed = 0.5;\n    vec2 noiseUV = uv * rippleScale + time * rippleSpeed;\n    float noiseValue = noise(noiseUV);\n    float turbulentValue = turbulent(noiseUV);\n    // Combine noise effects for more complex patterns\n    float surfaceDisturbance = (noiseValue + turbulentValue) * 0.5;\n    dist += surfaceDisturbance * 0.1;\n    // Create depth effect by using distance from center\n    vec3 color = hsl2rgb(hslColor);\n    color *= smoothstep(0.0, 1.0, circle);\n    // Add lighting effects for more realism\n    vec3 lightPos = vec3(0.5, 0.5, 1.0);\n    vec3 normal = normalize(vec3(\n        sin(time + dist * 2.0),\n        cos(time + dist * 2.0),\n        1.0\n    ));\n    \n    float ambient = 0.4;\n    float diffuse = max(0.0, dot(normal, lightPos)) * 0.6;\n    color *= (ambient + diffuse);\n    // Add glow effect at the edges of the plasma ball\n    float glowFactor = smoothstep(0.95, 1.0, circle);\n    color += vec3(0.5) * glowFactor;\n    return vec4(color, 1.0);\n}"
  },
  "data_344.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 pos = vec3(uv * 2.0 - 1.0, 0.0);\n    pos.xy *= 0.5;\n    \n    float time = iTime * 0.5;\n    \n    // Generate base noise patterns\n    float n1 = noise(pos + vec3(time, 0.0, 0.0)) * 0.5 + 0.5;\n    float n2 = noise(pos + vec3(0.0, time, 0.0)) * 0.5 + 0.5;\n    \n    // Create leaf glow effect\n    vec3 color = hsl(n1 * 0.6 + 0.3, 0.8, 0.7);\n    color *= n2;\n    \n    // Add turbulence for dynamic movement\n    float turb = turbulent(pos + vec3(time)) * 0.5 + 0.5;\n    color *= turb;\n    \n    // Create shadow effect\n    float shadow = noise(vec2(n1 * 10.0, time)) * 0.5 + 0.5;\n    color *= mix(1.0, 0.3, shadow);\n    \n    // Add ambient glow\n    vec3 ambient = hsl(0.6, 0.4, 0.2) * (n1 * 0.5 + 0.5);\n    color += ambient;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_345.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for tessellation pattern\n    vec2 st = uv * 10.0;\n    \n    // Add noise and time-based variation\n    float n = noise(st + iTime);\n    vec2 offset = vec2(sin(iTime * 0.5), cos(iTime)) * 0.3;\n    \n    // Create shifting grid pattern\n    vec2 grid = fract(st + offset) - 0.5;\n    float d = length(grid);\n    \n    // Add turbulence for more dynamic effect\n    float t = turbulent(st * 0.5 + iTime);\n    \n    // Combine patterns and create color transitions\n    vec3 color = hsl2rgb(vec3(\n        mod(length(st) * 0.1 + iTime, 1.0), \n        0.7,\n        0.5 + t * 0.5\n    ));\n    \n    // Mix colors based on distance and noise\n    color *= mix(0.8, 1.0, smoothstep(0.4, 0.6, d));\n    color += n * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_346.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color with time-based hue shift\n    vec3 baseColor = hsl2rgb(vec3(0.5 + 0.5*sin(iTime*0.5), 1.0, 0.5));\n    \n    // Create a moving pattern using noise and turbulence\n    float noiseScale = 4.0;\n    vec2 noiseUV = uv * noiseScale + iTime;\n    float noiseValue = noise(noiseUV);\n    \n    // Add turbulent trails effect\n    vec3 trailColor = hsl2rgb(vec3(0.5 + 0.5*sin(iTime*0.3), 1.0, 0.7));\n    float trailStrength = turbulent(uv * 4.0 + iTime) * 0.5;\n    \n    // Combine colors with noise modulation\n    vec3 finalColor = baseColor * (1.0 - noiseValue) + trailColor * noiseValue;\n    finalColor += trailStrength * 0.5;\n    \n    // Add glow effect based on distance from center\n    float dist = length(uv);\n    float glow = smoothstep(0.8, 1.2, 1.0 - dist);\n    finalColor *= 1.0 + glow * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_347.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale UV coordinates\n    vec2 st = (uv - 0.5) * 16.0;\n    \n    // Add rotation based on time\n    float angle = iTime * 0.5;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    mat2 rot = mat2(ca, -sa, sa, ca);\n    st = rot * st;\n    \n    // Create rotating sine wave patterns\n    float x = sin(st.x * 0.1 + iTime) * 4.0;\n    float y = sin(st.y * 0.15 + iTime * 0.8) * 3.0;\n    float d = abs(x + y);\n    \n    // Create color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.1) * 360.0,   // Hue variation over time\n        0.7,                          // Saturation\n        0.5 + d * 0.4                 // Lightness modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_348.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create chromatic aberration effect by offsetting UV coordinates for each color channel\n    vec2 redUV = uv + vec2(0.01, 0.005);\n    vec2 greenUV = uv;\n    vec2 blueUV = uv - vec2(0.01, 0.005);\n    // Create flowing sine wave pattern with noise and turbulence\n    float scale = 4.0;\n    float timeFactor = iTime * 0.5;\n    \n    // Calculate base intensity for each color channel\n    float redIntensity = sin(redUV.x * scale + timeFactor) * \n                        sin(redUV.y * scale + timeFactor);\n    float greenIntensity = sin(greenUV.x * scale + timeFactor) *\n                          sin(greenUV.y * scale + timeFactor);\n    float blueIntensity = sin(blueUV.x * scale + timeFactor) *\n                         sin(blueUV.y * scale + timeFactor);\n    // Add turbulence for more dynamic effect\n    redIntensity += turbulent(redUV * 2.0 + vec2(timeFactor));\n    greenIntensity += turbulent(greenUV * 2.0 + vec2(timeFactor));\n    blueIntensity += turbulent(blueUV * 2.0 + vec2(timeFactor));\n    // Create color variations using HSL to RGB conversion\n    vec3 redColor = hsl(0.5, 1.0, 0.5);\n    vec3 greenColor = hsl(0.3, 1.0, 0.5);\n    vec3 blueColor = hsl(0.1, 1.0, 0.5);\n    // Combine intensity and color\n    vec3 finalColor = vec3(\n        redIntensity * redColor.r,\n        greenIntensity * greenColor.g,\n        blueIntensity * blueColor.b\n    );\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_349.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create rotating sine wave pattern\n    float speed = 0.5;\n    theta += iTime * speed;\n    \n    // Calculate sine wave with time-based rotation\n    float wave = sin(theta + iTime) * 0.5 + 0.5;\n    wave *= sin(r * 10.0 - iTime * 2.0);\n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        theta * 0.15 + iTime * 0.1,   // Hue\n        0.7 + wave * 0.3,             // Saturation\n        0.5 + sin(iTime) * 0.2        // Lightness\n    );\n    \n    // Convert HSL to RGB and mix with noise\n    vec3 color = hsl2rgb(hslColor);\n    float turbulence = turbulent(uv * 10.0 + iTime);\n    color *= 0.5 + turbulence * 0.5;\n    return vec4(color, 1.0);\n}"
  },
  "data_35.json": {
    "src": "\n//prompt: something Wonderful!\nvec4 Effect2(vec2 uv) {\n    // Create expanding rings effect with color variations\n    vec2 pos = uv - 0.5;\n    float r = length(pos);\n    r += iTime * 0.1;\n    \n    // Add noise and sine patterns for detail\n    float s = sin(r * 3. + iTime) * 0.5 + 0.5;\n    vec2 st = uv * 8.; \n    float f = noise(st + iTime);\n    \n    // Create RGB values with time-based variations\n    vec3 col = vec3(\n        (sin(r * 4. + iTime) * 0.5 + 0.5) + f * 0.2,\n        (sin(r * 6. - iTime*2.) * 0.5 + 0.5) + f * 0.2,\n        sin(r * 8. + iTime*3.) * 0.5 + 0.5 + f * 0.2\n    );\n    \n    // Add noise to each channel for texture\n    col += vec3(noise(uv + iTime), noise(uv + iTime + 1.), noise(uv + iTime - 1.)) * 0.3;\n    \n    return vec4(col, 1.0);\n}\n"
  },
  "data_350.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing color patterns using sine waves and noise\n    vec3 baseColor = hsl(\n        sin(uv.x * 10.0 + iTime) * 0.5 + 0.5,   // Hue variation along x-axis\n        0.7,                                      // Saturation\n        0.5                                       // Lightness\n    );\n    \n    // Add turbulence to create dynamic patterns\n    float turb = turbulent(vec3(uv * 2.0, iTime * 0.1));\n    \n    // Create flowing river effect using sine waves with time offset\n    vec3 color = hsv2rgb(\n        vec3(\n            sin(uv.x * 5.0 + iTime) * 0.5 + 0.5,   // Hue variation\n            0.8,                                    // Saturation\n            0.6 + turb * 0.2                        // Lightness with turbulence\n        )\n    );\n    \n    // Add more complex patterns using multiple sine waves\n    color += sin(uv.x * 15.0 + iTime * 3.0) * 0.2;\n    color += sin(uv.y * 5.0 + iTime * 2.0) * 0.1;\n    \n    // Final color adjustment using noise\n    float finalNoise = noise(vec2(uv.x * 4.0, uv.y * 2.0 + iTime));\n    color *= 1.0 + finalNoise * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_351.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating patterns with multiple frequencies\n    vec2 st = uv * 3.0 + time;\n    float angle1 = sin(time * 2.0) * 0.5 + 0.5;\n    float angle2 = cos(time * 1.5) * 0.5 + 0.5;\n    \n    // Layer 1: Rotating squares\n    vec2 rotatedUv1 = uv * mat2(cos(angle1), -sin(angle1), sin(angle1), cos(angle1)) * 0.8;\n    float pattern1 = sin(rotatedUv1.x * 4.0) + sin(rotatedUv1.y * 4.0);\n    \n    // Layer 2: Rotating circles\n    vec2 rotatedUv2 = uv * mat2(cos(angle2), -sin(angle2), sin(angle2), cos(angle2)) * 0.8;\n    float dist = length(rotatedUv2) * 3.0;\n    float pattern2 = sin(dist + time * 2.0);\n    \n    // Combine patterns with noise\n    float combined = (pattern1 * 0.5 + pattern2 * 0.25) + turbulent(uv * 4.0 + time);\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(time * 0.2 + uv.x * 2.0, 1.0),\n        0.7,\n        0.5 + combined * 0.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_352.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create circular pattern with multiple layers\n    float dist = length(uv);\n    vec3 color;\n    \n    // Layer 1: Base circular pattern\n    float layer1 = sin(dist * 8.0 + iTime * 2.0) * 0.5 + 0.5;\n    \n    // Layer 2: Adding more layers with different frequencies\n    float layer2 = sin(dist * 16.0 + iTime * 3.0) * 0.5 + 0.5;\n    \n    // Layer 3: Even more layers for complexity\n    float layer3 = sin(dist * 32.0 + iTime * 4.0) * 0.5 + 0.5;\n    \n    // Combine layers with noise and turbulence\n    vec3 finalColor = hsl(\n        (layer1 + layer2 + layer3) * 360.0,  // Hue variation based on layers\n        0.7 + turbulent(uv * 4.0) * 0.3,      // Saturation with some noise\n        0.5 + sin(iTime) * 0.5               // Brightness modulation over time\n    );\n    \n    return vec4(hsl2rgb(finalColor), 1.0);\n}"
  },
  "data_353.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Time-based animation\n    float t = iTime * 0.5;\n    \n    // Number of particles (simulated through layers)\n    const int numLayers = 4;\n    \n    for(int i = 0; i < numLayers; i++) {\n        // Layer parameters\n        float layerSpeed = pow(1.2, float(i)) * 0.5;\n        float layerRadius = pow(1.3, float(i)) * 0.7;\n        vec3 layerColor = hsl2rgb(vec3(float(i) * 0.3, 1.0, 0.8));\n        \n        // Particle position in polar coordinates\n        float angle = uv.x * 10.0 + t * layerSpeed + noise(vec3(uv, t)) * 2.0;\n        float radius = length(uv) * layerRadius + noise(vec2(angle, t)) * 0.2;\n        \n        // Convert to cartesian coordinates\n        vec2 pos = vec2(cos(angle), sin(angle)) * radius;\n        \n        // Add noise and turbulence for more organic movement\n        pos += noise(vec3(pos, t)) * 0.1;\n        pos += turbulent(vec2(pos + t)) * 0.05;\n        \n        // Compute color with trails effect\n        float dist = length(pos - uv);\n        float alpha = smoothstep(0.1, 0.0, abs(dist));\n        \n        // Mix colors for trail effect\n        finalColor = mix(finalColor, layerColor * (1.0 + sin(t + angle) * 0.5), alpha * 0.3);\n    }\n    \n    // Add central gravitational field glow\n    float glow = smoothstep(0.7, 0.0, length(uv));\n    finalColor += vec3(1.0, 0.8, 0.6) * glow * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_354.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * 10.0;\n    \n    float time = iTime * 0.5;\n    \n    // Create a base pattern using sine waves\n    float patternX = sin(st.x + time) * 0.5 + 0.5;\n    float patternY = sin(st.y + time * 0.7) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for more complexity\n    vec2 noiseUV = st * 0.1;\n    float noiseVal = noise(noiseUV);\n    float turbulentVal = turbulent(noiseUV);\n    \n    // Combine pattern and noise\n    float combined = (patternX + patternY) * 0.5 + noiseVal * 0.3 + turbulentVal * 0.2;\n    \n    // Create color using HSL to HSV conversion\n    vec3 hslColor = vec3(\n        sin(time + st.x * 2.0) * 0.5 + 0.5,   // Hue\n        0.7 + noiseVal * 0.3,                  // Saturation\n        0.5 + turbulentVal * 0.2               // Lightness\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add some depth using sine functions\n    float depth = sin(time + st.x * 0.5) * 0.5 + 0.5;\n    rgbColor *= depth;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_355.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Wave pattern for red channel\n    float r = sin(uv.x * 10.0 + iTime) * 0.5 + 0.5;\n    r += sin(uv.y * 5.0 + iTime * 2.0) * 0.3;\n    \n    // Wave pattern for green channel\n    float g = sin(uv.y * 20.0 + iTime) * 0.4 + 0.6;\n    g += cos(uv.x * 15.0 + iTime * 3.0) * 0.2;\n    \n    // Wave pattern for blue channel\n    float b = sin((uv.x + uv.y) * 8.0 + iTime * 4.0) * 0.6 + 0.4;\n    b += cos(uv.x * 3.0 + uv.y * 5.0 + iTime) * 0.2;\n    \n    color.r = r;\n    color.g = g;\n    color.b = b;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_356.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base turbulence pattern\n    float t1 = turbulent(uv * 0.5 + iTime);\n    float t2 = turbulent(uv * 0.7 + vec2(sin(iTime), cos(iTime)));\n    \n    // Compute color components using sine functions\n    vec3 color = vec3(\n        sin(t1 * 4.0 + iTime) * 0.5 + 0.5,\n        sin(t2 * 6.0 + iTime * 0.7) * 0.5 + 0.5,\n        sin((t1 + t2) * 8.0 + iTime * 1.3) * 0.5 + 0.5\n    );\n    \n    // Convert to HSL and back to RGB for more vibrant colors\n    vec3 hslColor = vec3(\n        0.5 + t1 * 0.2,\n        0.8,\n        0.5 + abs(sin(iTime * 0.3 + t2)) * 0.5\n    );\n    \n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 0.8);\n}"
  },
  "data_357.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    // Create orbiting effect using time\n    angle += iTime * 0.5;\n    // Add chromatic aberration by offsetting each color channel\n    vec3 color;\n    color.r = sin(angle + iTime) * 0.5 + 0.5;\n    color.g = sin(angle + iTime + 2.0) * 0.5 + 0.5;\n    color.b = sin(angle + iTime - 2.0) * 0.5 + 0.5;\n    // Add turbulence for dynamic effect\n    float noiseValue = turbulent(vec3(uv, iTime)) * 0.1;\n    radius += noiseValue;\n    // Convert to HSL and back to RGB for color transformation\n    vec3 hslColor = vec3(angle * 2.0 / PI, 1.0, 0.5 + noiseValue * 0.5);\n    color = hsl2rgb(hslColor);\n    // Create ring pattern using radius\n    float ring = sin(radius * 8.0) * 0.5 + 0.5;\n    color *= ring;\n    return vec4(color, 1.0);\n}"
  },
  "data_358.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create hexagonal grid pattern\n    vec2 q = floor(uv * 5.0 + 0.5);\n    \n    // Convert UV to polar coordinates relative to center of hexagon\n    vec2 p = uv - (q + 0.5)/5.0;\n    float r = length(p) * 16.0;\n    float theta = atan2(p.y, p.x) + iTime;\n    \n    // Create rotating hexagonal pattern with noise perturbation\n    float d = sin(theta * 3.0 - iTime) * 0.5 + 0.5;\n    r += noise(vec3(q + iTime, 0.0)) * 0.2;\n    \n    // Calculate color based on angle and time\n    vec3 color = hsl2rgb(vec3(theta * 180.0 / PI + iTime * 60.0, 1.0, 0.5));\n    \n    // Create pulsing edge effect\n    float edge = sin(r - iTime * 4.0) * 0.5 + 0.5;\n    color *= edge;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_359.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying polar coordinates\n    vec2 st = uv * 5.0; // Scale up for more detail\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    float r = length(st);\n    \n    // Create fractal pattern using multiple layers of noise\n    float pattern1 = turbulent(vec3(st * 10.0, iTime)) * 0.5 + 0.5;\n    float pattern2 = turbulent(vec3(st * 20.0, iTime * 0.7)) * 0.5 + 0.5;\n    \n    // Combine patterns with color transitions\n    vec3 hsvColor;\n    hsvColor.x = theta * 0.1 + iTime * 0.1; // Hue variation over time and space\n    hsvColor.y = (pattern1 + pattern2) * 0.5; // Saturation based on noise\n    hsvColor.z = abs(sin(r * 0.5 - iTime)) * 0.5 + 0.5; // Value variation\n    \n    // Convert HSV to RGB and output\n    return vec4(hsv2rgb(hsvColor), 1.0);\n}"
  },
  "data_36.json": {
    "src": "\nvec4 Effect2(vec2 uv) {\n    float t = iTime * 0.1;\n    \n    // Create a rotating pattern with noise\n    vec2 pos = uv + sin(t * 5.0) * 0.1;\n    pos = (pos - 0.5) * mat2(cos(t), sin(t), -sin(t), cos(t)) * 0.5 + 0.5;\n    \n    // Add some movement and scale\n    vec2 scaled = pos * 4.0 + t;\n    \n    // Use noise to create a turbulent effect\n    float n1 = turbulent(vec3(scaled.x, scaled.y, t));\n    float n2 = turbulent(vec3(scaled.x * 0.5, scaled.y * 0.5, t * 0.5));\n    \n    // Combine noise values with UV coordinates\n    vec2 finalPos = uv + (n1 - 0.5) * 0.2;\n    finalPos = finalPos * mat2(cos(t * 2.0), sin(t * 2.0), -sin(t * 2.0), cos(t * 2.0));\n    \n    // Create color from noise values\n    vec3 color = hsl2rgb(vec3(\n        (n1 + n2) * 0.5,\n        0.7,\n        0.6 + n1 * 0.4\n    ));\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_360.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate with time\n    float time = iTime * 0.5;\n    \n    // Create flowing pattern using turbulence\n    vec2 st = uv * 10.0 + time;\n    float flow = turbulent(st);\n    \n    // Add detail with multiple noise layers\n    flow += noise(vec3(uv * 5.0, time)) * 0.5;\n    flow += noise(vec3(uv * 20.0, time)) * 0.25;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(\n        mod(time * 0.1 + uv.x * 2.0 + uv.y * 3.0, 1.0),  // Hue variation\n        0.7 + flow * 0.3,                               // Saturation modulation\n        0.5 + sin(time) * 0.2                           // Value modulation\n    );\n    \n    // Add lighting effect for water-like appearance\n    vec3 lightDir = vec3(1.0, -1.0, 1.0);\n    vec3 normal = normalize(vec3(\n        noise(vec3(uv + time*0.1, 0.0)) * 2.0 - 1.0,\n        noise(vec3(uv + time*0.2, 0.0)) * 2.0 - 1.0,\n        1.0\n    ));\n    \n    float specular = pow(max(dot(normalize(lightDir), normal), 0.0), 32.0);\n    \n    // Combine everything for final color\n    vec3 finalColor = mix(color, vec3(1.0), specular * 0.5) * (0.5 + flow * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_361.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + 0.25 * iTime; // Add time-based rotation\n    \n    // Create hexagonal pattern using sine function\n    float hexPattern = abs(sin(6.0 * theta)) - 0.1;\n    \n    // Create distance field for gradient fill\n    float distField = (1.0 - r) * 0.5 + 0.5;\n    \n    // Add turbulence to create dynamic effect\n    vec3 noisePos = vec3(uv * 20.0, iTime);\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    \n    // Combine patterns and add color shifts\n    vec3 baseColor = hsl(0.5 + sin(iTime * 0.5) * 0.5, 1.0, 0.5);\n    vec3 mixColor = hsl(0.5 + cos(iTime * 0.5) * 0.5, 1.0, 0.5);\n    \n    // Final color calculation\n    vec3 finalColor = mix(baseColor, mixColor, turb * distField);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_362.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for radial effect\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add noise and time variation\n    float noiseTheta = noise(vec3(theta * 5.0 + iTime, 0.0, 0.0));\n    \n    // Create pulsating effect with radius\n    float pulse = sin(iTime + r * 20.0) * 0.5 + 0.5;\n    \n    // Base color in HSL space\n    vec3 hslColor = vec3(\n        mod(theta * 3.0 + iTime, 1.0),  // Hue variation with angle and time\n        0.8,                              // Saturation\n        pulse * 0.7 + 0.3                 // Lightness varying with pulse\n    );\n    \n    // Add turbulence for more dynamic texture\n    float turb = turbulent(vec2(r, theta));\n    hslColor.xy += vec2(turb * 0.1, turb * 0.1);\n    \n    // Convert to RGB and add noise variation\n    vec3 color = hsl2rgb(hslColor) + noise(vec2(r, iTime)) * 0.3;\n    \n    // Add fog effect based on radius\n    color *= pow(0.5, r * 4.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_363.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Add time-based rotation and create a swirling effect\n    a += iTime * 0.5;\n    r = sin(a * 3.0 + iTime) * 0.5 + 0.5;\n    \n    // Create expanding rings pattern with turbulence\n    float ring = sin(r * 8.0 + iTime) * 0.5 + 0.5;\n    float noiseVal = turbulent(vec2(st.x, st.y)) * 0.3;\n    \n    // Combine patterns and add color cycling\n    vec3 color = hsl2rgb(vec3(\n        (iTime * 0.1 + a) * 0.5 + 0.5,\n        sin(iTime * 0.3 + r * 4.0) * 0.5 + 0.5,\n        ring * (1.0 - noiseVal)\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_364.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float t = iTime * 0.5;\n    \n    // Create moving sine wave pattern\n    vec2 st = uv * 10.0 + vec2(sin(t + uv.x * 3.0), cos(t + uv.y * 3.0));\n    \n    // Add noise and turbulence\n    float noiseVal = noise(st) * 0.5;\n    float turb = turbulent(vec2(st.x * 0.5, st.y * 0.5)) * 0.5;\n    \n    // Create RGB shifts\n    vec3 color = vec3(\n        sin(st.x * 0.5 + t) * 0.5 + 0.5,\n        sin(st.y * 0.5 + t * 0.7) * 0.5 + 0.5,\n        sin((st.x + st.y) * 0.3 + t * 0.9) * 0.5 + 0.5\n    );\n    \n    // Apply RGB shifts and noise/turbulence\n    color += vec3(\n        sin(t * 0.3) * 0.2,\n        sin(t * 0.4 + PI) * 0.2,\n        sin(t * 0.6 + PI*2.0) * 0.2\n    );\n    \n    // Combine with noise and turbulence\n    color *= (noiseVal + turb) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_365.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise pattern\n    float n = noise(uv * 10.0 + vec2(0.0, iTime));\n    \n    // Add sine wave patterns\n    float s1 = sin(uv.x * 20.0 - iTime);\n    float s2 = sin(uv.y * 15.0 + iTime);\n    \n    // Combine noise and waves with different frequencies\n    vec3 color;\n    color.r = n * 0.5 + s1 * 0.5;\n    color.g = n * 0.5 + s2 * 0.5;\n    color.b = (n + s1 + s2) * 0.333;\n    \n    // Add time-based color transformation\n    vec3 hslColor = vec3(\n        0.5 + sin(iTime * 0.5) / 4.0,   // Hue variation over time\n        0.7 + n * 0.2,                  // Saturation\n        0.5 + (s1 + s2) * 0.25          // Lightness\n    );\n    \n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_366.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += iTime * pi / 2.0;\n    // Create hexagonal grid pattern\n    float angle = mod(theta + pi/3.0, pi*2.0) - pi;\n    float dist = r * cos(angle);\n    \n    // Use noise and turbulence for variations\n    float noiseVal = turbulent(vec2(st.x, st.y)) * 0.5 + 0.5;\n    float hexPattern = smoothstep(0.4, 0.6, abs(dist));\n    \n    // Create color transitions\n    vec3 color = hsl2rgb(vec3(mod(iTime * 0.1, 1.0), 0.8, 0.5 + noiseVal * 0.3));\n    \n    // Add trailing effect\n    float trail = exp(-iTime) * 0.5;\n    color += vec3(turbulent(vec3(st.x, st.y, iTime)) * 0.2);\n    \n    return vec4(hexPattern * color + (1.0 - hexPattern) * trail, 1.0);\n}"
  },
  "data_367.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position over time with cosine waves\n    vec2 pos = uv * 8.0 + vec2(cos(iTime), sin(iTime)) * 3.0;\n    \n    // Create geometric pattern using mod and noise\n    vec2 st = fract(pos);\n    float pattern = mod(floor(st.x) + floor(st.y), 2.0);\n    \n    // Add time-based color shift\n    vec3 hslColor = vec3(\n        cos(iTime * 0.5 + pos.x * 0.1) * 0.5 + 0.5,\n        0.7,\n        0.8\n    );\n    \n    // Add noise and turbulence for more dynamic effect\n    float noiseVal = noise(vec2(pos.x * 0.5, pos.y * 0.5));\n    pattern = mix(pattern, noiseVal, 0.3);\n    \n    // Convert to RGB and apply geometric overlay\n    vec3 color = hsl2rgb(hslColor);\n    color *= mix(1.0, 0.5, smoothstep(0.4, 0.6, pattern));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_368.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    // Create pulsating effect using time\n    float pulse = sin(iTime * 0.5 + r * 10.0) * 0.5 + 0.5;\n    \n    // Layered sine waves with increasing frequency and decreasing amplitude\n    float wave1 = sin(theta * 3.0 - iTime * 2.0) * 0.4;\n    float wave2 = sin(theta * 5.0 - iTime * 3.0) * 0.3;\n    float wave3 = sin(theta * 7.0 - iTime * 4.0) * 0.2;\n    \n    // Combine waves and add pulsation\n    float d = r + pulse + wave1 + wave2 + wave3;\n    \n    // Create color gradient using HSL to RGB conversion\n    vec3 hslColor = vec3(0.5 + d * 0.2, 0.7, 0.6);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add turbulence for more organic feel\n    vec2 noiseUV = uv * 10.0;\n    float turb = turbulent(noiseUV) * 0.5 + 0.5;\n    \n    // Final color with brightness modulation\n    vec3 finalColor = rgbColor * (sin(d * 8.0 - iTime * 2.0) * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_369.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal patterns\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create hexagonal tiling pattern using polar coordinates\n    float angleStep = pi / 3.0;\n    float angleMod = mod(a, angleStep);\n    \n    // Use turbulence to create dynamic movement in the pattern\n    vec2 noiseUV = vec2(r * 10.0 + iTime, angleMod * 10.0);\n    float noiseVal = turbulent(noiseUV) * 0.5 + 0.5;\n    \n    // Create pulsating color effect using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        mod(a / pi + iTime * 0.2, 1.0), // Hue variation over time and angle\n        0.7 + noiseVal * 0.3,           // Saturation modulation with noise\n        0.5 + sin(iTime) * 0.4         // Lightness pulsation\n    );\n    \n    // Convert HSL to RGB for final color output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add dynamic gradients using noise texture sampling\n    float gradient = (sin(r * 10.0 + iTime) * 0.5 + 0.5) * noiseVal;\n    rgbColor *= gradient;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_37.json": {
    "src": "\nvec4 Effect2(vec2 uv) {\n    vec3 color;\n    // Convert UV coordinates to polar coordinates\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    // Animate radius and angle\n    r *= sin(iTime * 0.5);\n    theta += cos(iTime * 0.3);\n    // Transform to cartesian with animated polar coordinates\n    vec2 pos = vec2(r * cos(theta), r * sin(theta));\n    // Add noise for turbulence effect\n    float noiseValue = noise(pos * 10.0 + iTime);\n    pos += vec2(noiseValue * 0.1, noiseValue * 0.1);\n    // Calculate color using HSL with time-varying hue and lightness\n    color = hsl2rgb(vec3(\n    theta / (2.0 * pi) + iTime * 0.5,\n    0.7 + sin(r * 4.0 + iTime) * 0.3,\n    0.8 + turbulent(vec3(pos * 10.0, 0.0)) * 0.2\n    ));\n    return vec4(color, 1.0);\n}\n"
  },
  "data_370.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create expanding rings pattern\n    vec2 center = vec2(0.5, 0.5);\n    float dist = length(uv - center);\n    float ring = mod(dist * 10.0 + t, 1.0);\n    \n    // Create rotating squares pattern\n    vec2 squareUv = rotatedUv * 3.0;\n    vec2 squarePos = fract(squareUv);\n    float square = max(step(0.95, squarePos.x), step(0.95, squarePos.y));\n    \n    // Combine patterns with noise\n    float noiseVal = turbulent(rotatedUv * 10.0 + t) * 0.5 + 0.5;\n    vec3 color = hsl2rgb(vec3(\n        mod(t * 0.5, 1.0),\n        1.0,\n        mix(0.5, noiseVal, 0.7)\n    ));\n    \n    // Mix patterns and add glow effect\n    float glow = max(0.0, 1.0 - length(uv - center) * 2.0);\n    vec3 finalColor = mix(color * ring, color * square, 0.5) * (1.0 + glow * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_371.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of squares using tiling pattern\n    vec2 st = fract(uv * 100.0);\n    \n    // Calculate center point for each square\n    vec2 center = fract(st - 0.5);\n    \n    // Calculate rotation angle based on position and time\n    float speed = length(center) + turbulent(vec3(center, iTime)) * 0.5;\n    float angle = atan2(center.y, center.x) + iTime * speed;\n    \n    // Apply rotation matrix to each square\n    vec2 rotated = vec2(\n        cos(angle) * (st.x - 0.5) - sin(angle) * (st.y - 0.5),\n        sin(angle) * (st.x - 0.5) + cos(angle) * (st.y - 0.5)\n    ) + 0.5;\n    \n    // Create square shape\n    float square = max(abs(rotated.x - 0.5), abs(rotated.y - 0.5));\n    \n    // Add noise and color transformation\n    vec3 color = hsl2rgb(vec3(\n        length(center) * 0.7 + iTime * 0.1,\n        0.8 + turbulent(vec3(st, iTime)) * 0.2,\n        0.5 + sin(iTime + length(center)*10.0) * 0.5\n    ));\n    \n    // Combine effects and output\n    return vec4(color * (1.0 - square), 1.0);\n}"
  },
  "data_372.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 fragColor;\n    \n    // Convert UV to polar coordinates for rotation effect\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Add time-based rotation\n    theta += iTime * 3.0; // Rotate at 3 radians per second\n    \n    // Create geometric pattern using sine waves and noise\n    float pattern = sin(theta * 10.0 + iTime) * 0.5 + 0.5;\n    pattern = mod(pattern, PI/2.0); // Quarter-circle pattern\n    \n    // Add noise for complexity\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.2 + pattern), // Time-based hue variation\n        0.7, // Saturation\n        0.5 // Lightness\n    ));\n    \n    // Mix in noise for dynamic transitions\n    float noiseValue = noise(uv * 10.0 + iTime);\n    color = mix(color, hsl2rgb(vec3(\n        fract(iTime * 0.3), \n        0.8,\n        0.6\n    )), noiseValue * 0.3);\n    \n    fragColor = vec4(color, 1.0);\n    return fragColor;\n}"
  },
  "data_373.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating grid pattern\n    float time = iTime * 0.5;\n    vec2 rotatedUV = uv * cos(time) + uv.yx * sin(time);\n    \n    // Add moving sine waves overlay\n    float waveX = sin(rotatedUV.x * 8.0 + time * 2.0) * 0.5 + 0.5;\n    float waveY = sin(rotatedUV.y * 8.0 - time * 2.0) * 0.5 + 0.5;\n    \n    // Combine grid and waves\n    float combined = (waveX + waveY) * 0.5;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(time * 0.1, 1.0, 0.8));\n    \n    // Overlay effect with grid lines\n    float grid = step(0.9, abs(sin(rotatedUV.x * 4.0 + time)) + \n                    abs(cos(rotatedUV.y * 4.0 - time)));\n    \n    return vec4(color * combined + (1.0 - combined) * vec3(grid), 1.0);\n}"
  },
  "data_374.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset UV coordinates\n    vec2 st = uv * 10.0 - 5.0;\n    \n    // Create a time-based wave movement\n    float time = iTime * 0.5;\n    float wave = sin(st.x * 0.5 + time) * cos(st.y * 0.5 + time);\n    \n    // Add color shifting using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(time * 0.1, 1.0),  // Hue\n        0.7,                  // Saturation\n        0.5 + wave * 0.2      // Lightness with wave modulation\n    ));\n    \n    // Add turbulence for more dynamic effect\n    float turb = turbulent(vec3(st.x, st.y, time));\n    color *= 1.0 + turb * 0.4;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_375.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create multiple rotating layers with different speeds\n    float rot1 = iTime * 0.5;\n    float rot2 = iTime * 0.75;\n    float rot3 = iTime * 1.0;\n    // Calculate hexagonal pattern for each layer\n    vec3 colors = vec3(0.0);\n    \n    // Layer 1: Fast rotation with cyan hue\n    {\n        float angle = a + rot1;\n        float hex = abs(sin(angle * 6.0)) * 0.5 + 0.5;\n        float d = r * 20.0 - iTime * 3.0;\n        float noiseVal = turbulent(vec2(d, 0.0)) * 0.1;\n        float finalHex = hex + noiseVal;\n        \n        colors.r += smoothstep(0.4, 0.5, abs(finalHex - 0.5));\n    }\n    \n    // Layer 2: Medium rotation with magenta hue\n    {\n        float angle = a + rot2 + PI;\n        float hex = abs(sin(angle * 6.0)) * 0.5 + 0.5;\n        float d = r * 20.0 - iTime * 3.0;\n        float noiseVal = turbulent(vec2(d, 1.0)) * 0.1;\n        float finalHex = hex + noiseVal;\n        \n        colors.g += smoothstep(0.4, 0.5, abs(finalHex - 0.5));\n    }\n    \n    // Layer 3: Slow rotation with yellow hue\n    {\n        float angle = a + rot3 + PI * 2.0;\n        float hex = abs(sin(angle * 6.0)) * 0.5 + 0.5;\n        float d = r * 20.0 - iTime * 3.0;\n        float noiseVal = turbulent(vec2(d, 2.0)) * 0.1;\n        float finalHex = hex + noiseVal;\n        \n        colors.b += smoothstep(0.4, 0.5, abs(finalHex - 0.5));\n    }\n    // Add pulsating color effect\n    vec3 hslColors = vec3(\n        sin(iTime * 2.0) * 0.5 + 0.5,   // Hue variation\n        1.0,                             // Saturation\n        0.8                              // Lightness\n    );\n    \n    vec3 finalColor = hsl2rgb(hslColors) * (colors.r + colors.g + colors.b);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_376.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates from UV\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Add pulsating effect\n    float pulse = sin(iTime * 0.7) * 0.5 + 0.5;\n    r *= 1.0 + pulse * 0.4;\n    \n    // Create color variations using turbulence and noise\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.1,\n        0.8 + turbulent(vec3(st, iTime)) * 0.2,\n        0.5 + noise(vec2(r * 4.0, theta)) * 0.5\n    ));\n    \n    // Add radial motion and blending\n    color *= 1.0 - r * 0.6;\n    color += vec3(turbulent(vec2(st * 0.5 + iTime * 0.2)));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_377.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using sine functions\n    float time = iTime * 0.5;\n    \n    // Transform UV coordinates for rotation effect\n    vec2 rotatedUV = vec2(\n        uv.x * cos(time) - uv.y * sin(time),\n        uv.x * sin(time) + uv.y * cos(time)\n    );\n    \n    // Add turbulence to create plasma-like effect\n    float noise1 = turbulent(rotatedUV * 5.0);\n    float noise2 = turbulent(rotatedUV * 10.0 + vec2(sin(time), cos(time)));\n    \n    // Combine noise layers with different frequencies\n    float combinedNoise = (noise1 + noise2) * 0.5;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        sin(time + uv.x * 2.0 + uv.y * 3.0) * 0.5 + 0.5,\n        0.7,\n        0.8 + combinedNoise * 0.2\n    );\n    \n    // Convert HSL to RGB and mix with noise patterns\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor = mix(rgbColor, vec3(1.0), abs(combinedNoise));\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_378.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 fragColor;\n    \n    // Create rotating geometric pattern using polar coordinates\n    float angle = atan2(uv.y, uv.x) + iTime * 0.25;\n    float radius = length(uv);\n    \n    // Generate multiple overlapping patterns with sine functions\n    float pattern1 = sin(angle * 6.0) * 0.5 + 0.5;\n    float pattern2 = sin(radius * 30.0 - iTime * 2.0) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for organic feel\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noisePattern = noise(noiseUV);\n    float turbulentPattern = turbulent(vec3(uv, iTime));\n    \n    // Combine patterns with color transitions\n    float combined = pattern1 * pattern2 + noisePattern * 0.5 + turbulentPattern * 0.3;\n    combined = clamp(combined, 0.0, 1.0);\n    \n    // Convert to HSL and animate hue over time\n    vec3 hslColor = vec3(0.5 + sin(iTime) * 0.5, 0.7, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    fragColor = vec4(combined * rgbColor, 1.0);\n    \n    return fragColor;\n}"
  },
  "data_379.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotatedUV = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create triangular pattern using barycentric coordinates\n    vec3 coords = vec3(uv, 0.0);\n    coords.xy = abs(mod(coords.xy * 5.0, 1.0) - 0.5);\n    float dist = length(coords.xy);\n    \n    // Add noise and turbulence for dynamic effect\n    float noiseVal = noise(vec2(rotatedUV.x + t, rotatedUV.y));\n    float turb = turbulent(vec3(rotatedUV * 2.0 + vec2(t), 0.0)) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(turb + dist) * 0.5 + 0.5,\n        1.0 - abs(noiseVal),\n        0.6 + noiseVal * 0.2\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_38.json": {
    "src": "\nvec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Transform coordinates over time\n    float scale = sin(iTime * 0.5) * 3.0 + 4.0;\n    st *= scale;\n    st = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * st;\n    \n    // Add noise and turbulence\n    vec3 point = vec3(st.x, st.y, iTime * 0.1);\n    float t = turbulent(point) * 2.0 + noise(vec3(st, iTime));\n    \n    // Convert to HSL and then RGB\n    vec3 color = hsl2rgb(vec3(\n        t * 60.0 + iTime * 30.0,\n        sin(t * 5.0 + iTime) * 0.5 + 0.5,\n        cos(t * 7.0 + iTime * 2.0) * 0.5 + 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}\n"
  },
  "data_380.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating pattern using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x) + time;\n    float radius = length(st);\n    \n    // Generate geometric patterns with noise and turbulence\n    float pattern = sin(theta * 4.0) * cos(theta * 6.0) +\n                   sin(theta * 8.0) * cos(theta * 12.0);\n    pattern = abs(pattern) * 0.5 + 0.5;\n    \n    // Create vibrant color transitions\n    vec3 hslColor = vec3(\n        fract(time * 0.2 + radius * 0.4),\n        0.8,\n        0.6 + turbulent(vec3(radius, time, 0.0)) * 0.1\n    );\n    \n    // Convert to RGB and add dynamic shadows\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= 0.5 + 0.5 * noise(vec3(radius, time, 0.0));\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_381.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    // Create rotating pattern using time-based rotation\n    float timeRotation = iTime * 0.5;\n    angle += timeRotation;\n    // Add another layer of rotation for more dynamic effect\n    float secondaryRotation = sin(iTime) * 0.2;\n    angle += secondaryRotation;\n    // Use turbulence to add noise variation\n    float noiseValue = turbulent(vec3(uv * 10.0, iTime));\n    \n    // Create pulsating color effect using HSL\n    vec3 hslColor = vec3(\n        fract(timeRotation * 0.2 + sin(radius) * 0.5),\n        0.7,\n        0.5 + noiseValue * 0.2\n    );\n    \n    // Convert to RGB and mix with another color for depth\n    vec3 finalColor = mix(hsl2rgb(hslColor), \n                         hsl2rgb(vec3(0.1, 0.8, 0.6)),\n                         smoothstep(0.5, 1.5, radius));\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_382.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base terrain using fractal noise\n    float terrain = turbulent(uv * 10.0 + iTime);\n    \n    // Add secondary layer of noise for more detail\n    terrain += turbulent(uv * 5.0 + iTime * 0.5) * 0.5;\n    \n    // Create height-based color transitions\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1, 1.0),  // Hue that shifts over time\n        0.7,                    // Saturation\n        0.5 + terrain * 0.4     // Value based on terrain height\n    ));\n    \n    // Add atmosphere effect using distance from center\n    float dist = length(uv);\n    color = mix(\n        color,\n        hsl2rgb(vec3(mod(iTime * 0.15, 1.0), 0.6, 0.8)),\n        smoothstep(1.0, 0.0, dist)\n    );\n    \n    // Add height-based color transitions\n    color = mix(\n        color,\n        hsl2rgb(vec3(mod(iTime * 0.2 + uv.y * 0.5, 1.0), 0.8, 0.6)),\n        smoothstep(0.5, 1.0, terrain)\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_383.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create rotating sine wave patterns\n    float tx = sin(st.x + cos(st.y + iTime)) * 0.5 + 0.5;\n    float ty = cos(st.y + sin(st.x - iTime)) * 0.5 + 0.5;\n    \n    // Combine patterns with turbulence\n    float pattern = sin(tx * PI + ty * PI) * 0.5 + 0.5;\n    pattern += turbulent(vec2(uv * 10.0 + iTime * 0.5)) * 0.3;\n    \n    // Create shifting hues using HSL color space\n    vec3 color = hsl(pattern * 360.0, 0.7, 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_384.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Animate rotation and add noise variation\n    theta += iTime * 5.0 + turbulent(vec3(theta / 4.0, iTime * 0.5, 0.0)) * 2.0;\n    \n    // Create color layers with HSL\n    vec3 color1 = hsl2rgb(vec3(theta * 0.15 + iTime * 0.1, 0.6, 0.8));\n    vec3 color2 = hsl2rgb(vec3(theta * 0.15 + iTime * 0.1 + 0.5, 0.4, 0.7));\n    // Mix colors based on radius and add glow\n    float mixAmount = smoothstep(0.0, 1.0, r);\n    vec3 finalColor = mix(color2, color1, mixAmount) * (1.0 - r * 0.5) + \n                     turbulent(vec2(theta / 4.0, iTime)) * 0.3 * (1.0 - r);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_385.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate coordinates with sine waves\n    vec2 st = uv * 10.0 + vec2(sin(iTime), cos(2.0*iTime)) * 5.0;\n    \n    // Add noise and turbulence\n    float turb = turbulent(st * 10.0 + iTime);\n    \n    // Create color shifts using HSL\n    vec3 baseColor = hsl(\n        sin(iTime * 0.5) * 0.5 + 0.5,   // Hue variation\n        0.7,                              // Saturation\n        cos(iTime * 0.3) * 0.5 + 0.5     // Lightness variation\n    );\n    \n    // Add RGB shifts based on position and time\n    vec3 rgbShift = vec3(\n        sin(st.x * 2.0 + iTime),\n        sin(st.y * 2.0 + iTime + 2.0),\n        sin((st.x + st.y) * 1.5 + iTime)\n    ) * 0.3;\n    \n    // Combine everything\n    vec3 finalColor = mix(baseColor, rgbShift, turb);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_386.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using HSL with time-based modulation\n    vec3 color = hsl(\n        sin(uv.x * 10.0 + iTime) * 0.5 + 0.5,  // Hue variation across screen and time\n        0.7,  // Saturation\n        0.6  // Lightness\n    );\n    \n    // Add flowing movement using sine waves modulated by time\n    float flow = sin(uv.x * 10.0 + iTime) * 0.5;\n    flow += sin(uv.y * 10.0 + iTime * 2.0) * 0.3;\n    \n    // Add turbulence for more dynamic movement\n    vec2 noiseUV = uv * 10.0 + vec2(iTime, iTime);\n    float turb = turbulent(noiseUV);\n    \n    // Combine color and movement\n    color = hsl2rgb(vec3(\n        (sin(uv.x * 5.0 + iTime) + sin(uv.y * 5.0 + iTime)) * 0.5 + 0.5,  // Dynamic hue\n        0.7,\n        turb * 0.4 + 0.6  // Modulate lightness with turbulence\n    ));\n    \n    // Add pulsing effect to overall brightness\n    float pulse = sin(iTime) * 0.3 + 0.7;\n    color *= pulse;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_387.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates from UV\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime;  // Add time for rotation\n    \n    // Create mirrored patterns using modular arithmetic\n    theta = mod(theta * 8.0, PI * 2.0);  // 8-fold symmetry\n    float sawtooth = sin(theta * 4.0) * 0.5 + 0.5;  // Sine wave for color shifts\n    \n    // Generate geometric pattern using noise and turbulence\n    float pattern = turbulent(vec3(r, theta, iTime)) * 0.5 + 0.5;\n    pattern *= r * 5.0;  // Scale pattern by radius\n    \n    // Create dynamic colors using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.6 + sawtooth * 0.3, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.9 - sawtooth * 0.2, 0.7, 0.5));\n    \n    // Mix colors based on pattern\n    vec3 finalColor = mix(color1, color2, pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_388.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate parameters over time\n    float time = iTime * 0.5;\n    \n    // Create a base grid pattern using sine waves\n    vec2 st = uv * 10.0 + time;\n    float grid = sin(st.x * PI) * cos(st.y * PI);\n    \n    // Add noise to create dynamic movement\n    vec3 noisePos = vec3(uv * 5.0, time);\n    float turbulence = turbulent(noisePos);\n    \n    // Create intersecting lines with varying thickness\n    float line1 = sin(uv.x * PI + time) * 0.5 + 0.5;\n    float line2 = cos(uv.y * PI - time) * 0.5 + 0.5;\n    \n    // Combine lines and add color\n    vec3 color = hsl2rgb(vec3(\n        mod(time, 1.0) * 360.0,\n        0.7,\n        line1 * line2 * (1.0 + turbulence * 0.5)\n    ));\n    \n    // Add anti-aliasing and glow effect\n    float aa = smoothstep(0.9, 1.0, grid);\n    color *= mix(vec3(0.2), vec3(1.0), aa);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_389.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base circle field\n    vec3 baseColor = vec3(0.0);\n    \n    // Generate random circles using noise\n    for(float i = 0.0; i < 100.0; i++) {\n        float seed = (i + 1.0) * 0.1;\n        vec2 pos = fract(vec2(i, i) * 0.3) + noise(vec2(seed, seed)) * 0.5;\n        float radius = 0.05 + noise(vec2(seed, seed + 1.0)) * 0.05;\n        \n        // Circle equation\n        vec2 toCircle = uv - pos;\n        float dist = length(toCircle);\n        float circle = smoothstep(radius, 0.0, dist);\n        \n        // Add color with varying hue\n        baseColor += hsl2rgb(vec3(iTime * 0.1 + i * 0.1, 0.7, 0.5)) * circle;\n    }\n    \n    // Moving sine wave overlay\n    vec2 waveUV = uv * 4.0 + iTime;\n    float wave1 = sin(waveUV.x * pi + iTime) * 0.5 + 0.5;\n    float wave2 = sin(waveUV.y * pi + iTime * 0.7) * 0.5 + 0.5;\n    \n    // Combine waves and add turbulence\n    vec3 waveColor = hsl2rgb(vec3(iTime * 0.1, 0.8, 0.6));\n    float waveEffect = (wave1 + wave2) * 0.5;\n    waveEffect *= turbulent(uv * 4.0 + iTime);\n    \n    // Combine circle field with sine waves\n    vec3 finalColor = baseColor * (1.0 - waveEffect) + waveColor * waveEffect;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_39.json": {
    "src": "\n//prompt: something wonderful\nvec4 Effect2(vec2 uv) {\n    vec2 st = uv * 2.0;\n    st.x += sin(iTime) * 1.5;\n    st.y += cos(iTime * 0.75) * 1.5;\n    \n    float t = iTime * 0.3;\n    float a = turbulent(st) * 2.0;\n    \n    vec3 color = hsl2rgb(vec3(\n        (a + sin(a * 4.0)) * 0.25 + t * 0.1,\n        0.85,\n        0.7\n    ));\n    \n    return vec4(color, exp(-length(st) * 0.3));\n}\n"
  },
  "data_390.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create hexagonal pattern using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Add pulsating effect with cosine waves\n    theta += time;\n    float petal = cos(theta * 6.0) * cos(time + r * 5.0);\n    \n    // Create color transitions using HSL colors\n    vec3 colors[3];\n    colors[0] = hsl(0.0, 1.0, 0.5);   // Red\n    colors[1] = hsl(120.0, 1.0, 0.5); // Green\n    colors[2] = hsl(240.0, 1.0, 0.5); // Blue\n    \n    // Interpolate between colors based on time and position\n    float colorIndex = mod(time * 0.5 + r * 0.2, 3.0);\n    vec3 finalColor = mix(colors[int(colorIndex)], \n                         colors[int(colorIndex) % 2 == 0 ? int(colorIndex)+1 : 0], \n                         fract(colorIndex));\n    \n    // Add noise for extra texture\n    float noiseValue = noise(vec2(uv * 20.0 + time)) * 0.5 + 0.5;\n    finalColor *= noiseValue;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_391.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating sine wave pattern\n    float wave = sin(uv.x * 4.0 + iTime) * 0.5 + 0.5;\n    wave += sin(iTime * 0.5 + uv.x * 8.0) * 0.3;\n    \n    // Create shifting RGB colors using HSL\n    vec3 color = hsl2rgb(vec3(0.5 * iTime, 1.0, wave));\n    \n    // Add vertical movement and noise\n    float yWave = sin(uv.y * 4.0 + iTime * 0.7) * 0.3;\n    color *= vec3(wave + yWave);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_392.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of hexagon centers\n    vec2 st = floor(uv * 10.0);\n    \n    // Convert to polar coordinates for hexagonal symmetry\n    vec2 pos = vec2(\n        cos(atan2(st.y, st.x)),\n        sin(atan2(st.y, st.x))\n    );\n    \n    // Calculate distance from center with hexagonal pattern\n    float dist = length(uv - st);\n    float angle = atan2(pos.y, pos.x) + iTime * 0.25; // Slow rotation\n    \n    // Pulsating glow effect\n    float pulse = sin(iTime * 3.0 + dist * 10.0) * 0.5 + 0.5;\n    \n    // Concentric circles around each hexagon\n    float rings = sin(length(uv - st) * 20.0 + iTime * 2.0);\n    \n    // Color transitions using HSL\n    vec3 color1 = hsl2rgb(vec3(\n        (angle + dist) * 0.5,\n        0.8,\n        pulse * 0.7 + 0.3\n    ));\n    \n    vec3 color2 = hsl2rgb(vec3(\n        (angle - dist) * 0.5,\n        0.6,\n        rings * 0.4 + 0.6\n    ));\n    \n    // Combine effects with noise modulation\n    float noiseMod = noise(vec3(st, iTime)) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, noiseMod);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_393.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float angle = sin(iTime * 0.5) * pi;\n    vec2 rotatedUV = vec2(\n        (uv.x - 0.5) * cos(angle) - (uv.y - 0.5) * sin(angle),\n        (uv.x - 0.5) * sin(angle) + (uv.y - 0.5) * cos(angle)\n    ) + 0.5;\n    \n    // Create noise patterns with time offset\n    vec2 st = rotatedUV * 8.0 + iTime;\n    float n1 = noise(st);\n    float n2 = noise(st + vec2(0.3, 0.7));\n    \n    // Mix noise patterns with turbulence\n    float pattern = (n1 + n2) * 0.5;\n    pattern += turbulent(rotatedUV * 4.0 + iTime * 0.5);\n    \n    // Create dynamic color shifts using HSL\n    vec3 color = hsl(\n        sin(iTime * 0.2 + rotatedUV.x * pi) * 0.5 + 0.5,\n        0.7 + sin(rotatedUV.y * pi + iTime) * 0.3,\n        0.5 + pattern * 0.4\n    );\n    \n    // Add color transformation and contrast\n    color = hsv2rgb(vec3(\n        color.r * 0.8 + 0.2,\n        color.g * 1.2,\n        color.b * 1.2\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_394.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create multiple layers of sine waves with different frequencies\n    float pattern = sin(rotatedUv.x * 10.0 + t) +\n                   sin(rotatedUv.y * 20.0 + t*0.5) +\n                   sin(length(uv)*30.0 - t);\n    \n    // Add turbulence for more organic feel\n    vec2 noiseScale = rotatedUv * 4.0;\n    float turb = turbulent(noiseScale);\n    \n    // Create color cycling effect using HSL\n    vec3 hslColor = vec3(\n        mod(t*0.1, 1.0),   // Hue cycling over time\n        0.7 + turb*0.3,    // Saturation with turbulence variation\n        0.5 + pattern*0.2  // Lightness with sine wave pattern\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor * (1.0 + turb*0.5), 1.0);\n}"
  },
  "data_395.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime * 8.0;\n    \n    // Create layered sine patterns with time-based phase shifts\n    float r = sin(radius * 8.0 + iTime) * 0.5 + 0.5;\n    float g = sin(radius * 4.0 + iTime * 2.0 + angle) * 0.5 + 0.5;\n    float b = sin(radius * 2.0 + iTime * 3.0 + angle * 2.0) * 0.5 + 0.5;\n    \n    // Add turbulence for dynamic plasma effect\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float turb = turbulent(noiseUV);\n    \n    // Combine colors and add turbulence\n    vec3 color = vec3(r, g, b) * (turb * 0.5 + 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_396.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create multiple layers of rotating sine waves\n    for(float i = 1.0; i <= 5.0; i++) {\n        float speed = i * 0.5;\n        float time = iTime * speed;\n        \n        // Calculate rotating pattern using sine waves\n        vec2 st = uv * i + vec2(sin(time), cos(time)) * 0.5;\n        float angle = atan2(st.y, st.x);\n        float radius = length(st) * 10.0;\n        \n        // Create color cycling effect\n        float hue = (radius - time) * 0.1;\n        vec3 c = hsl(hue, 1.0, 0.5);\n        \n        // Add turbulence for dynamic patterns\n        float turb = turbulent(vec2(uv.x * iTime, uv.y * iTime)) * 0.5 + 0.5;\n        \n        // Combine layers with different frequencies\n        color += sin(radius - time) * c * turb;\n    }\n    \n    // Add noise for extra detail\n    color += noise(uv * 10.0 + iTime) * 0.3;\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_397.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation effect\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    // Create rotating sine wave pattern with increasing frequency\n    float wave = sin(r * 5.0 + theta) * 0.5 + 0.5;\n    \n    // Add noise for texture and complexity\n    vec3 noiseColor = vec3(noise(vec2(theta, r * 0.1)), \n                          noise(vec2(theta * 0.7, r * 0.2)),\n                          noise(vec2(theta * 0.9, r * 0.3)));\n    \n    // Create dynamic color transitions using HSL\n    vec3 baseColor = hsl2rgb(vec3(theta + iTime, 1.0, 0.5));\n    \n    // Combine wave pattern with noise and color transitions\n    float mixAmount = wave * 0.7 + 0.3;\n    vec3 finalColor = mix(baseColor, noiseColor * 0.8, mixAmount);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_398.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to create grid cells\n    vec2 st = uv * 10.0;\n    \n    // Get integer cell indices\n    vec2 ij = floor(st);\n    \n    // Calculate pulsing factor based on time and position\n    float pulse = sin(iTime + (ij.x + ij.y) * 0.5) * 0.5 + 0.5;\n    \n    // Alternate colors based on cell coordinates\n    vec3 color1 = vec3(1.0, 0.0, 0.0); // Red\n    vec3 color2 = vec3(0.0, 0.0, 1.0); // Blue\n    \n    // Mix colors based on pulsing effect and cell position\n    vec3 finalColor = mix(color1, color2, pulse);\n    \n    // Add some noise to create variation\n    finalColor += noise(st * 5.0 + iTime) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_399.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates with time\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create complex wave patterns using multiple sine frequencies\n    float wave1 = sin(st.x * 0.5) * cos(st.y * 0.7);\n    float wave2 = sin(st.y * 0.3 + iTime * 2.0) * cos(st.x * 0.4 + iTime);\n    \n    // Add turbulence for organic movement\n    vec2 noiseUV = uv * 5.0;\n    float turb1 = turbulent(noiseUV);\n    float turb2 = turbulent(noiseUV * 0.7 + iTime);\n    \n    // Combine waves and turbulence with time-based offset\n    float finalValue = (wave1 + wave2) * 0.5 + turb1 * 0.3 + turb2 * 0.2;\n    \n    // Convert to HSL color space for smooth transitions\n    vec3 hslColor = vec3(\n        fract(finalValue * 0.5 + iTime * 0.1),   // Hue\n        0.7,                                    // Saturation\n        0.6 + turb2 * 0.2                       // Lightness with noise variation\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_4.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = hsv2rgb(vec3(\n        noise(uv * 5.0 + iTime * 0.1),\n        0.8,\n        0.8\n    ));\n    \n    float timeFactor = iTime * 0.2;\n    vec2 st = uv * 2.0 - 1.0;\n    st.x += sin(timeFactor) * 0.5;\n    st.y += cos(timeFactor * 0.7) * 0.5;\n    \n    float noiseValue = noise(st * 3.0 + timeFactor);\n    finalColor *= vec3(0.8 + noiseValue * 0.2);\n    \n    float distanceFromCenter = length(uv - 0.5);\n    finalColor += vec3(0.2, 0.4, 0.6) * (1.0 - smoothstep(0.0, 1.0, distanceFromCenter));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_40.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = hsl(\n        sin(uv.x * iTime) * 0.5 + 0.5,\n        cos(uv.y * iTime) * 0.5 + 0.5,\n        noise(uv * iTime) * 0.5 + 0.5\n    );\n    \n    float timeFactor = mod(iTime * 2.0, 1.0);\n    color = hsl2rgb(color * vec3(1.0 - timeFactor, 1.0 - timeFactor, 1.0));\n    \n    float noiseValue = noise(vec2(uv.x * iTime, uv.y * iTime));\n    color *= hsv2rgb(vec3(\n        mod(iTime * 5.0 + uv.x, 1.0),\n        0.8,\n        0.8\n    ));\n    \n    vec4 result;\n    result.rgb = color;\n    result.a = 1.0;\n    return result;\n}"
  },
  "data_400.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create pulsating effect using time-based radius modulation\n    float pulse = sin(iTime * 0.5 + r * 4.0) * 0.5 + 0.5;\n    float radius = r * (1.0 + pulse * 0.3);\n    \n    // Generate hexagonal pattern using angle and radius\n    float hexPattern = abs(cos(a * 6.0)) * 0.5 + 0.5;\n    hexPattern *= smoothstep(0.7, 1.0, radius);\n    // Add noise for texture\n    vec2 noiseScale = vec2(4.0, 8.0);\n    float noiseValue = noise(st * noiseScale.x + iTime) * 0.3;\n    noiseValue += noise(st * noiseScale.y + iTime * 0.5) * 0.15;\n    // Create color transitions using HSL\n    vec3 hslColor = vec3((iTime * 0.2 + a * 0.5) * 0.6, 0.7, hexPattern * 0.8 + noiseValue * 0.2);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Combine all elements\n    return vec4(rgbColor * hexPattern, 1.0);\n}"
  },
  "data_401.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern based on UV coordinates\n    vec2 st = fract(uv * 10.0); // Scale up for smaller cells\n    \n    // Calculate triangle positions\n    vec2 pos = st;\n    float d = length(pos - vec2(0.5)); // Distance from center\n    float angle = atan2(pos.y - 0.5, pos.x - 0.5);\n    \n    // Create tessellation pattern\n    float pattern = sin(angle * 3.1415926) * cos(d * 3.1415926 * 2.0);\n    pattern = fract(pattern + iTime); // Animate the pattern\n    \n    // Generate RGB shift effect\n    vec3 color = hsl2rgb(vec3(fract(iTime * 0.2), 1.0, 0.5));\n    \n    // Add flowing background with noise\n    float flow = turbulent(vec2(uv.x + iTime * 0.1, uv.y + iTime * 0.2)) * 0.5 + 0.5;\n    vec3 bgColor = hsl2rgb(vec3(flow * 360.0, 0.7, 0.5));\n    \n    // Combine effects\n    vec3 finalColor = mix(bgColor, color, pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_402.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to range [-1.0, 1.0]\n    vec2 pos = uv * 2.0 - 1.0;\n    \n    // Add time-based rotation\n    float angle = atan(pos.y, pos.x) + iTime * 0.5;\n    \n    // Calculate polar coordinates\n    float radius = length(pos);\n    float theta = fract(angle / (pi * 2.0)) * pi * 2.0;\n    \n    // Create hexagon pattern using polar coordinates\n    float hex = abs(cos(theta * 3.0)) * radius;\n    hex = smoothstep(0.5, 1.0, hex);\n    \n    // Add turbulence for gradient effect\n    vec3 color = vec3(turbulent(vec2(radius, theta + iTime)));\n    \n    // Convert to HSL and animate hue over time\n    vec3 hslColor = vec3(fract(iTime * 0.2), 1.0, 0.5);\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_403.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create rotating color wheels using HSL colors\n    float hue = fract(theta / (pi * 2.0) + iTime * 0.1); // Time-based color shift\n    vec3 hslColor = vec3(hue, 0.7, 0.5);\n    \n    // Add pulsating rings effect\n    float ring = sin(r * 8.0 - iTime * 2.0) * 0.5 + 0.5;\n    hslColor.z *= ring; // Modulate lightness for pulsation\n    \n    // Apply noise texture for additional variation\n    vec3 noiseTex = texture(iChannel0, st * 16.0).rgb;\n    hslColor.g += noiseTex.r * 0.2; // Add noise to saturation\n    \n    // Convert HSL color to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_404.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 center = vec2(0.5);\n    vec2 offset = uv - center;\n    float radius = length(offset);\n    float angle = atan2(offset.y, offset.x);\n    \n    // Create expanding circles using time and radius\n    float circle = sin(radius * 10.0 + iTime) * 0.5 + 0.5;\n    \n    // Generate color based on polar coordinates\n    vec3 colorBase = hsl(\n        (radius * 2.0 + iTime) * 4.0,   // Hue: varies with radius and time\n        0.7,                             // Saturation\n        0.5 + circle * 0.5               // Lightness: modulated by circle pattern\n    );\n    \n    // Add noise to create more dynamic color shifts\n    float noiseValue = noise(vec2(radius * 10.0, iTime)) * 0.3;\n    vec3 finalColor = hsl2rgb(\n        vec3(\n            (radius * 2.0 + iTime) * 4.0,\n            0.7 + noiseValue * 0.3,\n            0.5 + circle * 0.5\n        )\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_405.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Convert to polar coordinates for circular patterns\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    \n    // Create pulsating effect using cosine function\n    float pulse = cos(r - iTime * 5.0) + 0.5;\n    \n    // Add noise to create organic variations\n    vec3 noiseFactor = vec3(turbulent(vec3(uv * 10.0, iTime)));\n    pulse *= 1.0 + noiseFactor.x * 0.2;\n    \n    // Create color fading effect based on distance and time\n    float colorFactor = cos(r * 5.0 - iTime) * 0.5 + 0.5;\n    \n    // Generate vibrant colors using HSL\n    vec3 hslColor = hsl(theta * 180.0 / PI, 0.7, 0.6);\n    \n    // Combine all elements to create the final color\n    color = hslColor * pulse * colorFactor;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_406.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates around center\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = iTime * 0.5;\n    st = vec2(\n        cos(angle)*st.x + sin(angle)*st.y,\n        -sin(angle)*st.x + cos(angle)*st.y\n    );\n    // Layered noise with different scales and rotations\n    float n1 = turbulent(st * 4.0) * 0.5;\n    float n2 = turbulent((st * 8.0 + iTime) * 0.5) * 0.3;\n    float n3 = turbulent((st * 16.0 - iTime) * 0.25) * 0.2;\n    // Combine noise layers with time-based modulation\n    float value = sin(n1 + iTime) * 0.5 +\n                  cos(n2 + iTime*0.5) * 0.3 +\n                  sin(n3 - iTime*0.7) * 0.2;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl(\n        fract(iTime * 0.1 + value * 0.5) * PI,\n        0.8 + abs(sin(iTime * 0.3)) * 0.2,\n        0.4 + abs(cos(iTime * 0.2 + value * PI)) * 0.6\n    );\n    return vec4(color, 1.0);\n}"
  },
  "data_407.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern with time-based transformation\n    vec2 center = vec2(0.5, 0.5);\n    float angle = iTime * 0.1;\n    \n    // Transform UV coordinates with rotation and scaling\n    vec2 transformedUV = (uv - center) * mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) + center;\n    \n    // Add some distortion using sine waves\n    transformedUV.x += sin(transformedUV.y * 4.0 * PI + iTime) * 0.3;\n    transformedUV.y += sin(transformedUV.x * 8.0 * PI + iTime) * 0.2;\n    \n    // Calculate distance from center for color transitions\n    float dist = length(transformedUV - center);\n    \n    // Create smooth color transitions using HSL\n    vec3 hslColor = vec3(\n        (dist * 2.0 + iTime) * PI,   // Hue\n        0.7 + noise(uv * 4.0),       // Saturation with some noise variation\n        0.5 + turbulent(transformedUV * 8.0) * 0.3  // Lightness with turbulence\n    );\n    \n    // Convert HSL to RGB and add noise for texture\n    vec3 color = hsl2rgb(hslColor);\n    color *= 1.0 + noise(uv * 4.0 + iTime) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_408.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec3 color = vec3(0.0);\n    \n    // Orb parameters\n    float scale = 10.0;\n    float speed = 0.75;\n    int orbs = 8;\n    \n    for(int i = 0; i < orbs; i++) {\n        // Generate random position using noise\n        vec2 pos = fract(vec2(float(i) * 0.3, time * speed)) * 2.0 - 1.0;\n        pos *= scale;\n        \n        // Calculate distance from current uv to orb center\n        float dist = length(uv - pos);\n        float radius = 0.5 + 0.5 * sin(time + float(i) * 0.3);\n        \n        // Create glowing effect with turbulence\n        float glow = turbulent(vec2(dist, time)) * 0.5 + 0.5;\n        glow = smoothstep(radius - 0.1, radius + 0.1, dist);\n        \n        // Color based on position and time\n        vec3 orbColor = hsl2rgb(vec3(\n            fract(time * 0.1 + float(i) * 0.2) * PI,\n            0.7,\n            0.5 + 0.5 * sin(time + uv.x * 2.0)\n        ));\n        \n        // Add orb to color\n        color += glow * orbColor;\n    }\n    \n    // Add shimmering trail effect\n    vec2 trailUV = uv * scale + time;\n    float trail = turbulent(trailUV) * 0.5 + 0.5;\n    color *= mix(vec3(1.0), hsl2rgb(vec3(time * PI, 1.0, 1.0)), trail * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_409.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern by scaling and tiling the UV coordinates\n    vec2 st = fract(uv * 10.0);\n    \n    // Add rotation effect using time\n    float angle = sin(iTime * 0.5 + 3.1415926) * 0.5;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedSt = rotMatrix * (st - 0.5) + 0.5;\n    \n    // Create square pattern using minimum distance to grid lines\n    float squarePattern = min(rotatedSt.x, rotatedSt.y);\n    squarePattern = min(squarePattern, 1.0 - rotatedSt.x);\n    squarePattern = min(squarePattern, 1.0 - rotatedSt.y);\n    \n    // Generate dynamic color based on time and position\n    vec3 color = hsl(\n        sin(iTime * 0.2 + rotatedSt.x * 5.0) * 0.5 + 0.5,\n        0.7,\n        0.6\n    );\n    \n    // Add noise to create dynamic variations\n    float noiseValue = noise(vec3(rotatedSt, iTime));\n    color *= 1.0 + noiseValue * 0.2;\n    \n    // Combine pattern and color for final output\n    return vec4(color * squarePattern, 1.0);\n}"
  },
  "data_41.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for radial effects\n    vec2 centered = uv - 0.5;\n    float radius = length(centered);\n    float angle = atan2(centered.y, centered.x);\n    \n    // Create pulsating effect using time\n    float pulse = sin(iTime * 0.5 + radius * 10.0) * 0.3;\n    radius += pulse;\n    \n    // Generate color based on angle and radius\n    vec3 color = hsl2rgb(vec3(\n        (angle + iTime) * 0.5 + 0.5,   // Hue varies with angle and time\n        1.0 - radius * 0.8,            // Saturation decreases with distance\n        0.5 + sin(radius * 4.0 + iTime) * 0.3  // Brightness pulsates\n    ));\n    \n    // Add radial motion effect\n    vec2 motion = vec2(\n        sin(angle - iTime) * radius * 0.1,\n        cos(angle + iTime) * radius * 0.1\n    );\n    \n    // Add turbulence for more dynamic effect\n    float turb = turbulent(uv * 4.0 + iTime);\n    color *= 1.0 + turb * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_410.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create mirrored patterns by repeating and reflecting coordinates\n    float mirrors = 8.0;\n    vec2 mirroredUv = mod(uv * mirrors, 1.0);\n    \n    // Reflect every other section\n    mirroredUv.x = mirroredUv.x - (mod(floor(mirroredUv.x), 2.0) == 1.0 ? 1.0 : 0.0);\n    mirroredUv.y = mirroredUv.y - (mod(floor(mirroredUv.y), 2.0) == 1.0 ? 1.0 : 0.0);\n    \n    // Add some turbulence to create dynamic patterns\n    vec3 noiseInput = vec3(mirroredUv * 5.0, iTime * 0.5);\n    float turb = turbulent(noiseInput);\n    \n    // Create shifting hues based on position and time\n    vec3 colorHSL;\n    colorHSL.x = (mirroredUv.x + mirroredUv.y) * 0.5 + iTime * 0.1;\n    colorHSL.y = 0.7 + turb * 0.2; // Add some variation in saturation\n    colorHSL.z = 0.5 + turb * 0.3; // Add some variation in lightness\n    \n    vec3 finalColor = hsl2rgb(colorHSL);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_411.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for spiral effect\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 3.0;\n    \n    // Add time-based rotation and radial movement\n    theta += iTime * 0.5;\n    r += sin(theta + iTime) * 0.5;\n    \n    // Create spiral pattern using HSL colors\n    vec3 baseColor = hsl(theta * 0.5 + iTime, 1.0, 0.5);\n    float noiseValue = noise(vec2(r, theta)) * 0.5 + 0.5;\n    \n    // Mix in noise for texture and variation\n    vec3 finalColor = mix(baseColor, hsl(theta * 0.5 + iTime + noiseValue, 1.0, 0.6), 0.2);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_412.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 fragColor;\n    \n    // Normalize UV coordinates\n    vec2 adjustedUV = (uv - 0.5) * 2.0;\n    float aspectRatio = 16.0/9.0;\n    adjustedUV.x *= aspectRatio;\n    \n    // Time-based animation\n    float time = iTime * 0.5; // Speed control\n    \n    // Create orbiting pattern using polar coordinates\n    vec2 center = vec2(0.5, 0.5);\n    vec2 pos = uv - center;\n    float dist = length(pos);\n    \n    // Dynamic rotation and radius\n    float angle = sin(time * 2.0) * 0.5 + 0.5;\n    vec2 rotatedUV = vec2(\n        cos(angle) * pos.x - sin(angle) * pos.y,\n        sin(angle) * pos.x + cos(angle) * pos.y\n    ) + center;\n    \n    // Create multiple orbiting circles with dynamic radius\n    float pattern = 0.0;\n    for(float i = 0.0; i < 3.0; i++) {\n        float orbitRadius = 0.4 + sin(time + i * 2.094) * 0.15;\n        vec2 offset = vec2(\n            cos(angle + i * 2.094) * 0.3,\n            sin(angle + i * 2.094) * 0.3\n        );\n        pattern += step(orbitRadius, length(rotatedUV - center + offset));\n    }\n    \n    // Color transitions using HSL to RGB conversion\n    vec3 baseColor = hsl(\n        fract(time * 0.1) * 360.0,\n        0.7 + turbulent(vec2(time)) * 0.3,\n        0.5 + sin(time * 0.5) * 0.5\n    );\n    \n    // Add noise and color variations\n    vec3 finalColor = mix(\n        baseColor,\n        hsl(\n            fract(time * 0.15) * 360.0,\n            0.8 + turbulent(rotatedUV) * 0.2,\n            0.6 + sin(time * 0.7) * 0.4\n        ),\n        pattern\n    );\n    \n    // Apply noise texture for additional detail\n    finalColor += vec3(noise(vec3(uv, time))) * 0.3;\n    \n    fragColor = vec4(finalColor, 1.0);\n    return fragColor;\n}"
  },
  "data_413.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Normalize UV coordinates\n    vec2 st = (uv + 1.0) * 0.5;\n    \n    // Create polar coordinates\n    float radius = length(st - 0.5);\n    float angle = atan2(st.y - 0.5, st.x - 0.5);\n    \n    // Animate rotation\n    angle += iTime * 0.1;\n    \n    // Hexagon pattern\n    float hex = sin(6.0 * angle) * 0.5 + 0.5;\n    float pattern = radius * 2.0 < hex ? 1.0 : 0.0;\n    \n    // Cellular noise overlay\n    vec2 noiseUV = st * 4.0; // Scale noise\n    float cellNoise = turbulent(noiseUV);\n    \n    // Combine patterns and add time-based color\n    float finalPattern = pattern * 0.7 + cellNoise * 0.3;\n    vec3 color = hsl2rgb(vec3(sin(iTime) * 0.5 + 0.5, 1.0, finalPattern));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_414.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create hexagonal pattern by tiling the angle space\n    theta = mod(theta + iTime * 0.5, PI * 2.0);\n    float segment = floor(theta / (PI/3.0)) * (PI/3.0);\n    \n    // Pulsing effect based on radius and time\n    float pulse = sin(iTime * 4.0 + r * 10.0) * 0.5 + 0.5;\n    float perturb = noise(vec2(r, iTime)) * 0.3;\n    \n    // Create hexagonal pattern with pulsing effect\n    float d = abs(theta - segment);\n    float c = sin(d * 6.0) * pulse * (1.0 + perturb);\n    \n    // Color calculation using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(theta * 5.0 + iTime, 1.0),   // Hue variation\n        0.7,                              // Saturation\n        0.5 + sin(r * 4.0 - iTime) * 0.5 // Lightness pulsing\n    ));\n    \n    return vec4(color * c, 1.0);\n}"
  },
  "data_415.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float gridSize = 20.0;\n    vec2 cellCoords = floor(uv * gridSize);\n    vec2 cellCenter = (cellCoords + 0.5) / gridSize;\n    \n    // Calculate pulsing intensity using sine waves and time\n    float intensity = sin(iTime * 0.5 + cellCoords.x * 0.1) +\n                     sin(iTime * 0.7 + cellCoords.y * 0.2);\n    intensity = abs(intensity) * 0.5 + 0.5; // Scale to 0-1 range\n    \n    // Add turbulence for more dynamic variation\n    float turbulentFactor = turbulent(cellCenter * 0.1);\n    intensity += turbulentFactor * 0.3;\n    \n    // Convert to color using HSL\n    vec3 color = hsl(\n        iTime * 0.2 + cellCoords.x * 0.1, // Hue variation over time and space\n        0.7, // Saturation\n        intensity * 0.6 + 0.4 // Lightness based on intensity\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_416.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create geometric pattern using sine waves with increasing frequency\n    float pattern = sin(a * 4.0 + iTime * 2.0) * cos(r * 8.0 - iTime);\n    \n    // Add noise and turbulence for more dynamic effect\n    vec3 noisePattern = vec3(\n        noise(vec3(uv * 10.0, iTime)),\n        turbulent(vec2(uv * 5.0 + iTime)),\n        sin(iTime)\n    );\n    \n    // Combine pattern with noise for color transitions\n    float mixValue = (pattern + 0.5) * 0.5 + 0.5;\n    vec3 color1 = hsl2rgb(vec3(0.0, 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.7, 1.0, 0.5));\n    vec3 finalColor = mix(color1, color2, mixValue) * noisePattern;\n    \n    // Create circular mask for geometric effect\n    float mask = smoothstep(0.8, 1.0, r);\n    finalColor *= mask;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_417.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates from 0-1 range to -1 to 1 range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a basic sine wave pattern with time-based animation\n    float waveX = sin(st.x * 5.0 + iTime) * 0.5 + 0.5;\n    float waveY = sin(st.y * 5.0 + iTime * 0.7 + PI) * 0.5 + 0.5;\n    \n    // Combine the waves and add some noise for complexity\n    vec2 wavePattern = vec2(waveX, waveY);\n    float combinedWave = (waveX + waveY) * 0.5;\n    combinedWave += turbulent(st * 10.0 + iTime) * 0.3;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + 0.5),   // Hue cycling over time\n        0.7,                       // Saturation\n        combinedWave * 0.6 + 0.4   // Lightness modulated by wave pattern\n    );\n    \n    // Convert HSL to RGB and mix with noise patterns\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= vec3(\n        sin(waveX * PI) * 0.5 + 0.5,\n        sin(waveY * PI) * 0.5 + 0.5,\n        turbulent(st * 5.0 + iTime) * 0.5 + 0.5\n    );\n    \n    // Final color with alpha\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_418.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create rotating pattern using sine waves\n    float pattern = sin(theta * 4.0 + iTime) * 0.5 + 0.5;\n    pattern += sin(r * 10.0 + theta * 6.0 + iTime) * 0.3;\n    \n    // Generate color shifts using sine waves\n    vec3 color = vec3(\n        sin(theta * 2.0 + iTime * 2.0) * 0.5 + 0.5,\n        sin(theta * 3.0 + iTime * 1.5) * 0.5 + 0.5,\n        sin(theta * 4.0 + iTime * 1.0) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence for more dynamic effect\n    float noiseVal = turbulent(vec3(uv * 10.0, iTime)) * 0.2;\n    color *= sin(r * 8.0 + iTime) * 0.5 + 0.5 + noiseVal;\n    \n    // Mix colors and create final output\n    vec4 finalColor = vec4(color * pattern, 1.0);\n    return finalColor;\n}"
  },
  "data_419.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.1;\n    \n    // Create rotating sine wave patterns with different frequencies\n    vec3 waves = vec3(0.0);\n    \n    // Wave 1: slower rotation, lower frequency\n    float angle1 = atan2(uv.y - 0.5, uv.x - 0.5) + time * 0.5;\n    waves.r += sin(angle1 * 4.0 + time) * 0.3;\n    \n    // Wave 2: faster rotation, higher frequency\n    float angle2 = atan2(uv.y - 0.5, uv.x - 0.5) + time * 1.0;\n    waves.g += sin(angle2 * 8.0 + time * 2.0) * 0.3;\n    \n    // Wave 3: medium rotation, varying frequency\n    float angle3 = atan2(uv.y - 0.5, uv.x - 0.5) + time * 0.75;\n    waves.b += sin(angle3 * 6.0 + time * 1.5) * 0.3;\n    \n    // Combine waves and add noise\n    float pattern = (waves.r + waves.g + waves.b) * 0.5;\n    pattern += noise(uv * 4.0 + time);\n    \n    // Create color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(pattern + time) * 360.0,\n        0.7,\n        0.5 + abs(sin(time)) * 0.5\n    ));\n    \n    return vec4(color * (1.0 + noise(uv * 8.0 + time * 2.0) * 0.5), 1.0);\n}"
  },
  "data_42.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Time-based transformation\n    st.x += sin(iTime) * 0.5;\n    st.y += cos(iTime * 1.5);\n    \n    // Generate noise and turbulence patterns\n    float n = noise(st * 3.1415926);\n    float t = turbulent(vec2(uv * 5.)) * 0.2;\n    \n    // Combine noise and turbulence with time\n    vec3 colorHSL = hsl(n * 0.5 + 0.5, \n                       sin(iTime) * 0.5 + 0.5,\n                       cos(iTime * 0.5) * 0.5 + 0.5);\n    \n    // Mix colors with time-based factors\n    vec3 finalColor = mix(hsl2rgb(colorHSL), hsv2rgb(vec3(sin(n * PI) * 0.5 + 0.5, t * 0.5 + 0.5, cos(iTime) * 0.5 + 0.5)), \n                        sin(iTime * 0.7) * 0.5 + 0.5);\n    \n    // Apply final scaling and mix\n    return vec4(finalColor * (1.0 - abs(sin(st.x * PI)) * 0.2), 1.0);\n}"
  },
  "data_420.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for checkerboard pattern\n    vec2 st = uv * 8.0;\n    \n    // Add time-based movement to the pattern\n    st += sin(iTime * 0.5) * 2.0;\n    \n    // Create a grid of cells using floor and mod functions\n    vec2 cell = floor(st);\n    \n    // Determine if current cell is black or colored based on checkerboard pattern\n    float isBlack = mod(cell.x + cell.y, 2.0);\n    \n    // Calculate color for non-black cells with RGB shifts\n    vec3 color;\n    if (isBlack < 0.5) {\n        // Use HSL colors with time-based hue shift\n        float hue = fract(iTime * 0.1) * 360.0;\n        color = hsl2rgb(vec3(hue, 0.7, 0.8));\n        \n        // Add noise to create variations in color intensity\n        vec2 noisePos = cell.xy * 0.5 + iTime;\n        float n = noise(noisePos) * 0.4 + 0.6;\n        color *= n;\n    } else {\n        // Black cells\n        color = vec3(0.0);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_421.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float a = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Create rotating sine wave pattern\n    float timeMod = iTime * 0.5;\n    float sinVal = sin(r * 10.0 + timeMod) * 0.5 + 0.5;\n    float sinRot = sin(a + timeMod) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        (a / PI + 0.5 + timeMod * 0.1) * 360.0, \n        0.7,\n        sinVal * 0.5 + 0.5\n    );\n    \n    // Convert to RGB and mix with sine rotation\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= sinRot;\n    \n    // Add noise for shimmer effect\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseVal = noise(noiseUV) * 0.5 + 0.5;\n    rgbColor = mix(rgbColor, hsl2rgb(vec3((a / PI + timeMod) * 360.0, 1.0, 1.0)), noiseVal);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_422.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    angle += iTime * 5.0; // Rotation speed\n    \n    // Create hexagonal grid pattern using polar coordinates\n    float theta = fract(angle / (pi/3.0)); // Divide circle into 6 segments\n    float d = radius - mod(theta, 1.0) * 0.2;\n    \n    // Add turbulence for dynamic effect\n    vec2 noisePos = uv + vec2(sin(iTime)*0.5, cos(iTime)*0.5);\n    float turb = turbulent(noisePos * 4.0) * 0.3;\n    turb += turbulent(vec3(uv * 8.0, iTime)) * 0.7;\n    \n    // Create color transitions using HSL\n    vec3 color;\n    color.x = fract(theta + iTime/2.0); // Hue variation over time\n    color.y = 1.0; // Full saturation\n    color.z = 0.5 + turb * 0.5; // Brightness modulation\n    \n    // Convert to RGB and mix with hexagonal pattern\n    vec3 finalColor = hsl2rgb(color) * (1.0 - abs(d)) * 0.8;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_423.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5; // Speed control\n    \n    // Rotate coordinates\n    vec2 rotatedUv;\n    rotatedUv.x = uv.x * cos(time) - uv.y * sin(time);\n    rotatedUv.y = uv.x * sin(time) + uv.y * cos(time);\n    \n    // Add sine wave distortion\n    vec2 distortedUv = rotatedUv;\n    distortedUv.x += sin(rotatedUv.y * 4.0 + time * 2.0) * 0.3;\n    distortedUv.y += sin(rotatedUv.x * 4.0 + time * 1.5) * 0.3;\n    \n    // Add turbulence\n    vec2 finalUv = distortedUv * 0.5 + 0.5;\n    float t = turbulent(finalUv * 8.0);\n    \n    // Color calculation with RGB shifts\n    vec3 color = hsl(\n        sin(time * 0.7) * 0.5 + 0.5, // Hue variation\n        1.0 - abs(turbulent(finalUv * 4.0)), // Saturation\n        0.5 // Lightness\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_424.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 polar = vec2(length(uv), atan2(uv.y, uv.x));\n    \n    // Add time-based rotation\n    float angle = iTime * 0.5;\n    float radius = polar.x;\n    float theta = polar.y + angle;\n    \n    // Create rotating sine wave pattern\n    float wave1 = sin(radius * 5.0 + theta * 3.0);\n    float wave2 = sin(radius * 4.0 + theta * 2.0);\n    \n    // Combine waves with noise for complexity\n    float value = (wave1 + wave2) * 0.5;\n    value += noise(uv * 8.0 + iTime) * 0.3;\n    \n    // Create dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(value * 4.0 + iTime) * 0.5 + 0.5,   // Hue\n        0.7,                                    // Saturation\n        abs(sin(iTime * 0.2)) * 0.5 + 0.5       // Lightness\n    );\n    \n    // Convert to RGB and output\n    vec3 color = hsl2rgb(hslColor);\n    return vec4(color, 1.0);\n}"
  },
  "data_425.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 result;\n    \n    // Create base frequency with time offset\n    float time = iTime * 0.5;\n    \n    // Layered sine waves with varying frequencies and directions\n    float wave1 = sin(uv.x * 8.0 + time) * 0.5;\n    float wave2 = sin(uv.y * 4.0 - time) * 0.3;\n    float wave3 = sin((uv.x + uv.y) * 6.0 + time * 2.0) * 0.2;\n    \n    // Combine waves with varying frequencies\n    float d = wave1 + wave2 + wave3;\n    \n    // Add noise and turbulence for more organic feel\n    vec2 st = uv * 8.0 + time;\n    d += turbulent(st) * 0.1;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(d * 0.5 + 0.5, 0.7, 0.6);\n    color = hsl2rgb(color);\n    \n    // Add depth and glow effect\n    result.rgb = mix(vec3(0.1), color, d * 0.5 + 0.5);\n    result.a = d * 0.5 + 0.5;\n    \n    return result;\n}"
  },
  "data_426.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Time-based color variation\n    float time = iTime * 0.5;\n    \n    // Base color with metallic feel\n    vec3 baseColor = hsl2rgb(vec3(sin(time)*0.6 + 0.5, 0.8, 0.4));\n    \n    // Create noise layers for displacement\n    float scale1 = 4.0;\n    float scale2 = 8.0;\n    vec2 st = uv * scale1;\n    \n    // Add time-based offset to create flow effect\n    st += vec2(time*0.5, time*0.3);\n    \n    // Use turbulent noise for displacement\n    float displacement = turbulent(st * scale1) * 0.5;\n    displacement += turbulent((st + vec2(time)) * scale2) * 0.3;\n    \n    // Create ripple effect with mouse interaction\n    vec2 mousePos = vec2(0.5, 0.5); // Simulated mouse position\n    float distanceToMouse = length(uv - mousePos);\n    displacement += (1.0 - smoothstep(0.2, 0.8, distanceToMouse)) * 0.3;\n    \n    // Displace UV coordinates based on noise\n    vec2 displacedUV = uv + displacement * 0.1;\n    displacedUV = mod(displacedUV, 1.0);\n    \n    // Add metallic sheen effect\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));\n    vec3 normal = normalize(vec3(\n        turbulent(uv * scale1 + time) * 2.0 - 1.0,\n        turbulent((uv + vec2(time)) * scale2) * 2.0 - 1.0,\n        1.0\n    ));\n    float specular = pow(max(dot(normal, lightDir), 0.0), 32.0);\n    \n    // Combine effects\n    vec3 finalColor = mix(\n        baseColor,\n        hsl2rgb(vec3(sin(time)*0.6 + 0.5, 0.8, 0.6)),\n        abs(displacement) * 0.5\n    );\n    finalColor += specular * 0.4;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_427.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Base noise position\n    vec2 pos = uv * 5.0 + iTime;\n    float n = noise(pos);\n    \n    // Multiple layers of particles\n    for(float i = 1.0; i <= 4.0; i++) {\n        // Particle scale and position\n        float scale = pow(0.5, i);\n        vec2 st = uv * (i + 3.0) + iTime * scale;\n        \n        // Complex noise with time variation\n        vec3 noisePos = vec3(st.x, st.y, iTime * 0.1);\n        float t = turbulent(noisePos);\n        \n        // Color based on position and time\n        vec3 hue = hsl2rgb(vec3(\n            fract(iTime * 0.1 + t) * 0.6 + 0.2,\n            0.7 + sin(iTime * 0.5 + t) * 0.3,\n            0.8 + cos(iTime * 0.3 + t) * 0.2\n        ));\n        \n        // Particle shape and glow\n        float d = length(uv - vec2(0.5, 0.5)) * scale;\n        float glow = exp(-d * 4.0);\n        \n        // Additive blending\n        color += hue * glow * (1.0 + sin(iTime + t) * 0.5);\n    }\n    \n    // Final color correction and gamma\n    return vec4(pow(color, vec3(0.7)), 1.0);\n}"
  },
  "data_428.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create rotating hexagonal pattern\n    theta -= 0.5 * iTime; // Rotate over time\n    \n    // Hexagon tiling\n    theta = mod(theta, pi/3.0);\n    theta = abs(theta - pi/6.0);\n    \n    // Create pulsating color effect\n    float hue = (theta + r) / (pi/3.0);\n    hue += 0.5 * sin(iTime * 2.0 + theta * 4.0);\n    \n    // Add turbulence for dynamic effect\n    vec3 noisePos = vec3(uv * 10.0, iTime * 0.5);\n    float turb = turbulent(noisePos) * 0.5;\n    \n    // Combine color and noise effects\n    vec3 color = hsl(hue + turb, 0.7 + 0.3*sin(iTime), 0.5 + 0.5*r);\n    \n    // Create hexagonal rings\n    float ring1 = step(0.3, r) * (1.0 - step(0.5, r));\n    float ring2 = step(0.6, r);\n    \n    color *= mix(vec3(1.0), vec3(0.8, 0.9, 1.0), ring1 + ring2);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_429.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of points scaled by UV coordinates\n    vec2 st = uv * 10.0;\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 1.5; // Add time-based rotation\n    \n    // Create a triangular pattern using sine wave\n    float triangle = sin(theta * 3.0 + iTime) * 0.5 + 0.5;\n    \n    // Create a mask for the triangles\n    float mask = smoothstep(0.7, 1.0, abs(triangle));\n    \n    // Add color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        (theta * 0.15 + iTime) * 360.0,\n        0.8,\n        0.7\n    ));\n    \n    // Mix in some noise for extra variation\n    float n = noise(vec2(r, theta)) * 0.1;\n    mask += n;\n    \n    // Final color output\n    return vec4(color * mask, 1.0);\n}"
  },
  "data_43.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = hsv2rgb(vec3(\n        atan2(sin(iTime * 2.0), cos(iTime * 1.5)) / (pi * 2.0),\n        0.7 + noise(uv * 5.0 + iTime * 0.5) * 0.3,\n        0.8 + turbulent(vec2(uv * 10.0 - iTime * 0.2)) * 0.2\n    ));\n    \n    float brightness = 0.7 + noise(vec2(iTime * 0.1)) * 0.3;\n    color *= vec3(brightness);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_430.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying frequency and phase offset for the waves\n    float freq = 5.0;\n    float speed = 0.3;\n    float time = iTime * speed;\n    \n    // Generate two sets of sine waves with different frequencies and phases\n    vec2 wave1 = sin(uv * freq + time) * 0.5 + 0.5;\n    vec2 wave2 = sin((uv + time/4.0) * freq * 0.7 + time*2.0) * 0.5 + 0.5;\n    \n    // Combine the waves and add turbulence\n    vec2 combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(uv * 4.0 + time) * 0.3;\n    \n    // Create a color palette using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.6 + time*0.1, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.2 + time*0.15, 0.7, 0.8));\n    \n    // Mix the colors based on the wave patterns\n    vec3 finalColor = mix(color1, color2, combined.x * 0.6 + 0.4);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_431.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create multiple layered sine waves with different frequencies\n    float wave1 = sin(st.x * 3.0 + iTime) * 0.5 + 0.5;\n    float wave2 = sin(st.y * 4.0 + iTime * 2.0) * 0.5 + 0.5;\n    float wave3 = sin((st.x + st.y) * 5.0 + iTime * 3.0) * 0.5 + 0.5;\n    \n    // Combine waves with different weights\n    float combined = wave1 * 0.4 + wave2 * 0.3 + wave3 * 0.3;\n    \n    // Add noise for extra detail\n    vec2 noiseUV = uv * 64.0;\n    float n = noise(noiseUV) * 0.2;\n    combined += n;\n    \n    // Create color from combined value and time\n    vec3 color = hsl(combined * 0.7 + iTime, 1.0, 0.5);\n    \n    return vec4(hsv2rgb(color), 1.0);\n}"
  },
  "data_432.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create rotating geometric pattern using sine waves\n    vec3 color = hsl2rgb(vec3(\n        sin(theta) * 0.5 + 0.5,   // Hue variation\n        1.0,                      // Full saturation\n        0.5                       // Mid lightness\n    ));\n    \n    // Add pulsating effect based on time and radius\n    float pulse = sin(iTime * 2.0 + radius * 8.0) * 0.5 + 0.5;\n    color *= pulse;\n    \n    // Add noise texture with dynamic scaling\n    vec3 noise1 = vec3(noise(vec2(theta, iTime)));\n    vec3 noise2 = vec3(noise(vec2(radius * 50.0, iTime * 2.0)));\n    color += (noise1 + noise2) * 0.3;\n    \n    // Add geometric interference pattern\n    float pattern = sin(theta * 4.0) * cos(radius * 20.0);\n    color += vec3(pattern * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_433.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += iTime * 0.5;\n    // Create kaleidoscopic effect by repeating angles\n    theta = mod(theta, PI/3.0);  // Creates 6-pointed symmetry\n    \n    // Add turbulence to create dynamic patterns\n    float noise1 = turbulent(vec2(r*0.5 + iTime*0.2, theta));\n    float noise2 = turbulent(vec3(r*0.7 - iTime*0.3, theta, r*0.5));\n    // Create color transitions using HSL\n    vec3 color;\n    color.r = sin(theta * 4.0 + iTime) * 0.5 + 0.5;\n    color.g = cos(r * 2.0 - iTime) * 0.5 + 0.5;\n    color.b = noise1 * 0.5 + 0.5;\n    // Apply turbulence to color\n    color *= vec3(noise2 * 0.6 + 0.4);\n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_434.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create orbiting pattern with time-based movement\n    a += iTime * 0.5;\n    r = abs(r * 3.0 + sin(iTime) * 2.0);\n    \n    // Add noise and turbulence for dynamic effect\n    vec2 noisePos = uv * 10.0 + vec2(sin(iTime), cos(iTime)) * 5.0;\n    float noiseVal = noise(noisePos);\n    r += noiseVal * 0.3;\n    // Create chromatic aberration effect\n    vec3 color;\n    color.r = hsl(r + a * 0.5, 0.7, 0.6).r;\n    color.g = hsl(r + a * 0.5 + 0.2, 0.7, 0.6).g;\n    color.b = hsl(r + a * 0.5 - 0.2, 0.7, 0.6).b;\n    // Add dynamic color shifts\n    color *= vec3(1.0, 1.0, 1.0) + sin(iTime + vec3(0.0, 2.0, 4.0)) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_435.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float angle = sin(iTime * 0.5) + 1.0;\n    vec2 rotatedUv = vec2(\n        uv.x * cos(angle) - uv.y * sin(angle),\n        uv.x * sin(angle) + uv.y * cos(angle)\n    ) * 2.0;\n    // Create a base noise pattern with time offset\n    float noise1 = noise(vec3(rotatedUv * 100.0, iTime));\n    float noise2 = noise(vec3(rotatedUv * 50.0 + vec2(123.456), iTime * 0.7));\n    // Create turbulence pattern\n    float turb = turbulent(rotatedUv * 10.0);\n    \n    // Combine patterns with color transformations\n    vec3 color1 = hsl2rgb(vec3(\n        mod(iTime + noise1, 1.0) * 360.0,\n        0.7,\n        0.5 + turb * 0.5\n    ));\n    \n    vec3 color2 = hsl2rgb(vec3(\n        mod(iTime + noise2, 1.0) * 360.0,\n        0.8,\n        0.4 + abs(sin(iTime)) * 0.6\n    ));\n    // Mix colors based on patterns\n    vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, noise(rotatedUv)));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_436.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates relative to center\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal pattern using multiple octaves of sine waves\n    float d = 0.0;\n    for(float i = 1.0; i <= 4.0; i++) {\n        float freq = pow(2.0, i);\n        a += sin(a * freq + iTime) * 0.5 / i;\n        d += sin(r * freq * 3.0 + a * 6.0) * 0.5 / i;\n    }\n    // Add time-based rotation\n    a += iTime * 0.2;\n    // Create pulsating color effect using HSL\n    vec3 col = hsl(\n        mod(a * 4.0 + iTime, 1.0),   // Hue variation over time and angle\n        0.7 + turbulent(vec3(r, a, iTime)) * 0.3,  // Saturation with turbulence\n        0.5 + sin(iTime) * 0.5       // Brightness pulsation\n    );\n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(col), 1.0);\n}"
  },
  "data_437.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    vec2 center = vec2(0.5);\n    float angle = iTime * 0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedUV = (uv - center) * rot + center;\n    // Create radial waves pattern\n    vec2 uv_centered = rotatedUV - center;\n    float dist = length(uv_centered);\n    \n    // Multiple wave frequencies with time-based animation\n    float wave1 = sin(dist * 8.0 + iTime * 3.0) * 0.5;\n    float wave2 = sin(dist * 16.0 + iTime * 4.0) * 0.3;\n    float wave3 = sin(dist * 32.0 + iTime * 5.0) * 0.2;\n    \n    // Combine waves and add turbulence\n    float value = (wave1 + wave2 + wave3) * 0.5;\n    value += turbulent(rotatedUV * 4.0) * 0.2;\n    // Convert to HSL color with smooth transitions\n    vec3 hslColor = vec3(\n        mod(value * 6.0 + iTime, 1.0),  // Hue\n        0.7 + abs(sin(iTime * 0.5)) * 0.3,  // Saturation\n        0.5 + value * 0.4  // Lightness\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_438.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern with time-based movement\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = iTime * 0.5;\n    mat2 rot = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 rotatedUV = rot * st;\n    // Add turbulence and noise layers\n    float t = turbulent(rotatedUV * 4.0 + iTime);\n    float n1 = noise(rotatedUV * 8.0 + iTime) * 0.5;\n    float n2 = noise(rotatedUV * 16.0 + iTime + 1.0) * 0.3;\n    \n    // Create color shifts using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.1 + rotatedUV.x * 0.5, 1.0),\n        0.7,\n        0.6 + t * 0.2\n    );\n    \n    // Combine noise layers and colors\n    float finalNoise = (n1 + n2) * 0.8;\n    vec3 color = hsl2rgb(hslColor);\n    color *= sin(iTime * 0.5 + rotatedUV.y * 4.0) * 0.5 + 0.5;\n    \n    // Add geometric pattern overlay\n    float pattern = abs(sin(rotatedUV.x * 8.0)) * abs(cos(rotatedUV.y * 8.0));\n    color = mix(color, vec3(1.0), pattern * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_439.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    float time = iTime * 0.5;\n    \n    // Create orbiting motion using sine and cosine functions\n    vec2 center = vec2(sin(time * 0.7), cos(time * 0.6)) * 0.4 + uv;\n    \n    // Add multiple layers of orbiting polygons\n    for(float i = 0.0; i < 3.0; i++) {\n        float angle = time * (i + 1.0) + i * PI;\n        vec2 pos = center + vec2(sin(angle), cos(angle)) * 0.5;\n        \n        // Create pulsating color effect\n        vec3 hslColor = vec3(\n            fract(time * 0.2 + i * 0.333),\n            1.0,\n            0.5 + 0.5 * sin(time + angle)\n        );\n        vec3 rgbColor = hsl2rgb(hslColor);\n        \n        // Add noise and turbulence for dynamic effect\n        float noiseVal = turbulent(pos * 4.0) * 0.5 + 0.5;\n        color += rgbColor * noiseVal;\n    }\n    \n    // Apply final color transformations\n    color *= vec3(1.0, 0.8, 0.6); // Add some warmth to colors\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_44.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    // Create interweaving sine patterns with dynamic scaling\n    float scale = sin(iTime) * 0.5 + 0.5;\n    float pattern1 = sin(theta * 3.0 - iTime) * scale;\n    float pattern2 = sin(theta * 5.0 + iTime) * scale;\n    // Combine patterns and create color\n    float value = (sin(r * 4.0 + pattern1 * 2.0) + sin(r * 6.0 + pattern2 * 2.0)) / 2.0;\n    \n    // Create shifting hues using HSL\n    float hue = iTime * 2.0 + theta * 3.0;\n    vec3 color = hsl2rgb(vec3(hue, 1.0, 0.5 + sin(iTime) * 0.5));\n    return vec4(color * (value * 0.5 + 0.5), 1.0);\n}"
  },
  "data_440.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position based on time\n    vec2 st = uv * 5.0 + sin(iTime * 0.3) * 1.5;\n    \n    // Create flowing pattern using sine functions\n    vec2 flow = sin(st + iTime) * 0.5 + 0.5;\n    \n    // Generate base color with dynamic hue\n    vec3 color = hsl2rgb(vec3(\n        mod(length(flow) * 180.0 + iTime * 60.0, 360.0),\n        0.7,\n        0.5\n    ));\n    \n    // Add noise and turbulence for detail\n    float noise1 = noise(st + vec2(iTime)) * 0.5;\n    float noise2 = turbulent(vec3(st, iTime * 0.2)) * 0.3;\n    \n    // Combine elements with smooth transitions\n    color += sin(length(flow) * 8.0 + iTime) * 0.4;\n    color *= mix(1.0, sin(noise1 * pi), noise2);\n    \n    // Add pulsing effect\n    float pulse = sin(iTime * 0.5) * 0.3 + 0.7;\n    color *= pulse;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_441.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and rotate coordinates\n    vec2 st = uv - 0.5;\n    float time = iTime * 0.5;\n    \n    // Apply rotation\n    st = mat2(cos(time), sin(-time),\n              sin(time), cos(time)) * st;\n    // Create hexagonal pattern using polar coordinates\n    vec2 polar = vec2(length(st), atan2(st.y, st.x));\n    float r = polar.x;\n    float theta = polar.y;\n    \n    // Generate geometric pattern with noise\n    float pattern = cos(theta * 6.0 + time) * 0.5 + 0.5;\n    pattern += cos(theta * 3.0 + time * 2.0) * 0.3;\n    pattern = smoothstep(0.4, 0.6, pattern);\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(time * 0.1 + theta / (2.0 * PI)) * 360.0,\n        0.7,\n        0.5 + 0.5 * sin(time + r * 4.0)\n    );\n    \n    // Convert to RGB and add noise\n    vec3 color = hsl2rgb(hslColor) * (0.5 + 0.5 * noise(st * 10.0 + time));\n    \n    // Add pulsing outer ring\n    float pulse = smoothstep(0.8, 1.0, r);\n    color *= 1.0 - pulse;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_442.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate UV coordinates over time\n    vec2 st = uv * 5.0 + vec2(iTime, iTime*0.5);\n    \n    // Create moving sine patterns\n    float pattern1 = sin(st.x + iTime) * 0.5 + 0.5;\n    float pattern2 = sin(st.y + iTime*0.7 + 3.14159) * 0.5 + 0.5;\n    \n    // Mix patterns with noise\n    vec2 noiseSt = uv * 10.0 + vec2(iTime, iTime);\n    float noiseVal = noise(noiseSt);\n    \n    // Create RGB transitions using HSL\n    vec3 colorHSL = vec3(0.5 + sin(iTime)*0.4, 0.7, 0.8);\n    vec3 colorRGB = hsl2rgb(colorHSL);\n    \n    // Combine patterns and noise with color\n    float finalPattern = pattern1 * pattern2 + noiseVal * 0.3;\n    vec3 finalColor = mix(colorRGB, vec3(finalPattern), 0.5);\n    \n    // Add gamma correction for better contrast\n    finalColor = pow(finalColor, vec3(0.7));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_443.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    float noiseValue = noise(vec2(uv.x * 10.0 + sin(time), uv.y * 10.0 + cos(time)));\n    \n    vec3 color;\n    color.r = sin(uv.x * 10.0 + time) * 0.5 + 0.5;\n    color.g = sin(uv.y * 10.0 + time + 2.0) * 0.5 + 0.5;\n    color.b = sin((uv.x + uv.y) * 10.0 + time + 4.0) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_444.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create a rotating grid pattern\n    vec2 grid = floor((uv + sin(iTime) * 0.5) * 4.0);\n    vec2 cellCenter = (grid + 0.5) / 4.0;\n    \n    // Calculate distance from center of nearest square\n    float dist = length(uv - cellCenter);\n    \n    // Create rotating squares using angle offset\n    theta += iTime * 0.5 + sin(grid.x * PI) * 0.5;\n    \n    // Use turbulence to add variation\n    float turb = turbulent(vec2(theta, r));\n    \n    // Create color transitions based on position and time\n    vec3 color = hsl2rgb(vec3(\n        (theta + iTime) * 0.1,\n        1.0,\n        0.5 + 0.5 * sin(iTime + theta)\n    ));\n    \n    // Combine effects to create final output\n    return vec4(color, 1.0);\n}"
  },
  "data_445.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotatedUV = vec2(\n        uv.x * cos(t) - uv.y * sin(t),\n        uv.x * sin(t) + uv.y * cos(t)\n    );\n    \n    // Create polar coordinates\n    vec2 polar = vec2(length(rotatedUV), atan2(rotatedUV.y, rotatedUV.x));\n    float angle = polar.y + t;\n    \n    // Generate noise patterns\n    float noise1 = noise(vec3(polar.x * 5.0, angle * 5.0, t));\n    float noise2 = turbulent(vec2(angle * 2.0, polar.x * 2.0));\n    \n    // Create color variations\n    vec3 color1 = hsl2rgb(vec3((angle + t) * 0.5, 0.7, 0.6));\n    vec3 color2 = hsl2rgb(vec3((polar.x + t) * 0.5, 0.8, 0.7));\n    \n    // Combine patterns and colors\n    vec3 finalColor = mix(color1, color2, noise1);\n    finalColor *= sin(polar.x * 4.0 + t) * 0.5 + 0.5;\n    finalColor += noise2 * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_446.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x) + iTime * 0.5;\n    \n    // Create rotating sine waves with different frequencies for each color channel\n    float red = sin(theta * 4.0 + iTime) * 0.5 + 0.5;\n    float green = sin(theta * 2.0 + iTime * 0.7 + PI) * 0.5 + 0.5;\n    float blue = sin(theta + iTime * 1.3 + PI*2.0) * 0.5 + 0.5;\n    \n    // Add some turbulence to create dynamic movement\n    vec3 noisePos = vec3(uv * 10.0, iTime * 0.1);\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    \n    // Combine the sine waves with turbulence and color shifts\n    vec3 color = vec3(\n        red * (1.0 - turb) + blue * turb,\n        green * (1.0 - turb) + red * turb,\n        blue * (1.0 - turb) + green * turb\n    );\n    \n    // Convert to RGB and scale by distance from center\n    color = hsl2rgb(vec3(color.r, color.g, color.b)) * (1.0 - r * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_447.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Hexagonal grid pattern with pulsation\n    float hex = sin(theta * 6.0 + iTime) / r;\n    float pulse = sin(iTime * 0.5 + r * 2.0) * 0.5 + 0.5;\n    float pattern = (hex * 0.5 + 0.5) * pulse;\n    \n    // Color transitions with noise\n    vec3 color1 = hsl(r * 0.5 + iTime, 0.7, 0.6);\n    vec3 color2 = hsl(theta * 0.5 + iTime, 0.7, 0.4);\n    vec3 finalColor = mix(color1, color2, turbulent(vec2(st.x * 0.5, st.y * 0.5)));\n    \n    // Motion blur effect\n    float motionBlur = turbulent(vec2(uv.x + iTime * 0.1, uv.y));\n    finalColor = mix(finalColor, vec3(0.0), motionBlur * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_448.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create expanding square pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float d = length(abs(st.x) + abs(st.y));\n    \n    // Add pulsating effect using time\n    float t = iTime * 0.5;\n    float pulse = mod(t, PI);\n    float dist = d + sin(pulse) * 0.5;\n    \n    // Create color transitions\n    vec3 color1 = hsl2rgb(vec3(0.0, 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.666, 1.0, 0.5));\n    vec3 color3 = hsl2rgb(vec3(0.333, 1.0, 0.5));\n    \n    // Mix colors based on distance and time\n    float mixAmount = (sin(t) + 1.0) * 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    finalColor = mix(finalColor, color3, noise(vec3(uv * 4.0, t)) * 0.5);\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(uv * 2.0, t));\n    finalColor *= (1.0 + sin(turb * PI) * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_449.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float a = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Create swirling pattern using sine waves and time\n    a += sin(a * 5.0 + iTime) * 0.2;\n    a += iTime * 0.1; // Add time-based rotation\n    \n    // Generate color transitions based on angle and radius\n    vec3 color = hsl(\n        sin(iTime * 0.5 + a * 4.0) * 0.5 + 0.5, // Hue variation over time\n        0.7, // Saturation\n        0.5 // Lightness\n    );\n    \n    // Add turbulence for more dynamic patterns\n    vec3 noisePattern = vec3(turbulent(vec3(uv * 10.0, iTime)));\n    color = mix(color, noisePattern, 0.2);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_45.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 p = vec3(uv * 2.0 - 1.0, iTime * 0.5);\n    float n = noise(p.xy) + turbulent(p);\n    n *=8.0;\n    \n    vec3 color = hsl(n, 0.8, 0.7);\n    \n    return vec4(color , 1.0) ;\n}"
  },
  "data_450.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += iTime * 0.5;\n    // Create a pattern using sine waves and noise\n    float pattern = sin(r * 8.0 + theta) * 0.5 + 0.5;\n    pattern *= turbulent(vec2(theta, r)) * 0.5 + 0.5;\n    // Generate pulsating colors using HSL\n    vec3 color = hsl2rgb(vec3(\n        (theta * 0.5 + iTime) * 180.0 / PI,\n        1.0,\n        0.5\n    ));\n    // Combine pattern with color and noise\n    vec3 finalColor = mix(color, vec3(0.0), pattern);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_451.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create multiple rotating points around center\n    const int numPoints = 8;\n    float angleStep = pi * 2.0 / float(numPoints);\n    \n    vec3 color = vec3(0.0);\n    for(int i = 0; i < numPoints; i++) {\n        float angle = a + float(i) * angleStep + iTime * 0.5;\n        vec2 pointPos = vec2(cos(angle), sin(angle)) * 0.7;\n        \n        // Calculate distance from current point\n        float dist = length(st - pointPos);\n        \n        // Create rotating color patterns\n        float hue = (angle + a) * 0.5 + iTime * 0.1;\n        vec3 hslColor = vec3(hue, 1.0, 0.5);\n        vec3 rgbColor = hsl2rgb(hslColor);\n        \n        // Add turbulence for dynamic effect\n        float turb = turbulent(vec3(st.x, st.y, iTime * 0.1));\n        dist += turb * 0.1;\n        \n        // Mix colors based on distance and angle\n        color += rgbColor * smoothstep(0.2, 0.0, abs(dist - 0.4)) *\n                 (1.0 + sin(a * 3.0 + iTime * 2.0)) * 0.5;\n    }\n    \n    // Final color with noise overlay\n    float finalDist = length(st);\n    vec3 finalColor = mix(vec3(0.0), color, smoothstep(0.9, 1.0, r));\n    finalColor += noise(vec2(a, iTime)) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_452.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating sine wave pattern\n    vec2 st = uv * 5.0; // Scale coordinates for more detail\n    float time = iTime * 0.5; // Slow down the animation\n    \n    // Convert to polar coordinates\n    vec2 polar = vec2(\n        length(st - 0.5), \n        atan2(st.y - 0.5, st.x - 0.5)\n    );\n    \n    // Create rotating sine wave pattern with color shifts\n    float pattern = sin(polar.x * 10.0 + time) * cos(polar.y + time);\n    pattern += sin(polar.x * 5.0 + time * 2.0) * sin(polar.y * 3.0 + time);\n    \n    // Add turbulence for more dynamic effect\n    vec2 noiseUV = uv * 100.0;\n    float turb = turbulent(noiseUV);\n    pattern += turb * 0.5;\n    \n    // Create RGB color shifts using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        fract(time * 0.2 + uv.x) * 360.0, \n        1.0, \n        0.5 + turb * 0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine pattern with color shifts\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(pattern),\n        abs(sin(time)) * 0.5 + 0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_453.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequency components\n    float time = iTime * 0.5;\n    vec3 freqs = vec3(1.0, 1.5, 2.0);\n    \n    // Generate sine wave patterns with noise modulation\n    float wave1 = sin(uv.x * freqs.x + time) * \n                  sin(uv.y * freqs.x + time * 0.7) *\n                  noise(vec3(uv * 4.0, time));\n                  \n    float wave2 = sin(uv.x * freqs.y + time * 0.9) *\n                  sin(uv.y * freqs.y + time * 0.5) *\n                  noise(vec3(uv * 6.0, time)); \n                  \n    // Combine waves with turbulence\n    float combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(vec3(uv * 8.0, time)) * 0.4;\n    \n    // Create rotating RGB gradient\n    vec3 color = hsl(\n        mod(combined * 0.5 + time, 1.0),  // Rotating hue\n        0.7,                               // Saturation\n        0.5 + noise(vec2(uv * 4.0)) * 0.3 // Lightness variation\n    );\n    \n    // Add noise texture overlay\n    vec4 noiseTex = texture(iChannel0, uv * 8.0);\n    color = mix(color, noiseTex.rgb, 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_454.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 fragColor;\n    \n    // Create rotating pattern using time\n    float rot = sin(iTime * 0.5);\n    vec2 rotatedUV = vec2(\n        uv.x * cos(rot) - uv.y * sin(rot),\n        uv.x * sin(rot) + uv.y * cos(rot)\n    );\n    \n    // Add noise and turbulence\n    float t = turbulent(rotatedUV * 10.0);\n    \n    // Create sine wave pattern with time offset\n    float wave = sin(uv.x * 5.0 + iTime) * 0.5 + 0.5;\n    vec2 displacedUV = rotatedUV + vec2(0.0, wave * 0.5);\n    \n    // Dynamic color transitions using HSL\n    float h = 0.5 + t * 0.5;\n    float s = 1.0 - abs(sin(iTime)) * 0.5;\n    float l = mix(0.3, 0.7, wave);\n    vec3 color1 = hsl2rgb(vec3(h, s, l));\n    \n    // Secondary color layer\n    float h2 = h + 0.5;\n    float s2 = s * 0.8;\n    float l2 = l * 0.9;\n    vec3 color2 = hsl2rgb(vec3(h2, s2, l2));\n    \n    // Combine colors based on sine wave pattern\n    fragColor = vec4(mix(color1, color2, wave), 1.0);\n    \n    return fragColor;\n}"
  },
  "data_455.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using polar coordinates\n    float angle = atan2(uv.y, uv.x) + iTime * 0.5;\n    float radius = length(uv);\n    \n    // Generate color shifts using HSL colors\n    vec3 color1 = hsl(angle * 0.1 + iTime * 0.2, 0.6, 0.7);\n    vec3 color2 = hsl(angle * 0.15 - iTime * 0.3, 0.5, 0.8);\n    \n    // Add noise and turbulence for dynamic effect\n    float noise1 = turbulent(vec2(uv.x * 4.0 + iTime, uv.y * 4.0));\n    float noise2 = turbulent(vec3(uv * 6.0 + vec2(iTime), iTime * 0.5));\n    \n    // Combine colors and noise\n    vec3 finalColor = mix(color1, color2, abs(noise1 * 0.5 + 0.5)) * (0.8 + noise2 * 0.2);\n    \n    // Add radial glow effect\n    float glow = smoothstep(0.7, 0.9, radius) * (1.0 - length(uv));\n    finalColor += vec3(glow * 0.4);\n    \n    return vec4(hsl2rgb(finalColor), max(glow, 0.2));\n}"
  },
  "data_456.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create pulsating effect using time and radius\n    float pulse = sin(iTime * 0.5 + r * 3.0) * 0.5 + 0.5;\n    float speed = 1.0 + sin(iTime * 0.2) * 0.5;\n    // Add noise and turbulence for more dynamic effect\n    vec3 noisePos = vec3(st.x, st.y, iTime * speed);\n    float noiseVal = turbulent(noisePos * 4.0) * 0.5 + 0.5;\n    \n    // Create color gradients using HSL\n    float hue = theta / (2.0 * PI) + 0.5 * sin(iTime * 0.3 + r * 10.0);\n    vec3 hslColor = vec3(hue, 0.7, noiseVal * pulse);\n    // Convert to RGB and apply radial falloff\n    vec3 color = hsl2rgb(hslColor) / (r * r + 0.5);\n    return vec4(color, 1.0);\n}"
  },
  "data_457.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create smooth undulating waves using sine functions combined with time\n    float wave1 = sin(uv.x * 20.0 + iTime * 2.0);\n    float wave2 = sin((uv.y - 0.5) * 10.0 + iTime * 0.5);\n    \n    // Add turbulence for more dynamic movement\n    vec3 noisePos = vec3(uv * 10.0, iTime * 0.1);\n    float turb = turbulent(noisePos);\n    \n    // Combine waves and turbulence with color transitions\n    float v = sin(wave1 + wave2 + turb) * 0.5 + 0.5;\n    \n    // Create vibrant color transitions using HSL\n    vec3 hslColor = vec3(v * 360.0, 0.7, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_458.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create dynamic sine wave parameters\n    float time = iTime * 0.5;\n    \n    // Wave 1 parameters\n    vec2 w1_pos = uv + vec2(sin(time + uv.x * 2.0) * 0.5, 0.0);\n    float w1_amp = 0.3 + turbulent(w1_pos * 4.0 + time) * 0.3;\n    float w1_speed = 1.0 + sin(time * 2.0) * 0.5;\n    \n    // Wave 2 parameters\n    vec2 w2_pos = uv + vec2(0.0, sin(time + uv.y * 2.0) * 0.5);\n    float w2_amp = 0.3 + turbulent(w2_pos * 4.0 + time + PI) * 0.3;\n    float w2_speed = 1.0 + cos(time * 2.0) * 0.5;\n    \n    // Combine waves with noise modulation\n    float wave1 = sin((w1_pos.x * 8.0 + time * w1_speed) + uv.y * PI) * w1_amp;\n    float wave2 = sin((w2_pos.y * 8.0 + time * w2_speed) + uv.x * PI) * w2_amp;\n    \n    // Mix waves with noise\n    float mixAmount = noise(vec3(uv * 4.0, time)) * 0.5 + 0.5;\n    float finalWave = mix(wave1, wave2, mixAmount);\n    \n    // Create color from HSL values\n    vec3 color = hsl(\n        (uv.x + uv.y + time) * 0.5,\n        0.7 + turbulent(uv * 4.0 + time) * 0.3,\n        0.5 + finalWave * 0.5\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_459.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 rgb = vec3(0.0);\n    \n    // Create rotating spectral patterns\n    float time = iTime * 0.5;\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + time;\n    \n    // Add pulsing noise trails\n    float trail1 = turbulent(vec3(uv * 4.0, time)) * 0.5 + 0.5;\n    float trail2 = turbulent(vec3(uv * 8.0, time * 0.7)) * 0.5 + 0.5;\n    \n    // Create swirling color patterns\n    rgb.r += sin(theta * 4.0 + time) * r * 0.1 + noise(vec2(time * 0.3, uv.x));\n    rgb.g += cos(theta * 3.0 - time) * r * 0.1 + noise(vec2(uv.y, time * 0.5));\n    rgb.b += sin(theta * 2.0 + time * 0.8) * r * 0.1 + noise(vec3(uv, time));\n    \n    // Add glowing trails\n    rgb += vec3(trail1 * 0.4, trail2 * 0.3, (trail1 + trail2) * 0.2);\n    \n    // Create ethereal void effect\n    float d = length(uv - 0.5);\n    if (d > 0.98) {\n        rgb += vec3(0.1, 0.1, 0.2) * sin(time * 0.5 + d * 10.0);\n    }\n    \n    // Add color transformation\n    rgb = hsl2rgb(vec3(hsl(theta * 0.1 + time, 0.8, 0.6)));\n    \n    return vec4(rgb, 1.0);\n}"
  },
  "data_46.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using time-based rotation\n    float t = iTime * 0.5;\n    mat2 rot = mat2(cos(t), -sin(t), sin(t), cos(t));\n    vec2 st = uv * 10.0; // Scale coordinates for more detail\n    \n    // Add turbulence to create fractal-like patterns\n    float turb = turbulent(rot * st);\n    \n    // Create color variations using trigonometric functions\n    float c1 = sin(st.x * 0.5 + t) * cos(st.y * 0.5);\n    float c2 = cos(st.x * 0.3 - t) * sin(st.y * 0.4);\n    \n    // Combine turbulence with color variations\n    vec3 hslColor = vec3(\n        turb * 0.5 + 0.5, // Hue\n        abs(c1) * 0.7 + 0.3, // Saturation\n        abs(c2) * 0.6 + 0.4 // Lightness\n    );\n    \n    // Convert HSL to RGB and add time-based color shifting\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= sin(iTime * 0.2 + vec3(0.0, 1.0, 2.0)) * 0.5 + 0.5;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_460.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 50.0;\n    \n    // Get integer and fractional parts of scaled coordinates\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Calculate distance from diagonal lines\n    float d1 = abs(fpos.x + fpos.y - 0.5) * sqrt(2.0);\n    float d2 = abs(fpos.x - fpos.y) * sqrt(2.0);\n    \n    // Combine distances and add time-based offset\n    float dist = min(d1, d2);\n    dist += sin(iTime * 0.5 + ipos.x + ipos.y) * 0.3;\n    \n    // Add noise for shimmer effect\n    vec3 noiseVal = vec3(turbulent(st + iTime));\n    dist += noiseVal.r * 0.1;\n    \n    // Create color based on distance and time\n    float hue = (ipos.x + ipos.y) * 0.2 + iTime * 0.5;\n    vec3 color = hsl(hue, 0.7, 0.5);\n    \n    // Modulate color with distance\n    color *= 1.0 - smoothstep(0.0, 0.4, dist);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_461.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating circles pattern\n    float radius = length(uv - 0.5);\n    \n    // Add rotation over time\n    float angle = iTime * 0.1;\n    vec2 rotatedUV = uv - 0.5;\n    rotatedUV.x *= cos(angle);\n    rotatedUV.y *= sin(angle);\n    rotatedUV += 0.5;\n    \n    // Create multiple layers of circles with different frequencies\n    float d1 = mod(length(rotatedUV * 4.0 - 0.5) * 2.0, 1.0);\n    float d2 = mod(length(rotatedUV * 8.0 - 0.5) * 3.0, 1.0);\n    \n    // Add noise for dynamic variation\n    float noiseValue = turbulent(uv * 4.0 + iTime) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.5 + d1 * 0.5, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.5 + d2 * 0.5, 1.0, 0.6));\n    \n    // Combine layers with varying opacity\n    vec3 finalColor = mix(color1, color2, noiseValue);\n    \n    return vec4(finalColor, noiseValue);\n}"
  },
  "data_462.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5 + 1.387;\n    \n    // Rotating sine wave patterns\n    vec2 st = uv - 0.5;\n    float angle = time * pi;\n    float s = sin(uv.x * 4.0 + angle) * cos(time * 2.0);\n    float c = cos(uv.y * 4.0 + angle) * sin(time * 2.0);\n    \n    // Dynamic RGB shifts\n    vec3 color = hsl2rgb(vec3(\n        sin(time * 0.5 + st.x * 2.0) * 0.5 + 0.5,\n        cos(time * 0.7 + st.y * 2.0) * 0.5 + 0.5,\n        0.8\n    ));\n    \n    // Add noise and turbulence\n    float noiseVal = noise(vec3(uv, time)) * 0.4;\n    color += vec3(s * c + noiseVal);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_463.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color with HSL\n    vec3 color = hsl2rgb(vec3(0.5 * uv.x + 0.5, 1.0, 0.5));\n    \n    // Add time-based wave pattern\n    float wave1 = sin(uv.x * 4.0 + iTime) * 0.2;\n    float wave2 = sin(uv.y * 4.0 - iTime) * 0.3;\n    float wave = (wave1 + wave2) * 0.5;\n    \n    // Add noise and turbulence\n    vec3 noisePattern = vec3(turbulent(vec3(uv.x * 2.0, uv.y * 2.0, iTime)));\n    color += noisePattern * 0.4;\n    \n    // Create flowing effect by mixing colors with time\n    float hueFlow = (uv.x + uv.y) * 0.5 + iTime * 0.1;\n    vec3 finalColor = mix(color, hsl2rgb(vec3(hueFlow - 0.5, 1.0, 0.5)), 0.4);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_464.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Time-based offset for animation\n    float timeOffset = iTime * 0.5;\n    \n    // Create a displacement using noise and turbulence\n    vec2 st = uv * 10.0 + vec2(timeOffset, timeOffset);\n    float n1 = noise(st) * 0.5;\n    float n2 = turbulent(st * 0.5) * 0.3;\n    float n3 = turbulent(st * 0.25) * 0.2;\n    \n    // Combine noise layers\n    float displacement = (n1 + n2 + n3) * 0.5 + 0.5;\n    \n    // Modulate color based on displacement and time\n    vec3 baseColor = hsl2rgb(vec3((timeOffset * 0.1) + displacement, 1.0, 0.6));\n    \n    // Add a radial glow effect\n    float distFromCenter = length(uv - 0.5);\n    float glowFactor = smoothstep(0.7, 0.0, distFromCenter);\n    vec3 glowColor = hsl2rgb(vec3((timeOffset * 0.1), 1.0, 0.8)) * glowFactor;\n    \n    // Combine colors\n    color = mix(baseColor, glowColor, glowFactor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_465.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create hexagonal grid coordinates\n    vec2 st = uv * 5.0; // Scale up for more cells\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create hexagonal pattern using sine and cosine at 60 degree intervals\n    float angleStep = pi / 3.0;\n    vec2 gridPos = vec2(\n        sin(theta + angleStep * 0.5) * r,\n        cos(theta - angleStep * 0.5) * r\n    );\n    \n    // Add noise and turbulence to create dynamic shifting effect\n    float noiseValue = noise(vec3(gridPos, iTime * 0.1));\n    gridPos += noiseValue * 0.2;\n    \n    // Calculate color based on position and time\n    vec3 hslColor = vec3(\n        fract(r * 0.2 + iTime) * 360.0,\n        0.7 + turbulent(vec2(gridPos)) * 0.3,\n        0.5 + sin(iTime) * 0.5\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_466.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal grid pattern\n    a += iTime * 0.5; // Rotate pattern over time\n    a *= 6.0;         // Hexagon has six-fold symmetry\n    \n    // Use floor to create tiling effect\n    vec2 polar = vec2(r, a);\n    vec2 tile = floor(polar + 0.5);\n    // Add noise and turbulence for dynamic effect\n    float noiseVal = noise(vec3(tile.x * 0.1, tile.y * 0.1, iTime * 0.1));\n    float turbulentVal = turbulent(vec2(r * 0.5, a * 0.5));\n    // Calculate color based on position and time\n    vec3 color;\n    color.r = sin(a + iTime) * 0.5 + 0.5;\n    color.g = cos(r - iTime) * 0.5 + 0.5;\n    color.b = turbulentVal;\n    // Convert to HSL for better color control\n    vec3 hslColor = vec3(\n        (a / (2.0 * PI)) + 0.5,   // Hue based on angle\n        1.0 - abs(r - 0.5) * 2.0, // Saturation decreases towards center\n        0.5                       // Fixed lightness\n    );\n    \n    // Convert HSL to RGB and mix with noise\n    vec3 finalColor = hsl2rgb(hslColor);\n    finalColor *= noiseVal * 0.5 + 0.5;\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_467.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a checkerboard pattern using floor and mod\n    vec2 st = floor(uv * 5.0);\n    float check = mod(st.x + st.y, 2.0);\n    \n    // Animate the squares with time\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Create color variations for each square\n    vec3 color1 = hsl(check * 0.5, 0.7, 0.6);\n    vec3 color2 = hsl((check + pulse) * 0.5, 0.7, 0.6);\n    \n    // Combine colors based on checkerboard pattern\n    vec3 finalColor = mix(color1, color2, check);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_468.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Convert to polar coordinates for rotation effect\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    theta += iTime * 0.5; // Rotate over time\n    \n    // Create rotating grid pattern\n    vec2 gridPos = sin(vec2(theta) + iTime) * 10.0;\n    float grid = mod(gridPos.x, 1.0) < 0.01 || mod(gridPos.y, 1.0) < 0.01 ? 1.0 : 0.0;\n    \n    // Add circular pattern\n    float circles = mod(r * 5.0 + iTime, 1.0) < 0.02 ? 1.0 : 0.0;\n    \n    // Mix patterns and add noise overlay\n    vec3 color = mix(vec3(grid), vec3(circles), 0.5);\n    color += hsl2rgb(vec3(theta * 0.5 + iTime * 0.1, 0.7, 0.8));\n    color += noise(st * 10.0 + iTime) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_469.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec3 color = vec3(0.0);\n    \n    // Orb positions and movements\n    vec2 pos1 = sin(time * 0.3 + vec2(0.0, 1.0)) * 0.4 + uv * 4.0;\n    vec2 pos2 = sin(time * 0.5 + vec2(1.0, 0.0)) * 0.4 + uv * 4.0;\n    vec2 pos3 = sin(time * 0.7) * 0.4 + uv * 4.0;\n    \n    // Calculate distances\n    float d1 = length(uv * 4.0 - pos1);\n    float d2 = length(uv * 4.0 - pos2);\n    float d3 = length(uv * 4.0 - pos3);\n    \n    // Orb colors with time-based shifts\n    vec3 c1 = hsl(0.5 + sin(time) * 0.2, 1.0, 0.8);\n    vec3 c2 = hsl(0.3 + cos(time * 0.7) * 0.2, 1.0, 0.8);\n    vec3 c3 = hsl(0.7 + sin(time * 0.5) * 0.2, 1.0, 0.8);\n    \n    // Add light trails\n    color += c1 * smoothstep(0.4, 0.0, d1) * (0.1 + sin(time * 0.3));\n    color += c2 * smoothstep(0.4, 0.0, d2) * (0.1 + cos(time * 0.5));\n    color += c3 * smoothstep(0.4, 0.0, d3) * (0.1 + sin(time * 0.7));\n    \n    // Add interaction effects between orbs\n    float dist12 = length(pos1 - pos2);\n    float dist13 = length(pos1 - pos3);\n    float dist23 = length(pos2 - pos3);\n    \n    if (dist12 < 0.3) {\n        color += vec3(1.0, 0.5, 0.8) * sin(dist12 / 0.3 + time) * 0.4;\n    }\n    if (dist13 < 0.3) {\n        color += vec3(0.5, 1.0, 0.8) * sin(dist13 / 0.3 + time) * 0.4;\n    }\n    if (dist23 < 0.3) {\n        color += vec3(0.8, 0.5, 1.0) * sin(dist23 / 0.3 + time) * 0.4;\n    }\n    \n    // Add noise for extra detail\n    color += noise(uv * 10.0 + time) * 0.1;\n    \n    return vec4(color * 0.8, 1.0);\n}"
  },
  "data_47.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a moving point based on UV coordinates and time\n    vec3 p = vec3(uv * 10.0 + iTime, iTime);\n    \n    // Add some turbulence for organic movement\n    float t = turbulent(p * 0.5);\n    \n    // Generate color using HSL with time-based parameters\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.1) * 0.5 + 0.5,   // Hue variation\n        0.7 + t * 0.3,                  // Saturation\n        0.5 + sin(length(uv) * 8.0 + iTime * 2.0) * 0.5  // Lightness modulation\n    ));\n    \n    // Add some intensity based on position and time\n    float intensity = sin(length(uv) * 4.0 + iTime) * 0.5 + 0.5;\n    color *= intensity;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_470.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates and scale them appropriately\n    vec2 st = (uv - 0.5) * 12.0;\n    \n    // Add a rotating component based on time\n    float angle = iTime * 0.5;\n    vec2 rotated = vec2(\n        st.x * cos(angle) - st.y * sin(angle),\n        st.x * sin(angle) + st.y * cos(angle)\n    );\n    \n    // Create a swirling pattern using turbulence\n    float swirl = turbulent(rotated * 3.0 + iTime);\n    swirl += turbulent(rotated * 6.0 + iTime * 2.0);\n    \n    // Generate dynamic color transitions using HSL\n    vec3 color = hsl(\n        (swirl + length(st) * 0.5 + iTime) * 0.1,\n        0.7,\n        0.8\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_471.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 st = uv - 0.5;\n    \n    // Create a time-based animation\n    float time = iTime * 0.5;\n    \n    // Base color using noise for movement\n    vec3 color = hsl2rgb(vec3(\n        noise(st + time) * 180.0,\n        0.7,\n        0.5\n    ));\n    \n    // Add shimmering effect with turbulence\n    float shimmer = turbulent(st * 4.0 + time);\n    color *= 1.0 + shimmer * 0.5;\n    \n    // Create floating orbs using multiple layers of noise\n    for(float i = 0.0; i < 3.0; i++) {\n        vec2 pos = st + sin(time + i) * 0.2;\n        float dist = length(pos);\n        float orb = smoothstep(1.0, 0.0, dist * 4.0 - i);\n        \n        // Add color variations\n        color += hsl2rgb(vec3(\n            noise(vec3(pos.x, pos.y, time + i)) * 180.0,\n            0.5,\n            0.3\n        )) * orb;\n    }\n    \n    // Finalize the effect with a glow\n    float glow = turbulent(st * 2.0 + time);\n    color += vec3(glow) * 0.4;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_472.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    float d = length(uv - 0.5);\n    \n    // Create expanding rings using sine wave with time offset\n    float t = iTime * 0.5;\n    float ring = sin(d * 8.0 + t) * 0.5 + 0.5;\n    \n    // Use HSL color space for easy hue transitions\n    vec3 hslColor = vec3(\n        (d * 4.0 + t) / (2.0 * PI),  // Hue: varies with distance and time\n        0.8,                          // Saturation\n        0.5                           // Lightness\n    );\n    \n    // Convert HSL to RGB\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Create pulsing effect by mixing colors\n    vec3 finalColor = mix(\n        rgbColor * ring,          // Color when near the center\n        vec3(0.0),                // Black background\n        1.0 - ring               // Transition between colors and black\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_473.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Time-based animation\n    float time = iTime * 0.5;\n    \n    // Create frequency components for water waves\n    vec2 freq1 = vec2(sin(time), cos(time)) * 0.5 + 0.5;\n    vec2 freq2 = vec2(sin(time * 0.7), cos(time * 0.7)) * 0.3 + 0.3;\n    \n    // Generate displacement map using noise\n    float displacement = \n        noise(uv * 4.0 + time) * 0.5 +\n        noise(uv * 2.0 + freq1) * 0.3 +\n        noise(uv * 1.0 + freq2) * 0.2;\n    \n    // Create water depth effect\n    float depth = length(uv) * 0.7;\n    displacement += sin(time + depth * 2.0) * 0.4;\n    \n    // Apply displacement to UV coordinates\n    vec2 uv2 = uv + vec2(\n        sin(displacement * 3.0 + time) * 0.1,\n        cos(displacement * 3.0 + time) * 0.1\n    );\n    \n    // Add secondary displacement for more detail\n    uv2 += noise(uv2 * 4.0 + vec2(1.0, 1.0)) * 0.1;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 waterColor = hsl(\n        sin(time * 0.5) * 0.2 + 0.6,   // Hue (cyan/blue)\n        0.7,                            // Saturation\n        0.5 + displacement * 0.2       // Lightness modulation\n    );\n    \n    // Add shimmer effect based on UV coordinates and time\n    float shimmer = noise(uv2 * 8.0 + vec2(time)) * 0.1;\n    waterColor += hsl(\n        sin(time * 0.3) * 0.2 + 0.9,   // Hue (white/very light blue)\n        0.5,\n        0.7\n    ) * shimmer;\n    \n    return vec4(waterColor, 1.0);\n}"
  },
  "data_474.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for rotational effects\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Add turbulence to create dynamic swirling patterns\n    theta += turbulent(vec3(theta, r, iTime * 0.1)) * 0.5;\n    r += turbulent(vec3(r, theta, iTime * 0.2)) * 0.2;\n    \n    // Create rotational color gradients using HSL\n    vec3 color1 = hsl((theta + iTime) * 0.1, 0.7, 0.5);\n    vec3 color2 = hsl((theta - iTime) * 0.1, 0.6, 0.4);\n    \n    // Combine colors with additive blending\n    vec3 finalColor = (color1 + color2) * (0.5 + noise(vec2(r, theta)) * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_475.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 p = uv - 0.5;\n    \n    // Create rotation effect\n    float angle = atan(p.y, p.x);\n    angle += iTime * 0.5; // Add time-based rotation\n    \n    // Calculate distance from center\n    float dist = length(p);\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(angle / (2.0 * pi) + 0.5, 0.7, 0.6);\n    vec3 color2 = hsl((angle + iTime * 0.1) / (2.0 * pi) + 0.5, 0.7, 0.6);\n    \n    // Mix colors based on distance\n    vec3 finalColor = mix(color1, color2, dist);\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(p * 4.0, iTime * 0.1));\n    finalColor *= 0.5 + 0.5 * sin(iTime + turb * 2.0);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_476.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * 5.0 + iTime; // Scale and animate UV coordinates\n    \n    // Create warping pattern using turbulence\n    float warp = turbulent(st * 0.5 + iTime);\n    vec2 distortedUV = uv + (warp * 0.1) * vec2(sin(iTime), cos(iTime));\n    \n    // Generate color components with noise and time\n    float r = noise(vec3(distortedUV * 2.0, iTime)) * 0.5 + 0.5;\n    float g = noise(vec3(distortedUV * 3.0 + vec2(1.0), iTime * 0.8)) * 0.5 + 0.5;\n    float b = noise(vec3(distortedUV * 4.0 + vec2(2.0), iTime * 0.6)) * 0.5 + 0.5;\n    \n    // Mix colors with time-based hue shift\n    vec3 color = hsl2rgb(vec3(\n        (r + g + b) * 0.333 + iTime * 0.1, // Hue\n        0.7, // Saturation\n        0.5 // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_477.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal patterns\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add time-based rotation and pulsation\n    theta += iTime * 0.5;\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    \n    // Create hexagonal tiling pattern using polar coordinates\n    float angleStep = pi / 3.0;\n    float rotatedAngle = mod(theta, angleStep);\n    float d = abs(cos(rotatedAngle)) * r;\n    \n    // Use noise and turbulence for dynamic patterns\n    vec2 noiseUV = uv + vec2(iTime * 0.1, iTime * 0.15);\n    float noiseVal = noise(noiseUV) * 0.5 + 0.5;\n    float turbulentVal = turbulent(vec3(uv, iTime)) * 0.5 + 0.5;\n    \n    // Create hexagon mask and color transitions\n    float hexMask = smoothstep(1.0 - pulse, 1.0 + pulse, d);\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime) * 0.5 + 0.5,\n        noiseVal,\n        turbulentVal\n    ));\n    \n    // Apply pulsating colors and blend with background\n    vec3 finalColor = mix(vec3(0.1), color, hexMask);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_478.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 centeredUV = uv - 0.5;\n    \n    // Calculate distance from center\n    float dist = length(centeredUV);\n    \n    // Add pulsating effect using time\n    float pulse = sin(iTime * 2.0 + dist * 4.0) * 0.3;\n    float radius = dist + pulse;\n    \n    // Create circular shape with smooth edges\n    float circle = smoothstep(0.5, 0.7, radius);\n    \n    // Add turbulence for dynamic effect\n    vec2 noiseUV = centeredUV * 4.0 + iTime;\n    float turb = turbulent(noiseUV) * 0.3;\n    radius += turb;\n    \n    // Create radial gradient\n    vec3 color1 = hsl2rgb(vec3(0.5, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.1, 1.0, 0.6));\n    vec3 gradientColor = mix(color1, color2, radius);\n    \n    // Combine circle and gradient\n    vec3 finalColor = mix(vec3(0.0), gradientColor, circle);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_479.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create hexagonal pattern by rotating and scaling coordinates\n    a *= 6.0; // Hexagon has six points\n    vec2 rotated = vec2(cos(a), sin(a)) * r;\n    \n    // Use noise to create texture\n    float noiseVal = noise(vec3(rotated * 0.5, iTime));\n    noiseVal = turbulent(vec2(rotated * 0.1 + iTime)) * 0.5 + 0.5;\n    \n    // Create pulsating color effect using HSL\n    vec3 colorHSL = vec3(\n        fract(iTime * 0.2) * 360.0, // Hue variation over time\n        0.7, // Saturation\n        0.5 + noiseVal * 0.5 // Lightness modulation with noise\n    );\n    \n    // Convert HSL to RGB and mix with noise texture\n    vec3 color = hsl2rgb(colorHSL);\n    \n    // Add pulsating effect based on radius\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    color *= smoothstep(1.0, 0.0, r) * (1.0 + noiseVal * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_48.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using noise and turbulence\n    float time = iTime * 0.5;\n    \n    // Scale UV coordinates for more detailed patterns\n    vec2 st = fract(uv * 100.0);\n    \n    // Add some movement to the pattern\n    st += vec2(sin(time + st.x) * 0.3, cos(time + st.y) * 0.3);\n    \n    // Use turbulence to create a complex noise pattern\n    float turb = turbulent(vec3(st, time));\n    \n    // Create color variations using HSL conversion\n    vec3 color1 = hsl2rgb(vec3(turb * pi, 0.7, 0.5));\n    vec3 color2 = hsl2rgb(vec3(turb * pi + time, 0.6, 0.4));\n    \n    // Mix colors based on noise values\n    vec3 finalColor = mix(color1, color2, noise(st) * 0.5 + 0.5);\n    \n    // Add some dynamic lighting effect\n    float light = sin(time + length(uv - 0.5)) * 0.5 + 0.5;\n    finalColor *= light;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_480.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 p = uv * 2.0 - 1.0;\n    float angle = atan2(p.y, p.x);\n    float radius = length(p);\n    \n    // Add rotation based on time\n    angle += iTime * 0.1;\n    \n    // Convert back to cartesian coordinates\n    vec2 q = vec2(\n        cos(angle) * radius,\n        sin(angle) * radius\n    );\n    \n    // Create hexagonal grid pattern\n    vec2 grid = abs(q);\n    grid.x = (grid.x + grid.y) * 0.5;\n    grid = floor(grid * 4.0 + 0.5);\n    \n    // Calculate color based on grid position and time\n    float hue = fract(iTime / 3.0);\n    vec3 color = hsl2rgb(vec3(\n        (grid.x + grid.y) * 0.1 + hue,\n        1.0,\n        0.5 + 0.5 * sin(q.x * 4.0 + iTime)\n    ));\n    \n    // Add some variation to colors\n    color = mix(color, hsl2rgb(vec3(\n        (grid.x - grid.y) * 0.1 + hue + 0.333,\n        1.0,\n        0.5 + 0.5 * sin(q.y * 4.0 + iTime)\n    )), 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_481.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Add time-based rotation\n    theta += iTime * 0.2;\n    \n    // Create vector pattern using sine waves\n    float s1 = sin(theta + iTime) * 0.5 + 0.5;\n    float s2 = cos(theta - iTime) * 0.5 + 0.5;\n    \n    // Create line patterns\n    vec3 color1 = hsl2rgb(vec3(0.0, 1.0, s1));\n    vec3 color2 = hsl2rgb(vec3(0.666, 1.0, s2));\n    \n    // Mix colors based on position and time\n    float mixVal = step(0.5, sin(theta + iTime * 0.5) + 0.5);\n    vec3 finalColor = mix(color1, color2, mixVal);\n    \n    // Add turbulence effect\n    float turb = turbulent(uv * 4.0 + iTime);\n    finalColor *= 1.0 + turb * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_482.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create spiral pattern with rotation\n    a += iTime * 0.5; // Rotation speed\n    float spiral = sin(a * 4.0 + r * 3.0) * 0.5 + 0.5;\n    \n    // Add noise for cosmic dust effect\n    vec2 noiseScale = st * 0.5;\n    float noise1 = noise(noiseScale);\n    float noise2 = turbulent(vec3(st, iTime * 0.1));\n    \n    // Create color gradient based on radius and angle\n    vec3 color = hsl(r * 0.6 + 0.3, sin(a * 4.0) * 0.5 + 0.5, 0.8);\n    color = mix(color, vec3(1.0), noise2 * 0.5); // Add star effect\n    \n    // Combine spiral pattern with noise and color\n    float brightness = (spiral + noise1 * 0.5) * 1.5;\n    color *= brightness;\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_483.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.2;\n    \n    // Create rotating pattern by offsetting UV coordinates\n    vec2 center = uv - 0.5;\n    float angle = sin(time) + cos(time * 0.7);\n    vec2 rotatedUV = vec2(\n        center.x * cos(angle) - center.y * sin(angle),\n        center.x * sin(angle) + center.y * cos(angle)\n    ) + 0.5;\n    \n    // Create spiral pattern using polar coordinates\n    vec2 toCenter = rotatedUV - 0.5;\n    float radius = length(toCenter);\n    float theta = atan(toCenter.y, toCenter.x);\n    \n    // Add spiral arms and noise\n    float spiral = radius + sin(theta * 12.0) * 0.3;\n    spiral += turbulent(vec3(rotatedUV * 4.0, time)) * 0.2;\n    \n    // Create color gradient based on distance from center\n    vec3 color = hsl(\n        0.7 + (radius * 0.5),   // Purple base color with variation\n        1.0 - radius * 0.5,     // Saturation decreases with radius\n        0.3 + spiral * 0.2      // Brightness varies with spiral pattern\n    );\n    \n    // Convert HSL to RGB and add glow effect\n    vec3 finalColor = hsl2rgb(color) * (1.0 - radius * 0.5);\n    if (radius < 0.1) {\n        finalColor *= 2.0; // Add central glow\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_484.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Particle count\n    const int particles = 16;\n    \n    // Time-based animation\n    float t = iTime * 0.5;\n    \n    for(int i = 0; i < particles; i++) {\n        // Random seed for each particle\n        vec2 st = uv + vec2(float(i) / float(particles), 0.0);\n        \n        // Particle position with noise-based movement\n        vec3 pos = vec3(st * 10.0, t);\n        pos.xy += noise(pos) * 2.0;\n        pos.z += turbulent(pos) * 5.0;\n        \n        // Distance from particle to current UV coordinate\n        float dist = length(uv - (pos.xy / pos.z));\n        \n        // Glow effect based on distance\n        float glow = smoothstep(1.0, 0.0, dist);\n        \n        // Color with HSL variation\n        vec3 hslColor = vec3(t * 0.2 + float(i) / float(particles), 1.0, 0.5);\n        vec3 rgbColor = hsl2rgb(hslColor);\n        \n        // Add glow to color\n        color += rgbColor * glow;\n    }\n    \n    // Dark background with additive blending\n    color *= 0.9;\n    color = mix(vec3(0.0), color, 0.8);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_485.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec2 p = uv * 2.0 - 1.0;\n    \n    // Rotating geometric pattern\n    float r = length(p);\n    float theta = atan(p.y, p.x) + time;\n    \n    // Create shape using polar coordinates\n    float shape = sin(theta * 4.0) * cos(r * 8.0 + time) +\n                  cos(theta * 3.0) * sin(r * 6.0 - time);\n    \n    // Add noise and turbulence\n    vec2 noisePos = uv * 10.0;\n    float noiseValue = noise(noisePos) * 0.5 + 0.5;\n    shape += noiseValue * turbulent(vec3(p, time)) * 0.4;\n    \n    // Color transitions\n    vec3 color = hsl2rgb(vec3(\n        fract(time * 0.1 + r * 0.2) * 360.0,\n        0.7,\n        0.5\n    )) * (sin(r * 8.0 - time) * 0.5 + 0.5);\n    \n    // Mix noise overlay\n    float noiseOverlay = sin(time + r * 10.0) * 0.5 + 0.5;\n    color += noiseValue * noiseOverlay * 0.6;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_486.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Initialize base color\n    vec3 color = vec3(0.0);\n    \n    // Add multiple sine wave layers with different frequencies and phases\n    for(float i = 1.0; i <= 6.0; i++) {\n        // Scale UV coordinates based on frequency\n        vec2 st = uv * i * 4.0;\n        \n        // Add time-based animation\n        st += vec2(iTime * 0.5, iTime * 0.3);\n        \n        // Rotate the pattern slightly for each layer\n        float angle = iTime * 0.1 + i * 0.2;\n        st = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * st;\n        \n        // Create sine wave patterns with varying frequencies\n        float value = sin(st.x * 3.0 + iTime) * cos(st.y * 3.0 + iTime * 0.5);\n        value += sin(st.x * 2.0 + iTime * 0.7) * cos(st.y * 2.0 + iTime * 0.3);\n        \n        // Add turbulence for more complex patterns\n        value += turbulent(st * 4.0 + iTime) * 0.5;\n        \n        // Scale and add to the final color\n        color += vec3(value * 0.1, value * 0.1, value * 0.1);\n    }\n    \n    // Convert to HSL for better color control\n    vec3 hslColor = vec3(\n        mod(iTime * 0.2 + length(uv) * 2.0, 1.0),  // Hue\n        0.7,                                      // Saturation\n        0.5 + turbulent(vec3(uv * 4.0, iTime)) * 0.2  // Lightness with noise\n    );\n    \n    color = hsl2rgb(hslColor) * (1.0 + sin(iTime * 0.5) * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_487.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create base pattern using turbulence\n    float t1 = turbulent(st);\n    \n    // Add multiple layers of noise for more detail\n    float noiseSum = 0.0;\n    for(float i = 0.0; i < 4.0; i++) {\n        noiseSum += noise(vec2(st.x + iTime * (i+1.0), st.y) * pow(2.0, i)) / pow(2.0, i);\n    }\n    \n    // Combine patterns and create color\n    vec3 color = hsl(\n        sin(iTime * 0.5 + t1 * 2.0) * 0.5 + 0.5,   // Hue\n        0.7 + noiseSum * 0.3,                       // Saturation\n        0.5 + sin(st.x * 2.0 + iTime) * 0.5         // Lightness\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_488.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec3 color = vec3(0.0);\n    \n    // Create multiple layers of fractals\n    for (int i = 0; i < 5; i++) {\n        // Rotate and scale coordinates\n        float angle = time + float(i) * 0.2;\n        uv = abs(uv - 0.5) * 2.0;\n        uv = vec2(\n            uv.x * cos(angle) - uv.y * sin(angle),\n            uv.x * sin(angle) + uv.y * cos(angle)\n        );\n        uv = pow(uv, vec2(1.0 + float(i)*0.3)) * 4.0;\n        \n        // Add noise and color\n        float n = noise(vec3(uv, time));\n        n += turbulent(uv * 0.5);\n        n = abs(n) * 0.5 + 0.5;\n        \n        vec3 c = hsl2rgb(vec3(\n            time + float(i)*0.3,\n            1.0,\n            n * 0.7 + 0.3\n        ));\n        \n        color += c * (n * 0.4);\n    }\n    \n    // Add some glow and brightness variation\n    color *= abs(sin(time * 0.5)) * 0.5 + 0.5;\n    color = clamp(color, 0.0, 1.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_489.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequency pattern with time modulation\n    float base = sin(uv.x * 8.0 + iTime * 2.0);\n    \n    // Add noise and turbulence layers for complexity\n    vec3 noiseLayers = vec3(\n        turbulent(uv * 0.5 + iTime),\n        turbulent(uv * 0.25 + iTime * 0.5),\n        turbulent(uv * 0.125 + iTime * 0.75)\n    );\n    \n    // Combine noise layers with different weights\n    float noiseMix = (noiseLayers.x * 0.4) + (noiseLayers.y * 0.3) + (noiseLayers.z * 0.2);\n    \n    // Create color variations using HSL conversion\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + uv.x * 0.5),\n        0.7,\n        0.6\n    );\n    \n    // Convert to RGB and mix with noise\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = rgbColor * (0.5 + 0.5 * noiseMix);\n    \n    // Add pulsating effect using sine wave\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    finalColor *= pulse;\n    \n    // Mix in additional color variations based on position and time\n    vec3 colorVariation = vec3(\n        sin(uv.x * 4.0 + iTime),\n        cos(uv.y * 4.0 + iTime * 0.5),\n        sin((uv.x + uv.y) * 6.0 + iTime)\n    );\n    \n    finalColor += colorVariation * 0.3;\n    \n    // Apply gamma correction for better contrast\n    finalColor = pow(finalColor, vec3(1.2));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_49.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Generate noise patterns at different scales\n    float n1 = noise(uv * 5.0);\n    float n2 = noise(uv * 10.0 + iTime);\n    float n3 = turbulent(uv * 20.0 + iTime * 0.5);\n    \n    // Create a color palette using HSL\n    vec3 hslColor = vec3(\n        sin(iTime * 0.5) * 0.5 + 0.5,   // Hue variation over time\n        1.0,                             // Saturation\n        abs(n1 * 0.5 + 0.5)              // Lightness influenced by noise\n    );\n    \n    // Convert to RGB and add glow effect\n    vec3 color = hsl2rgb(hslColor);\n    color *= exp(color * 4.0);           // Exponential glow\n    \n    // Add turbulence-based distortion\n    vec2 distortedUV = uv + turbulent(uv * 10.0 + iTime) * 0.1;\n    \n    // Combine all elements with time-based animation\n    return vec4(\n        color * (n2 * 0.5 + 0.5), \n        exp(n3 * 2.0 + 1.0)             // Brightness modulation\n    );\n}"
  },
  "data_490.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Number of orbiting points\n    const int numPoints = 8;\n    \n    // Time-based rotation\n    float time = iTime * 0.5;\n    \n    // Add base noise for turbulence\n    vec2 noiseUV = uv * 10.0 + vec2(time, 0.0);\n    float baseNoise = turbulent(noiseUV) * 0.3;\n    \n    for(int i = 0; i < numPoints; i++) {\n        // Calculate angle for each point\n        float angle = (float(i) / float(numPoints)) * PI * 2.0 + time;\n        \n        // Orbiting position with radius\n        vec2 orbitPos = vec2(cos(angle), sin(angle)) * 0.7;\n        \n        // Add noise to orbit position\n        orbitPos += noise(vec3(orbitPos * 5.0 + time, 0.0)) * 0.1;\n        \n        // Calculate distance from fragment to orbiting point\n        vec2 diff = uv - orbitPos;\n        float dist = length(diff);\n        \n        // Create expanding rings effect\n        float ring = mod(dist - time, 1.0) * 0.5 + 0.5;\n        ring = abs(ring * 2.0 - 1.0);\n        \n        // Add turbulence to the rings\n        float turb = turbulent(diff * 10.0 + vec2(time)) * 0.3;\n        ring += turb;\n        \n        // Create color based on distance and time\n        vec3 color = hsl2rgb(vec3((time + float(i) / float(numPoints)) * 0.5, 0.7, 0.8));\n        \n        // Combine ring effect with color\n        finalColor += color * (1.0 - ring);\n    }\n    \n    // Add base noise to the background\n    finalColor += vec3(baseNoise * 0.2 + 0.1);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_491.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base noise pattern with time influence\n    float time = iTime * 0.5;\n    \n    // Multi-scale noise patterns\n    float n1 = turbulent(uv * 3.0 + vec2(time)) * 0.5 + 0.5;\n    float n2 = turbulent(uv * 6.0 + vec2(time * 0.7)) * 0.5 + 0.5;\n    float n3 = noise(vec3(uv * 12.0, time)) * 0.5 + 0.5;\n    \n    // Create color components using HSL\n    vec3 color1 = hsl(n1 * 360.0, 0.7, 0.5);\n    vec3 color2 = hsl((n2 * 360.0) + 180.0, 0.7, 0.5);\n    \n    // Mix colors based on noise values\n    vec3 finalColor = mix(color1, color2, n3);\n    \n    // Add time-based hue variation\n    finalColor = hsv2rgb(vec3(\n        atan2(finalColor.g - finalColor.b, finalColor.r) * 180.0 / PI + time * 50.0,\n        length(finalColor),\n        0.7\n    ));\n    \n    // Add brightness modulation\n    float brightness = turbulent(uv * 4.0 + vec2(time * 0.3)) * 0.5 + 0.5;\n    finalColor *= brightness * 1.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_492.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Add time-based rotation\n    a += iTime * 0.5;\n    // Create hexagonal pattern using polar coordinates\n    float hexPattern = abs(sin(a * 3.0 + iTime)) * 0.5 + 0.5;\n    \n    // Pulsating color effect\n    vec3 color = hsl2rgb(vec3(\n        (a / pi + 0.5) * 0.6 + 0.2,  // Hue\n        0.7,                          // Saturation\n        hexPattern * 0.8 + 0.2        // Lightness\n    ));\n    // Add dynamic gradient using noise\n    float gradient = turbulent(vec3(r * 5.0, a / pi, iTime * 0.1));\n    color *= gradient;\n    // Create pulsating ring effect\n    float ring = abs(sin(r * 4.0 - iTime)) * 0.2;\n    color += ring;\n    return vec4(color, 1.0);\n}"
  },
  "data_493.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 8.0 + iTime;\n    \n    // Create sine wave patterns with RGB shifts\n    vec3 color = vec3(\n        sin(st.x * 0.5 + iTime) * 0.5 + 0.5,\n        sin(st.y * 0.7 - iTime * 2.0) * 0.5 + 0.5,\n        sin((st.x + st.y) * 0.3 + iTime * 3.0) * 0.5 + 0.5\n    );\n    \n    // Add circular gradient effect\n    vec2 center = vec2(0.5, 0.5);\n    float dist = length(uv - center);\n    float circle = 1.0 - smoothstep(0.7, 1.0, dist);\n    \n    // Incorporate noise and turbulence\n    vec3 noisePattern = vec3(\n        turbulent(vec3(st.x * 0.2, st.y * 0.3, iTime)),\n        turbulent(vec3(st.x * 0.5, st.y * 0.4, iTime + 1.0)),\n        turbulent(vec3(st.x * 0.7, st.y * 0.6, iTime + 2.0))\n    );\n    \n    // Combine effects\n    color = mix(color, noisePattern, 0.5);\n    color *= circle;\n    \n    // Apply HSL to RGB conversion for vibrant colors\n    vec3 hslColor = hsl2rgb(vec3(\n        (color.r + iTime) * 0.1,\n        color.g * 0.7,\n        color.b * 0.8\n    ));\n    \n    return vec4(hslColor, 1.0);\n}"
  },
  "data_494.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of orbs using noise texture sampling\n    vec3 noise1 = texture(iChannel0, fract(uv * 8.0)).rgb;\n    vec3 noise2 = texture(iChannel0, fract(uv * 4.0 + noise1.rg * 2.0)).rgb;\n    \n    // Calculate base color with pulsating effect\n    float timeMod = mod(iTime * 0.5, 6.0);\n    vec3 baseColor = hsl(timeMod * 0.17 + 0.5, 0.8, 0.6);\n    \n    // Generate pulsating wave pattern\n    float wave = sin(uv.x * 2.0 + timeMod) * cos(uv.y * 2.0 + timeMod * 0.7);\n    wave += sin(uv.x * 4.0 + timeMod * 1.3) * cos(uv.y * 4.0 + timeMod * 0.9);\n    wave *= 0.5;\n    \n    // Create orb positions with noise-based movement\n    vec2 pos = uv * 8.0;\n    pos += noise1.rg * 0.1;\n    pos += noise2.rg * 0.2;\n    pos = fract(pos) - 0.5;\n    \n    // Calculate distance from center for fog effect\n    float dist = length(pos);\n    float fog = smoothstep(0.7, 1.0, dist);\n    \n    // Combine colors and apply fog\n    vec3 finalColor = mix(baseColor, hsv2rgb(vec3(timeMod * 0.17 + 0.5, 0.6, 0.8)), wave * 0.5 + 0.5);\n    finalColor *= 1.0 - fog * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_495.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 centered = uv - 0.5;\n    float r = length(centered);\n    float theta = atan2(centered.y, centered.x);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5 + sin(iTime) * 0.2;\n    \n    // Create kaleidoscopic effect using modular symmetry\n    float symmetries = 8.0;\n    theta = mod(theta + iTime, pi * 2.0);\n    theta = abs(mod(theta, pi / symmetries));\n    \n    // Add noise and turbulence\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float t = turbulent(noiseUV) * 0.5 + 0.5;\n    float n = noise(vec3(uv * 4.0, iTime)) * 0.5 + 0.5;\n    \n    // Create color transitions\n    vec3 color;\n    color.x = mod(theta / (pi / symmetries) + t, 1.0);\n    color.y = r * 2.0 - n;\n    color.z = sin(r * 8.0 + iTime) * 0.5 + 0.5;\n    \n    // Convert to HSL and back to RGB for vibrant colors\n    vec3 hslColor = vec3(\n        mod(color.x + iTime, 1.0),   // Hue variation over time\n        abs(sin(r * 4.0 + color.y)), // Saturation based on position\n        0.5 + t * 0.5               // Lightness modulation\n    );\n    \n    vec3 finalColor = hsl2rgb(hslColor);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_496.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    vec2 coord = uv * 5.0;\n    \n    // Recursive sine wave pattern with fractal detail\n    for(float i = 0.0; i < 6.0; i++) {\n        float time = iTime * (i + 1.0) * 0.5;\n        \n        // Complex sine transformations\n        coord.x += sin(coord.y * 3.0 + time) * 0.2;\n        coord.y += cos(coord.x * 3.0 - time) * 0.2;\n        \n        // Fractal detail with noise and turbulence\n        vec2 st = coord * pow(1.5, i);\n        float noiseVal = noise(st * 0.1 + time) * pow(0.5, i);\n        float turbulentVal = turbulent(st * 0.2 + time) * pow(0.3, i);\n        \n        // Color transformations\n        vec3 color = hsl(\n            sin(iTime * 0.2 + coord.x * 2.0) * 0.5 + 0.5,\n            abs(sin(coord.y * 2.0 + time)) * 0.5 + 0.5,\n            turbulentVal * 0.3 + 0.7\n        );\n        \n        finalColor += hsl2rgb(color) * (noiseVal + 0.5) * pow(0.8, i);\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_497.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal pattern with pulsating edges\n    r += sin(iTime) * 0.2;\n    a += sin(iTime * 0.5) * 0.5;\n    // Use modulo to create repeating hexagons\n    float angle = mod(a + iTime, PI/3.0);\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(angle * 2.0 + sin(r * 10.0), \n                     0.8 - r * 0.3,\n                     0.7 + cos(iTime) * 0.2);\n    // Add turbulence for dynamic effect\n    float turb = turbulent(vec3(uv * 10.0, iTime)) * 0.1;\n    \n    return vec4(color + turb, 1.0);\n}"
  },
  "data_498.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Create a base pattern using sine waves and noise\n    float f = sin(st.x * 5.0 + iTime) * sin(st.y * 5.0 + iTime);\n    f += noise(vec2(st.x * 3.0, st.y * 3.0)) * 0.5;\n    f += sin(iTime * 0.2 + st.x * 4.0 + st.y * 6.0) * 0.3;\n    \n    // Create a color from the pattern\n    vec3 color = hsl2rgb(vec3(\n        (f * 0.5 + 0.5) * pi * 2.0,  // Hue based on pattern\n        1.0,                          // Full saturation\n        0.5 + sin(iTime * 0.3 + f * 4.0) * 0.2  // Varying lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_499.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create flowing sine wave patterns\n    float time = iTime * 0.5;\n    float speed = 1.0;\n    \n    // X-direction flow\n    float xFlow = sin(uv.x * 5.0 + time) * 0.5 + 0.5;\n    // Y-direction flow\n    float yFlow = sin(uv.y * 5.0 + time + PI) * 0.5 + 0.5;\n    \n    // Combine flows with turbulence\n    vec2 flow = vec2(xFlow, yFlow);\n    float turbulentFlow = turbulent(flow * 10.0 + time);\n    \n    // Color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(time * 0.5, 1.0),  // Hue\n        0.7,                   // Saturation\n        0.6                    // Lightness\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add motion blur effect using noise\n    float noiseValue = noise(uv * 10.0 + time) * 0.5;\n    color += rgbColor * (turbulentFlow * 0.7 + noiseValue * 0.3);\n    \n    // Enhance the flowing effect with multiple sine layers\n    for(float i = 0.0; i < 3.0; i++) {\n        float freq = pow(2.0, i) * 5.0;\n        color += sin(uv.x * freq + time) * \n                 sin(uv.y * freq + time + PI) *\n                 rgbColor * 0.15;\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_5.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Animate UV coordinates with time\n    float t = iTime * 0.5;\n    st.x += sin(t) * 0.3;\n    st.y += cos(t) * 0.3;\n    \n    // Add noise to the UV coordinates for perturbation\n    vec2 noiseUV = st * 10.0 + vec2(sin(t), cos(t));\n    float n = noise(noiseUV);\n    \n    // Transform and scale the noise pattern\n    float scale = mod(iTime * 4.0, 10.0) / 10.0;\n    n = fract(n * scale + t);\n    \n    // Rotate based on time for additional movement\n    float angle = atan2(st.y, st.x) + t;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 transformedUV = vec2(st.x, st.y) * 0.5 + 0.5;\n    \n    // Calculate color using HSL\n    vec3 color = hsl(n * 0.5, 1.0, 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_50.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create a base color using HSL to RGB conversion\n    vec3 baseColor = hsl2rgb(vec3(0.6 + sin(time * 0.7) * 0.3, 0.8, 0.1));\n    \n    // Calculate distance from center\n    vec2 st = uv * 2.0 - 1.0;\n    float d = length(st);\n    \n    // Add some noise and turbulence\n    float t = turbulent(vec3(uv * 5.0 + time, time));\n    float glow = sin(d * 8.0 + time) * 0.5 + 0.5;\n    \n    // Create a pulsing effect\n    vec3 color = mix(baseColor, hsl2rgb(vec3(0.1 + sin(time * 0.3), 0.9, 0.7)), glow);\n    \n    // Add some movement and complexity\n    float movement = sin(time) * 0.5;\n    color += noise(vec3(uv * 4.0 + time, movement)) * 0.2;\n    \n    // Create a central glowing area\n    vec3 finalColor = mix(color, hsl2rgb(vec3(0.9, 1.0, 0.8)), smoothstep(0.7, 0.5, d));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_500.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create horizontal and vertical sine waves with varying frequencies\n    float horizontal = sin(uv.x * 10.0 + iTime * 5.0);\n    float vertical = sin(uv.y * 10.0 + iTime * 3.0);\n    // Add some complexity to the waves using noise\n    vec2 noiseUV = uv * 4.0;\n    float noiseValue = noise(noiseUV) * 0.5;\n    // Create color cycling for each wave\n    vec3 horizontalColor = hsl(0.6 + iTime * 0.1, 1.0, 0.5);\n    vec3 verticalColor = hsl(0.2 + iTime * 0.15, 1.0, 0.5);\n    // Combine the waves with their colors\n    vec3 color = vec3(0.0);\n    color += horizontalColor * (abs(horizontal) * 0.5 + 0.5);\n    color += verticalColor * (abs(vertical) * 0.5 + 0.5);\n    // Add some turbulence for extra complexity\n    float turbulence = turbulent(uv * 2.0 + iTime);\n    color *= abs(turbulence * 0.5 + 0.5);\n    // Mix in some noise and time-based variation\n    color += noiseValue * 0.3;\n    color += sin(iTime) * 0.1;\n    // Apply tonal adjustments\n    color = pow(color, vec3(2.2));\n    return vec4(color, 1.0);\n}"
  },
  "data_501.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create a 3D position with time-based z component\n    vec3 p = vec3(st.x, st.y, sin(iTime*0.5));\n    \n    // Generate turbulent noise values\n    float n1 = turbulent(p);\n    float n2 = turbulent(p * 0.5 + vec3(1.0));\n    \n    // Create color from HSL values\n    vec3 hslColor = vec3(\n        (n1 + iTime) * pi,       // Hue\n        0.6 + abs(n2)*0.4,      // Saturation\n        0.5 + n1*0.5            // Lightness\n    );\n    \n    // Convert to RGB and mix with another noise layer\n    vec3 color = hsl2rgb(hslColor) * (0.5 + turbulent(vec2(uv*2.0 + iTime))*0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_502.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Normalize UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a base frequency for the sine waves\n    float freq = 5.0;\n    \n    // Calculate horizontal and vertical sine waves with chromatic shifts\n    vec3 color1 = hsl2rgb(vec3(0.6 + sin(iTime * 0.5) * 0.2, 0.7, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.2 + cos(iTime * 0.5) * 0.2, 0.7, 0.8));\n    \n    // Create horizontal and vertical sine waves with noise\n    float wave1 = sin(st.x * freq + iTime) * 0.5 + 0.5;\n    float wave2 = sin(st.y * freq + iTime * 0.7 + 3.14159) * 0.5 + 0.5;\n    \n    // Add noise to create turbulence effect\n    vec2 noiseUV = st * 0.5 + 0.5;\n    float noiseVal = noise(noiseUV);\n    wave1 += noiseVal * 0.3;\n    wave2 += noiseVal * 0.3;\n    \n    // Combine the waves and colors\n    vec3 finalColor = color1 * wave1 + color2 * wave2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_503.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate time\n    float time = iTime * 0.5;\n    \n    // Create sine wave patterns in both x and y directions\n    vec2 st = uv * 8.0; // Scale coordinates for more waves\n    float waveX = sin(st.x + time) * 0.5 + 0.5;\n    float waveY = sin(st.y + time + PI/2.0) * 0.5 + 0.5;\n    \n    // Combine waves and add noise\n    float wave = (waveX + waveY) * 0.5;\n    wave += turbulent(vec3(uv * 4.0, time)) * 0.3;\n    \n    // Create rotating color palette using HSL\n    vec3 colorHSL = vec3(\n        mod(time * 0.2 + uv.x * 2.0 + uv.y * 3.0, 1.0), // Hue\n        0.7 + wave * 0.3, // Saturation\n        0.5 + sin(time + uv.x * PI) * 0.5 // Lightness\n    );\n    \n    // Convert to RGB and apply fog based on distance from center\n    vec3 color = hsl2rgb(colorHSL);\n    float depth = length(uv);\n    color *= exp(-depth * 0.1); // Fog effect\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_504.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a basic sine wave pattern\n    float speed = 5.0;\n    float frequency = 3.0;\n    \n    // Calculate position with time offset\n    vec2 pos = uv * 2.0 - 1.0;\n    float timeOffset = iTime * speed;\n    \n    // Create flowing lines using sine wave and noise\n    float lineValue = sin(pos.x * frequency + timeOffset) * 0.5 + 0.5;\n    lineValue += noise(vec3(uv * 4.0, iTime)) * 0.2; // Add noise for texture\n    \n    // Create color shifts using sine functions\n    vec3 hslColor = vec3(\n        sin(iTime * 0.5) * 0.5 + 0.5, // Hue variation over time\n        1.0, // Saturation\n        lineValue // Lightness based on line value\n    );\n    \n    // Convert HSL to RGB and add turbulence effect\n    vec3 color = hsl2rgb(hslColor);\n    float turb = turbulent(vec3(uv * 4.0, iTime)) * 0.5 + 0.5;\n    color *= turb; // Apply turbulence for dynamic intensity\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_505.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add animation over time\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create undulating sine wave patterns\n    float wave1 = sin(st.x * 0.5 + iTime) * 0.5;\n    float wave2 = cos(st.y * 0.7 - iTime) * 0.3;\n    \n    // Combine waves and add noise for texture\n    float d = sin(wave1 + wave2 + st.x*0.2 + st.y*0.3);\n    d += turbulent(vec2(uv * 5.0 + iTime)) * 0.4;\n    \n    // Create vibrant color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1, PI),   // Hue that changes over time\n        0.8,                   // Saturation\n        0.5 + d * 0.4          // Brightness modulation by wave pattern\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_506.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create hexagonal pattern using sine waves and turbulence\n    float hexPattern = sin(a * 6.0 + iTime); // Hexagonal symmetry\n    hexPattern += turbulent(vec3(st * 2.0, iTime)) * 0.5; // Add turbulence\n    \n    // Pulsating color effect\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1 + a * 0.5, 1.0), // Hue variation over time and angle\n        0.7, // Saturation\n        0.5 + sin(iTime) * 0.4 // Pulsating lightness\n    ));\n    \n    // Combine effects with circular mask\n    float mask = smoothstep(0.9, 1.0, r);\n    return vec4(color * hexPattern * mask, 1.0);\n}"
  },
  "data_507.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates around center\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    \n    // Create layered sine waves with time-based animation\n    float wave1 = sin(iTime + length(st)*5.0) * 0.5;\n    float wave2 = sin(iTime*0.8 + length(st)*3.0 + 1.57) * 0.4;\n    \n    // Add turbulence for organic feel\n    vec2 noiseUV = st * 0.5 + iTime*0.2;\n    float turb = turbulent(noiseUV);\n    \n    // Create color gradients using HSL\n    vec3 color1 = hsl(0.6 + sin(iTime)*0.2, 0.8, 0.7);\n    vec3 color2 = hsl(0.4 + cos(iTime*0.9), 0.8, 0.6);\n    \n    // Combine waves and colors\n    float blend = (wave1 + wave2 + turb) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, blend);\n    \n    // Add lighting effect\n    float light = sin(iTime*0.5 + radius*4.0) * 0.5 + 0.5;\n    finalColor *= light;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_508.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create a grid of squares with rotation\n    vec2 st = fract(uv * 100.0) - 0.5;\n    float speed = 0.5;\n    float time = iTime * speed;\n    \n    // Rotate each square based on its position and time\n    vec2 pos = vec2(\n        cos(time) * st.x - sin(time) * st.y,\n        sin(time) * st.x + cos(time) * st.y\n    );\n    \n    // Calculate color transitions using HSL\n    float hue = (pos.x + pos.y + time) * 0.5;\n    vec3 hslColor = hsl(hue, 1.0, 0.5);\n    \n    // Add noise and turbulence for more interesting patterns\n    float noiseScale = 0.1;\n    float noiseValue = noise(vec2(pos.x * noiseScale, pos.y * noiseScale));\n    float turbulentValue = turbulent(vec3(pos.x * noiseScale, pos.y * noiseScale, time));\n    \n    // Combine colors with noise and turbulence\n    color += hslColor * (0.5 + 0.5 * noiseValue);\n    color += vec3(0.1) * turbulentValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_509.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to -1.0 to 1.0 range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add time-based movement\n    float time = iTime * 0.5;\n    st.x += sin(time) * 0.5;\n    st.y += cos(time) * 0.3;\n    \n    // Create sine wave patterns with varying frequencies\n    float waveX = sin(st.x * 4.0 + time) * 0.5;\n    float waveY = sin(st.y * 6.0 - time * 2.0) * 0.5;\n    \n    // Combine waves and add turbulence\n    float factor = (waveX + waveY) * 0.5;\n    factor += turbulent(vec3(st.x, st.y, time)) * 0.3;\n    \n    // Create dynamic color shifts using HSL\n    vec3 hslColor = vec3(\n        sin(time * 0.2) * 0.5 + 0.5,\n        0.7,\n        0.8 + factor * 0.2\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Mix colors based on wave pattern\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(1.0, 0.5, 0.2),\n        smoothstep(-1.0, 1.0, factor)\n    );\n    \n    return vec4(finalColor * (1.0 + abs(factor) * 0.5), 1.0);\n}"
  },
  "data_51.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing patterns with time-based movement\n    vec2 st = uv * 5.0 + vec2(sin(iTime)*3.0, cos(iTime*0.7)*2.0);\n    \n    // Generate multi-scale noise patterns\n    float n1 = turbulent(st * 0.5) * 0.5;\n    float n2 = turbulent(st * 0.8 + 123.456) * 0.3;\n    float n3 = noise(vec3(st, iTime*0.1)) * 0.2;\n    \n    // Combine patterns with color\n    vec3 color = hsl(\n        sin(iTime*0.3 + st.x*2.0) * 0.5 + 0.5,\n        0.7 + n1 * 0.3,\n        0.5 + (n1 + n2 + n3) * 0.3\n    );\n    \n    // Add depth and movement to the color\n    color = hsl2rgb(color);\n    color *= sin(iTime*0.2 + uv.x * pi) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_510.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base pattern with rotating sine waves\n    float time = iTime * 0.5;\n    \n    // Animate UV coordinates with time\n    vec2 st = uv * 10.0 + vec2(time, time);\n    \n    // Create rotating sine wave patterns\n    float sinX = sin(st.x * 0.5 + time) * 0.5 + 0.5;\n    float sinY = sin(st.y * 0.5 + time + PI/2.0) * 0.5 + 0.5;\n    \n    // Combine sine waves with noise for complexity\n    vec3 colorBase = vec3(sinX, sinY, 0.0);\n    float noiseValue = noise(vec2(uv.x*10.0 + time, uv.y*10.0 + time));\n    \n    // Add turbulence for plasma effect\n    float turb = turbulent(vec2(uv * 5.0 + time));\n    \n    // Combine all elements and convert to RGB\n    vec3 finalColor = hsl2rgb(vec3(\n        (colorBase.x + noiseValue) * 0.5,\n        (colorBase.y + turb) * 0.7,\n        0.8\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_511.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.1; // Add rotation over time\n    \n    // Create a galaxy-like pattern using noise and turbulence\n    float galaxy = turbulent(vec3(r * 5.0, theta * 4.0, iTime * 0.1));\n    \n    // Add star glow effect using high-frequency noise\n    float stars = noise(vec3(st * 200.0, iTime)) * 0.5 + 0.5;\n    stars = smoothstep(0.95, 1.0, stars);\n    \n    // Create color gradient for the galaxy\n    vec3 galaxyColor = hsl2rgb(vec3(\n        sin(r * 2.0 + iTime) * 0.4 + 0.6,\n        0.7,\n        0.5 + 0.5 * sin(theta * 3.0 + iTime)\n    ));\n    \n    // Create star color\n    vec3 starColor = vec3(1.0);\n    \n    // Combine galaxy and stars with glow effect\n    vec3 finalColor = mix(\n        galaxyColor,\n        starColor,\n        stars * exp(-r * 2.0) // Star glow falloff\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_512.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create three interweaving sine waves with different parameters\n    vec3 amplitudes = vec3(0.1, 0.2, 0.3);\n    vec3 speeds = vec3(1.0, 1.3, 1.6);\n    vec3 phases = vec3(0.0, 0.5, 1.0);\n    \n    // Calculate wave positions\n    vec3 waveX = sin(uv.x * 20.0 + time * speeds + phases) * amplitudes;\n    vec3 waveY = cos(uv.y * 20.0 + time * speeds + phases) * amplitudes;\n    \n    // Combine waves and create interference pattern\n    float combined = (waveX.y + waveY.x + waveX.z + waveY.z) * 0.5 + 0.5;\n    \n    // Add turbulence for dynamic movement\n    vec2 turbulentUV = uv + turbulent(uv * 10.0 + time) * 0.1;\n    combined += turbulent(turbulentUV * 5.0) * 0.3;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 baseColor = hsl2rgb(vec3(time * 0.1, 0.7, 0.8));\n    vec3 shiftColor = hsl2rgb(vec3((time + uv.x * 5.0) * 0.1, 0.6, 0.7));\n    \n    // Mix colors based on wave pattern\n    vec3 finalColor = mix(baseColor, shiftColor, combined);\n    \n    // Add brightness variation\n    finalColor *= sin(time * 2.0 + uv.y * pi) * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_513.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float t = iTime * 0.5;\n    \n    // Rotating sine wave pattern\n    vec2 q = uv + vec2(sin(uv.y * 3.0 + t), sin(uv.x * 3.0 + t));\n    q += vec2(0.5, 0.5); // Center the coordinates\n    \n    // Create color components with time-based variation\n    float r = sin(q.x * 4.0 + t) * cos(q.y * 4.0 - t);\n    float g = sin(q.x * 4.0 - t) * cos(q.y * 4.0 + t);\n    float b = noise(vec2(t, q.x)) * 0.5 + 0.5;\n    \n    // Convert to HSL and shift hue over time\n    vec3 hslColor = vec3(\n        (uv.x + uv.y + t) * 0.5,\n        0.7,\n        0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine patterns and colors\n    vec3 finalColor = vec3(r, g, b) * rgbColor;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_514.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Rotate over time\n    \n    // Create hexagonal grid pattern\n    vec2 polar = vec2(r, theta);\n    vec2 gridUV = polar * 4.0;\n    vec2 gridPos = floor(gridUV);\n    \n    // Calculate color based on UV and time\n    float timeFactor = sin(iTime * 0.5 + gridPos.x * pi) * 0.5 + 0.5;\n    vec3 cyan = vec3(0.0, 1.0, 1.0);\n    vec3 magenta = vec3(1.0, 0.0, 1.0);\n    vec3 color = mix(cyan, magenta, timeFactor);\n    \n    // Add procedural noise for dynamic effect\n    float noiseValue = turbulent(vec2(gridPos.x, iTime)) * 0.5 + 0.5;\n    color *= noiseValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_515.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv * 1.5); // Scale UV coordinates\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create square pattern using sine and cosine of angles\n    vec2 st = vec2(sin(angle), cos(angle)) * radius;\n    \n    // Add turbulence for dynamic movement\n    float turb = turbulent(st * 0.5 + iTime);\n    \n    // Calculate color components with time-based fading\n    vec3 color = hsl(\n        fract(turb * 0.5 + iTime) * 360.0, // Hue\n        0.7 + sin(iTime * 0.2) * 0.3,       // Saturation\n        0.5 + turb * 0.5                  // Lightness\n    );\n    \n    // Add depth perception using radius and noise\n    float depth = radius * (1.0 - turbulent(vec2(radius, iTime)));\n    color *= mix(0.8, 1.0, smoothstep(0.0, 1.0, depth));\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_516.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base pattern\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Add rotation to create movement\n    float angle = iTime * 0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    st = rot * st;\n    \n    // Generate multiple layers of noise and turbulence\n    float t1 = turbulent(st * 0.5);\n    float t2 = turbulent((st + iTime) * 0.75);\n    float t3 = turbulent((st * 0.25 + vec2(iTime)) * 0.5);\n    \n    // Combine layers with different weights\n    float combined = (t1 * 0.5 + t2 * 0.3 + t3 * 0.2) * 0.5 + 0.5;\n    \n    // Create dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + combined * 0.2) * pi,\n        0.7 + sin(iTime * 0.5 + uv.x * pi) * 0.3,\n        0.6 + cos(uv.y * pi + iTime) * 0.4\n    );\n    \n    // Convert HSL to RGB and apply the combined noise pattern\n    vec3 color = hsl2rgb(hslColor);\n    color *= combined;\n    \n    // Add some global animation\n    color += sin(iTime * 0.5 + uv.x * pi) * 0.1;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_517.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Generate 10 points with random orbits\n    for(int i = 0; i < 10; i++) {\n        float t = iTime + float(i)*0.5;\n        \n        // Calculate point position using orbit\n        vec2 pos = vec2(\n            sin(t*0.7 + float(i)*0.3) * (0.5 + noise(vec3(t, float(i), 0.0)) * 0.3),\n            cos(t*0.6 + float(i)*0.4) * (0.5 + noise(vec3(t, float(i)+1.0, 0.0)) * 0.3)\n        );\n        \n        // Calculate distance from current fragment to point\n        vec2 delta = uv - pos;\n        float dist = length(delta);\n        \n        // Add glowing effect based on distance\n        finalColor += hsl2rgb(vec3(\n            sin(iTime + float(i)*0.5) * 0.5 + 0.5,\n            1.0,\n            0.8\n        )) / (dist * dist * 100.0);\n        \n        // Add connection lines between points\n        for(int j = i+1; j < 10; j++) {\n            vec2 pos2 = vec2(\n                sin(t*0.7 + float(j)*0.3) * (0.5 + noise(vec3(t, float(j), 0.0)) * 0.3),\n                cos(t*0.6 + float(j)*0.4) * (0.5 + noise(vec3(t, float(j)+1.0, 0.0)) * 0.3)\n            );\n            \n            vec2 lineDir = normalize(pos2 - pos);\n            float lineDist = length(uv - pos);\n            \n            // Create glowing lines\n            finalColor += hsl2rgb(vec3(\n                sin(iTime + float(j)*0.5) * 0.5 + 0.5,\n                1.0,\n                0.6\n            )) / (lineDist * lineDist * 200.0);\n        }\n    }\n    \n    // Add turbulence effect\n    finalColor *= 1.0 + turbulent(vec3(uv, iTime)) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_518.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float theta = atan2(st.y, st.x) + iTime;  // Add time for rotation\n    \n    // Create hexagonal pattern using multiple noise layers\n    float n1 = turbulent(vec3(st * 10.0, iTime));\n    float n2 = turbulent(vec3(st * 5.0, iTime)) * 0.5;\n    float n3 = turbulent(vec3(st * 2.0, iTime)) * 0.25;\n    \n    // Combine noise layers\n    float pattern = (n1 + n2 + n3) / 1.75;\n    \n    // Create color gradient based on rotation angle\n    vec3 hslColor = vec3(theta * 0.1, 0.8, sin(radius * 4.0 + iTime * 0.5));\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Mix pattern with color and output\n    float finalValue = (pattern + sin(theta) * 0.5 + 0.5) * radius;\n    return vec4(finalValue * rgbColor, 1.0);\n}"
  },
  "data_519.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying wave patterns\n    float t = iTime * 0.5;\n    \n    // Interweaving sine waves with RGB color transitions\n    vec3 waves = vec3(\n        sin(uv.x * 10.0 + t) + cos(uv.y * 10.0 + t),\n        sin(uv.x * 10.0 + t + 2.0) + cos(uv.y * 10.0 + t - 2.0),\n        sin(uv.x * 10.0 + t - 4.0) + cos(uv.y * 10.0 + t + 4.0)\n    );\n    \n    // Add noise and turbulence for more dynamic patterns\n    vec2 st = uv * 5.0;\n    float n = noise(st + vec2(t, t)) * 0.5 + 0.5;\n    waves += turbulent(vec3(uv, t)) * 0.4;\n    \n    // Convert to HSL and back to RGB for smooth color transitions\n    vec3 hslColor = vec3(\n        (waves.x + waves.y + waves.z) * 0.333,\n        0.7,\n        0.5 + n * 0.5\n    );\n    \n    // Output the final color with alpha channel\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_52.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 noise1 = vec3(turbulent(uv * 5.0 + iTime));\n    vec3 noise2 = vec3(turbulent(uv * 10.0 - iTime));\n    \n    float time = sin(iTime * 0.5);\n    \n    vec3 color = hsl(\n        (noise1.x + noise2.y) * 0.5 + 0.5,\n        (noise1.y + noise2.x) * 0.5 + 0.5,\n        abs(time)\n    );\n    \n    float mixAmount = turbulent(uv * 3.0 + iTime);\n    color = mix(color, hsl2rgb(vec3(0.0)), mixAmount);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_520.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base pulsation frequency\n    float basePulse = sin(iTime * 0.5 + 1.0);\n    \n    // Dynamic color components based on time and position\n    vec3 colorBase = hsl(\n        0.6 + 0.4 * sin(iTime * 0.2 + uv.x * 8.0),\n        0.7,\n        0.5\n    );\n    \n    // Add turbulence for dynamic movement\n    float turb = turbulent(uv * 10.0 + vec2(iTime));\n    \n    // Create distance field from center\n    vec2 center = vec2(0.5, 0.5);\n    float distanceFromCenter = length(uv - center) * 2.0;\n    \n    // Layered sine functions for pulsation effect\n    float layer1 = sin(distanceFromCenter * 3.0 + iTime) * 0.5;\n    float layer2 = sin(distanceFromCenter * 6.0 + iTime * 0.7) * 0.4;\n    float layer3 = sin(distanceFromCenter * 9.0 + iTime * 1.2) * 0.3;\n    \n    // Combine layers and add turbulence\n    float intensity = (layer1 + layer2 + layer3) * 0.5 + turb * 0.3;\n    \n    // Final color calculation with dynamic hue shift\n    vec3 finalColor = hsl2rgb(vec3(\n        0.6 + 0.4 * sin(iTime * 0.2 + distanceFromCenter),\n        0.7 + turb * 0.1,\n        0.5 + intensity * 0.3\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_521.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate the grid\n    float scale = 10.0;\n    vec2 st = floor(uv * scale);\n    \n    // Add time-based rotation\n    float timeRotation = sin(iTime * 0.5) * 0.5 + 0.5;\n    mat2 rot = mat2(cos(timeRotation), -sin(timeRotation),\n                    sin(timeRotation), cos(timeRotation));\n    \n    // Get noise value for each cell\n    vec3 noiseVal = texture(iChannel0, (st + 1.0) / scale).xyz;\n    float rand = noiseVal.x * 0.5 + 0.5;\n    \n    // Create rotating pattern within each cell\n    vec2 pos = uv * scale - st;\n    pos = rot * (pos - 0.5) + 0.5;\n    \n    // Add turbulence to position\n    vec3 dist = abs(vec3(pos.x, pos.y, sin(iTime)));\n    float turb = turbulent(dist * 10.0);\n    \n    // Calculate color based on distance and time\n    float d = length(pos - 0.5) + turb * 0.2;\n    float hue = fract(d + iTime * 0.1 + rand);\n    \n    // Convert to RGB and output\n    vec3 color = hsl2rgb(vec3(hue, 0.7, 0.6));\n    return vec4(color, 1.0);\n}"
  },
  "data_522.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create dynamic sine wave patterns with varying frequencies\n    float x = sin(uv.x * 8.0 + iTime * 2.0) * 0.5 + 0.5;\n    float y = sin(uv.y * 4.0 + iTime * 1.5) * 0.5 + 0.5;\n    \n    // Combine patterns and add turbulence\n    vec2 st = uv * 8.0;\n    float pattern = (x + y) * 0.5;\n    pattern += turbulent(st + iTime) * 0.3;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(pattern * 0.6 + iTime, 1.0, 0.5));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_523.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += iTime * 0.5;\n    // Create rotating sine wave pattern\n    float sinWave = sin(theta - iTime) * 0.5 + 0.5;\n    float cosWave = cos(theta + iTime) * 0.5 + 0.5;\n    \n    // Combine waves and add turbulence\n    float combined = (sinWave + cosWave) * 0.5;\n    combined += turbulent(vec2(r, theta)) * 0.3;\n    // Create color based on amplitude\n    vec3 color = hsl(\n        mod(theta * 4.0 + iTime, 1.0),  // Hue\n        0.7 + turbulent(vec2(r, theta + iTime)) * 0.3,  // Saturation\n        combined * 0.6 + 0.4  // Lightness based on amplitude\n    );\n    // Add some noise to the background\n    vec3 bg = hsl(\n        mod(theta * 2.0 + iTime, 1.0),\n        0.5,\n        0.1 + noise(vec2(r, theta)) * 0.1\n    );\n    // Mix foreground and background based on wave amplitude\n    color = mix(bg, color, combined);\n    return vec4(color, 1.0);\n}"
  },
  "data_524.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Rotate over time\n    \n    // Create square pattern using polar coordinates\n    float sa = sin(a);\n    float ca = cos(a);\n    vec2 rotated = vec2(ca * st.x + sa * st.y, -sa * st.x + ca * st.y);\n    \n    // Calculate distance from square edges\n    float d1 = abs(rotated.x) + abs(rotated.y);\n    float d2 = max(abs(rotated.x), abs(rotated.y));\n    float dist = min(d1, d2);\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(a * 0.5 + iTime, 1.0, 0.5);\n    vec3 finalColor = hsl2rgb(color) * (1.0 - turbulent(vec3(uv * 4.0, iTime)));\n    \n    // Combine patterns and output\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_525.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of triangles\n    vec2 pos = floor(uv * 10.0);\n    vec2 cell = fract(pos);\n    \n    // Add rotation based on time and position\n    float angle = iTime * 0.5 + noise(vec3(pos, iTime)) * 0.5;\n    \n    // Create three points for the triangle\n    vec2 p1 = vec2(0.5, 0.5) + vec2(cos(angle), sin(angle)) * 0.4;\n    vec2 p2 = vec2(0.5, 0.5) + vec2(cos(angle + 120.0 * pi/180.0), sin(angle + 120.0 * pi/180.0)) * 0.4;\n    vec2 p3 = vec2(0.5, 0.5) + vec2(cos(angle - 120.0 * pi/180.0), sin(angle - 120.0 * pi/180.0)) * 0.4;\n    \n    // Calculate barycentric coordinates to check if point is inside triangle\n    vec2 v = cell - p1;\n    vec2 w = p2 - p1;\n    vec2 u = p3 - p1;\n    \n    float dot00 = dot(w, w);\n    float dot01 = dot(w, u);\n    float dot02 = dot(w, v);\n    float dot11 = dot(u, u);\n    float dot12 = dot(u, v);\n    \n    float denom = dot00 * dot11 - dot01 * dot01;\n    float s = (dot11 * dot02 - dot01 * dot12) / denom;\n    float t = (dot00 * dot12 - dot01 * dot02) / denom;\n    \n    // Check if point is inside triangle\n    bool inside = s >= 0.0 && t >= 0.0 && s + t <= 1.0;\n    \n    // Calculate color based on position and time\n    vec3 color = hsl(\n        (pos.x + pos.y) * 0.1 + iTime,\n        0.7 + turbulent(vec2(cell)) * 0.3,\n        0.5 + min(s, t) * 0.5\n    );\n    \n    // Fade color based on proximity to center of triangle\n    float fade = smoothstep(0.0, 1.0, (1.0 - length(cell - vec2(0.5, 0.5))) * 4.0);\n    color *= fade;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_526.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x);\n    \n    // Create pulsing effect based on time and radius\n    float pulse = sin(iTime * 0.5 + r * 2.0) * 0.5 + 0.5;\n    pulse *= sin(iTime * 0.3 + r * 4.0) * 0.5 + 0.5;\n    \n    // Create rotating pattern based on angle and time\n    float rotation = theta / (pi * 2.0) + iTime * 0.1;\n    vec3 color = hsl2rgb(vec3(rotation, 1.0, pulse));\n    \n    // Add turbulence effect\n    float noiseFactor = turbulent(vec3(pos.x, pos.y, iTime)) * 0.5 + 0.5;\n    color *= noiseFactor;\n    \n    // Create radial rays effect\n    float angleOffset = theta / (pi * 2.0) * 10.0;\n    float rayStrength = sin(angleOffset + iTime) * 0.5 + 0.5;\n    rayStrength = pow(rayStrength, 4.0);\n    \n    // Combine effects and output\n    vec3 finalColor = color * (rayStrength * pulse) * (1.0 - r * 0.2);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_527.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Create hexagonal grid pattern\n    vec2 st = uv * 10.0 - 5.0;\n    vec2 grid = floor(st + 0.5);\n    \n    // Calculate polar coordinates for each cell\n    vec2 offset = fract(st) - 0.5;\n    float theta = atan(offset.y, offset.x) + sin(iTime * 0.5) * 3.14;\n    float r = length(offset);\n    \n    // Create rotating hexagon pattern\n    mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    vec2 rotated = rot * (offset / r) * 0.5;\n    \n    // Calculate distance from center and edges\n    float d1 = length(rotated + offset);\n    float d2 = length(offset);\n    \n    // Create gradient borders and pulsating centers\n    float border = smoothstep(0.4, 0.6, d2);\n    float centerPulse = sin(iTime * 3.0 + r * 5.0) * 0.5 + 0.5;\n    float inner = smoothstep(0.3, 0.7, d1);\n    \n    // Color transitions using HSL\n    vec3 color1 = hsl(sin(iTime * 0.2 + grid.x * 0.1) * 0.6 + 0.2, 0.8, 0.5);\n    vec3 color2 = hsl(sin(iTime * 0.2 + grid.y * 0.1) * 0.6 + 0.7, 0.7, 0.4);\n    \n    // Combine elements\n    finalColor += border * color2;\n    finalColor += inner * centerPulse * color1;\n    \n    // Add noise for extra texture\n    float noiseVal = noise(vec3(uv * 5.0, iTime)) * 0.1;\n    finalColor *= 1.0 + noiseVal;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_528.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create a rotating geometric pattern using sine waves\n    float pattern = sin(theta * 4.0 + iTime) * cos(r * 10.0 - iTime);\n    \n    // Generate pulsating color gradients\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.5, 1.0), // Pulsating hue\n        0.7,\n        0.5 + 0.5 * sin(iTime) // Pulsating lightness\n    ));\n    \n    // Add noise and turbulence for organic movement\n    float noiseValue = turbulent(vec3(uv * 2.0, iTime));\n    color *= 1.0 + 0.2 * noiseValue;\n    \n    // Combine pattern with color\n    vec4 finalColor = vec4(color * (0.5 + 0.5 * pattern), 1.0);\n    \n    return finalColor;\n}"
  },
  "data_529.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating pattern using sin/cos functions\n    float angle = time + length(uv) * 2.0 * PI;\n    vec2 rotatedUV = uv * vec2(cos(angle), sin(angle));\n    \n    // Generate plasma effect using turbulence and noise\n    float t1 = turbulent(rotatedUV * 50.0 + time);\n    float t2 = turbulent(rotatedUV * 25.0 + time * 0.5);\n    \n    // Create color shifts\n    vec3 colorShifts = vec3(\n        sin(time) * 0.5 + 0.5,\n        sin(time * 1.3) * 0.5 + 0.5,\n        sin(time * 2.0) * 0.5 + 0.5\n    );\n    \n    // Combine effects and convert to RGB\n    vec3 finalColor = hsv2rgb(vec3(\n        t1 * 360.0 + time * 180.0,\n        1.0,\n        1.0\n    )) * colorShifts;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_53.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Apply turbulence distortion to UV coordinates\n    vec2 distortedUV = uv + turbulent(uv * 10.0 + iTime) * 0.3;\n    \n    // Generate noise patterns at different scales\n    float noise1 = noise(distortedUV * 5.0);\n    float noise2 = noise(distortedUV * 10.0 + vec2(1.0, 2.0));\n    \n    // Create color shifts using HSL conversion\n    vec3 baseColor = hsl(\n        sin(iTime) * 0.5 + 0.5,\n        0.7,\n        0.6\n    );\n    \n    // Add glitch effects with noise and time\n    vec3 finalColor = mix(\n        baseColor,\n        hsl(\n            (sin(iTime * 2.0) + noise1) * 0.5 + 0.5,\n            0.8,\n            (noise2 + sin(uv.x * pi)) * 0.5 + 0.5\n        ),\n        abs(sin(iTime)) * 0.3 + 0.2\n    );\n    \n    // Add some turbulence-based color variation\n    finalColor += turbulent(vec3(distortedUV, iTime)) * 0.1;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_530.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Normalize UV coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    \n    // Create flower shape using rose curve equation\n    float petalRadius = sin(a * 4.0 + iTime) * 0.5 + 0.5;\n    float flowerMask = step(r, petalRadius * 0.8);\n    \n    // Calculate color based on angle relative to time\n    vec3 hslColor = vec3((a / (pi * 2.0) + 0.5) * 360.0, 1.0, 1.0);\n    vec3 petalColor = hsl2rgb(hslColor);\n    \n    // Add pulsating effect\n    float pulse = sin(iTime * 0.5) * 0.2 + 0.8;\n    petalColor *= pulse;\n    \n    // Create background color\n    vec3 bgColor = vec3(0.1, 0.1, 0.2);\n    bgColor += sin(iTime * 0.1) * 0.1;\n    \n    // Combine colors\n    vec3 finalColor = mix(bgColor, petalColor, flowerMask);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_531.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    float time = iTime * 0.5;\n    \n    // Create multiple circles with different properties\n    for (int i = 0; i < 4; i++) {\n        // Calculate circle center with pulsing effect\n        float angle = float(i) * pi * 0.5 + time;\n        vec2 center = vec2(sin(angle) * 0.3, cos(angle) * 0.3);\n        \n        // Calculate distance from current point to circle center\n        vec2 toCircle = uv - center;\n        float dist = length(toCircle);\n        \n        // Create pulsing radius with time offset\n        float radius = (sin(time + float(i)) * 0.4) + 0.5;\n        \n        // Check if inside the circle and accumulate color\n        if (dist < radius) {\n            // Calculate hue based on distance and time\n            float hue = dist * 3.0 + time * 2.0 + float(i) * 0.5;\n            \n            // Convert HSL to RGB and add to color\n            vec3 circleColor = hsl(hue, 1.0, 0.5);\n            color += circleColor * (1.0 - dist / radius) * 0.8;\n        }\n    }\n    \n    // Add some noise for extra detail\n    float noiseValue = noise(uv * 4.0 + time);\n    color += vec3(noiseValue * 0.2);\n    \n    return vec4(color, max(0.5, turbulent(uv * 2.0 + time)));\n}"
  },
  "data_532.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern with time\n    vec2 st = uv * 10.0;\n    float time = iTime * 0.5;\n    \n    // Polar coordinates for vortex effect\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add turbulence to create dynamic movement\n    angle += turbulent(vec3(angle, radius, time)) * 0.5;\n    radius += turbulent(vec2(radius, time)) * 0.3;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        sin(time + angle) * 180.0,\n        0.6 + noise(vec2(time, 0.0)) * 0.4,\n        0.5 + sin(radius * 0.5 + time) * 0.5\n    );\n    \n    // Add depth and layers\n    float depth = noise(vec3(st.x*0.5, st.y*0.5, time)) * 0.2;\n    color += hsl(\n        sin(time + angle + PI) * 180.0,\n        0.4,\n        0.3 + noise(vec2(radius*0.2, time)) * 0.2\n    ) * depth;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_533.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create orbiting shapes using sine waves with increasing frequency\n    float shape = sin(a * 4.0 + iTime * 2.0) * 0.5 + 0.5;\n    shape += sin(a * 8.0 - iTime * 3.0) * 0.3;\n    \n    // Add turbulence for dynamic variations\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float turb = turbulent(noiseUV);\n    \n    // Combine shape and noise\n    float pattern = shape * (0.5 + turb * 0.5);\n    \n    // Create RGB shifts using HSL color space\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2) * 360.0, // Hue variation over time\n        1.0 - abs(r - 0.5) * 2.0,   // Saturation based on distance from center\n        pattern                     // Lightness based on shape and noise\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_534.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 uv_centered = uv - 0.5;\n    \n    // Calculate distance from center\n    float r = length(uv_centered);\n    \n    // Create a pulsating effect using time\n    float time_factor = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Generate base color using HSL to RGB conversion\n    vec3 color_base = hsl2rgb(vec3(\n        mod(r * 10.0 + iTime, 1.0),  // Hue varies with radius and time\n        0.7 + noise(vec3(uv_centered * 5.0, iTime)) * 0.3,  // Saturation with noise\n        0.5 + sin(r * 2.0 - iTime) * 0.5  // Brightness variation\n    ));\n    \n    // Add turbulence effect\n    float turbulence = turbulent(vec3(uv_centered * 10.0, iTime)) * 0.5;\n    \n    // Create a swirling pattern using polar coordinates\n    vec2 polar = vec2(\n        cos(r * 8.0 - iTime) * length(uv_centered),\n        sin(r * 8.0 - iTime) * length(uv_centered)\n    );\n    \n    // Combine effects and modulate by radius\n    vec3 final_color = mix(\n        color_base,\n        hsl2rgb(vec3(\n            mod(r * 5.0 + iTime, 1.0),\n            0.9,\n            0.7\n        )),\n        turbulence * time_factor\n    ) * (1.0 - r * 0.8);\n    \n    // Add pulsating glow effect\n    final_color += vec3(\n        noise(vec3(uv_centered * 2.0, iTime)) * time_factor,\n        noise(vec3(uv_centered * 3.0, iTime + 1.0)) * time_factor,\n        noise(vec3(uv_centered * 4.0, iTime + 2.0)) * time_factor\n    ) * 0.5;\n    \n    return vec4(final_color, 1.0);\n}"
  },
  "data_535.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base terrain height using perlin noise\n    float time = iTime * 0.5;\n    vec3 pos = vec3(uv * 10.0, time);\n    \n    // Create flowing movement\n    float flow = sin(time + uv.x * 2.0) * 0.5;\n    pos.y += flow;\n    \n    // Generate terrain with multiple noise layers\n    float height = noise(pos * 0.3) * 0.5;\n    height += noise(pos * 0.6) * 0.3;\n    height += noise(pos * 1.2) * 0.2;\n    \n    // Create color transitions based on height and time\n    vec3 color = hsl(\n        (height + sin(time + uv.x)) * 0.5 + 0.5,\n        0.7,\n        abs(sin(time + height * 2.0) * 0.5 + 0.5)\n    );\n    \n    // Convert HSL to RGB\n    color = hsl2rgb(color);\n    \n    // Add fog effect based on distance from camera\n    float fogFactor = smoothstep(0.0, 1.0, length(uv));\n    vec3 fogColor = vec3(0.2, 0.3, 0.5) * (sin(time * 0.5) + 0.5);\n    \n    // Combine terrain color with fog\n    color = mix(color, fogColor, fogFactor);\n    \n    // Add ambient lighting based on height\n    float light = sin(height * pi + time) * 0.5 + 0.5;\n    color *= vec3(light);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_536.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate coordinates over time\n    vec2 st = uv * 5.0 + sin(iTime * 0.5) * 0.5;\n    \n    // Create flowing pattern using turbulence\n    float flow1 = turbulent(st + vec2(sin(iTime), cos(iTime))) * 0.5 + 0.5;\n    float flow2 = noise(st * 0.1 + iTime) * 0.5 + 0.5;\n    \n    // Create rotating color wheel effect\n    vec3 color1 = hsl(flow1 * 360.0, 0.7, 0.6);\n    vec3 color2 = hsl((flow1 + flow2) * 360.0, 0.8, 0.5);\n    \n    // Combine patterns with color transformations\n    vec3 finalColor = mix(color1, color2, flow2);\n    finalColor *= sin(iTime) * 0.5 + 0.5;\n    \n    // Add noise variation\n    float n = noise(st * 0.5 + iTime * 0.2);\n    finalColor = mix(finalColor, vec3(n), 0.3);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_537.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern with hexagonal cells\n    vec2 st = uv * 10.0;\n    \n    // Add time-based movement to the grid\n    float speed = 0.5;\n    vec2 offset = vec2(sin(iTime * speed), cos(iTime * speed)) * 0.3;\n    st += offset;\n    \n    // Generate noise values for each cell\n    float n1 = noise(st);\n    float n2 = noise(st + vec2(1.0, 0.5));\n    \n    // Combine noise values to create a hexagonal pattern\n    float grid = mix(n1, n2, fract(st.x * 0.5 + st.y * 0.7071));\n    \n    // Add turbulence for dynamic movement\n    vec3 pos = vec3(uv * 5.0, iTime);\n    float turb = turbulent(pos) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(iTime + uv.x * 2.0) * 0.5 + 0.5,\n        sin(iTime + uv.y * 2.0) * 0.5 + 0.5,\n        0.7\n    );\n    \n    // Convert HSL to RGB and apply grid pattern\n    vec3 color = hsl2rgb(hslColor);\n    color *= mix(1.0, 0.5, abs(grid - turb));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_538.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise pattern\n    float speed = 0.5;\n    vec2 st = uv * 8.0; // Scale coordinates for more detail\n    \n    // Add movement over time\n    st.x += sin(iTime * speed + st.y * 3.0) * 0.5;\n    st.y += cos(iTime * speed + st.x * 3.0) * 0.5;\n    \n    // Compute turbulence\n    float turb = turbulent(st);\n    \n    // Create color shifts based on noise and time\n    vec3 color1 = hsl2rgb(vec3(0.6 + turb * 0.4, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.3 + turb * 0.4, 0.8, 0.7));\n    \n    // Mix colors based on position and time\n    float mixAmount = sin(iTime * 0.5 + st.x) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    // Add depth effect\n    finalColor *= 1.0 - length(uv) * 0.4;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_539.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Create a grid of lines using sine waves\n    float horizontal = sin(st.y + iTime * 0.5);\n    float vertical = sin(st.x + iTime * 0.5);\n    \n    // Calculate distance field for glowing effect\n    float glow = min(abs(horizontal), abs(vertical));\n    glow = 1.0 - smoothstep(0.0, 0.3, glow);\n    \n    // Add turbulence to create organic movement\n    vec2 noisePos = st * 0.5 + iTime;\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    \n    // Combine grid and turbulence for final pattern\n    float pattern = mix(horizontal, vertical, turb);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(iTime * 0.1, 0.7, 0.5));\n    \n    // Add pulsating brightness effect\n    float brightness = sin(iTime) * 0.5 + 0.5;\n    color *= brightness;\n    \n    // Final output with glow and pattern\n    return vec4(color * glow, 1.0);\n}"
  },
  "data_54.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a warping pattern using noise and turbulence\n    vec2 st = uv * 5.0;\n    float t = iTime * 0.5;\n    \n    // Add some movement to the coordinates\n    vec2 offset = vec2(sin(t + st.x), cos(t + st.y)) * 0.1;\n    vec2 new_uv = uv + offset;\n    \n    // Create a hexagonal pattern using polar coordinates\n    vec2 center = vec2(0.5, 0.5);\n    vec2 toCenter = new_uv - center;\n    float radius = length(toCenter) * 3.0;\n    float angle = atan2(toCenter.y, toCenter.x);\n    \n    // Add some turbulence and noise\n    float turb = turbulent(vec3(new_uv * 10.0, t));\n    float noiseVal = noise(vec3(new_uv * 5.0, t)) * 0.5 + 0.5;\n    \n    // Create a color based on angle and radius\n    vec3 color = hsl2rgb(vec3(angle / (2.0 * PI), radius / 10.0, noiseVal));\n    \n    // Add some geometric patterns\n    float circle = smoothstep(0.9, 1.0, radius);\n    float hexagon = sin(radius) * 0.5 + 0.5;\n    \n    // Combine everything with some blending\n    color *= mix(vec3(circle), vec3(hexagon), noiseVal);\n    color += vec3(turb * 0.2);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_540.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color for jungle background\n    vec3 baseColor = hsl(120.0, 0.5, 0.3);\n    \n    // Add atmospheric mist effect using noise\n    float mist = noise(uv * 0.5 + iTime * 0.1) * 0.5 + 0.5;\n    vec3 mistColor = hsl(180.0, 0.3, 0.2);\n    \n    // Create tree trunks using noise\n    float trunkNoise = noise(uv * 4.0 + iTime * 0.1);\n    vec3 trunkColor = hsl(120.0, 0.7, 0.2);\n    \n    // Add leaves detail with turbulence\n    float leafDetail = turbulent(uv * 8.0 + iTime) * 0.5 + 0.5;\n    vec3 leafColor = hsl(120.0, 0.6, 0.4);\n    \n    // Combine elements\n    vec3 finalColor = baseColor;\n    finalColor = mix(finalColor, mistColor, mist * 0.4);\n    finalColor = mix(finalColor, trunkColor, step(0.7, trunkNoise) * 0.5);\n    finalColor = mix(finalColor, leafColor, step(0.8, leafDetail) * 0.3);\n    \n    // Add distance fog\n    vec3 fogColor = hsl(120.0, 0.4, 0.1);\n    float depth = uv.y;\n    finalColor = mix(finalColor, fogColor, depth * 0.5);\n    \n    // Add dynamic highlights\n    float highlight = turbulent(uv * 16.0 + iTime * 2.0) * 0.5 + 0.5;\n    vec3 highlightColor = hsl(120.0, 0.8, 0.6);\n    finalColor = mix(finalColor, highlightColor, step(0.9, highlight) * 0.2);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_541.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern by adding time-based rotation\n    vec2 st = uv * 10.0 + vec2(sin(iTime), cos(iTime)) * 5.0;\n    \n    // Use noise and turbulence to create complex patterns\n    float t = turbulent(st);\n    float n = noise(vec3(st, iTime));\n    \n    // Create color variations using HSL\n    vec3 color1 = hsl2rgb(vec3(0.5 + t * 0.5, 0.7, 0.6));\n    vec3 color2 = hsl2rgb(vec3(0.3 + n * 0.5, 0.8, 0.7));\n    \n    // Combine colors with smooth variation\n    float blend = sin(iTime) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, blend);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_542.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise values\n    float n = noise(uv);\n    \n    // Add turbulence for more dynamic movement\n    vec3 pos3d = vec3(uv, iTime * 0.1);\n    float turb = turbulent(pos3d);\n    \n    // Calculate color shifts based on time and position\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.5 + n * 2.0) * PI,\n        0.7, // Saturation\n        0.6 // Lightness\n    ));\n    \n    // Create floating particle effect\n    vec2 movement = vec2(sin(iTime * 0.1 + uv.x * 3.0), cos(iTime * 0.2 + uv.y * 2.0)) * 0.5;\n    vec2 finalUV = uv + movement;\n    \n    // Add depth and glow effect\n    float dist = length(finalUV);\n    color *= (1.0 - dist * 0.3) * (1.0 + turb * 0.5);\n    \n    return vec4(color, max(0.0, 1.0 - dist * 2.0 + n * 0.5));\n}"
  },
  "data_543.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Add time-based rotation and some randomness\n    a += iTime * 0.5 + noise(vec3(uv * 10.0, iTime)) * 0.2;\n    // Create hexagonal pattern using polar coordinates\n    float hexDistance = length(vec2(\n        cos(a) * r,\n        sin(a) * r\n    ));\n    // Add turbulence for glowing effect\n    float glow = turbulent(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    float pattern = hexDistance * (1.0 - glow);\n    // Create vibrant color palette using HSL\n    vec3 hslColor = vec3(\n        mod(a * 6.0 + iTime, 2.0 * PI) / (2.0 * PI),\n        0.7,\n        0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Combine pattern and color\n    vec3 finalColor = mix(\n        vec3(0.0),\n        rgbColor,\n        smoothstep(0.8, 1.0, 1.0 - pattern)\n    );\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_544.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color with time-varying hue\n    vec3 baseColor = hsl2rgb(vec3(0.3 + 0.1*sin(iTime*0.5), 0.6, 0.8));\n    \n    // Create a noise-based pattern for trees and vines\n    float noiseScale = 0.1;\n    vec2 noisePos = uv * noiseScale + iTime * 0.1;\n    float mainNoise = noise(noisePos);\n    \n    // Add tree-like structures with varying sizes\n    float treeStrength = max(0.0, sin(iTime*0.7) * 0.5 + 0.5);\n    vec2 diskPos = uv - vec2(0.5, 0.5);\n    float disk = length(diskPos) * 1.5;\n    float trees = smoothstep(0.3, 0.8, sin(disk*4.0 + iTime)*treeStrength);\n    \n    // Add vine-like patterns\n    vec2 vinePos = uv - vec2(0.5, 0.5);\n    float vineAngle = atan2(vinePos.y, vinePos.x) * 3.0;\n    float vines = sin(vineAngle + iTime*0.5) * noiseScale;\n    \n    // Combine elements with color variations\n    vec3 finalColor = baseColor * (1.0 - trees);\n    finalColor += hsv2rgb(vec3(0.4, 0.8, 0.7)) * vines;\n    \n    // Add lighting effect from top\n    float lightIntensity = max(0.0, sin(iTime*0.5 + PI) * 0.5 + 0.5);\n    vec2 lightPos = uv - vec2(0.0, 0.3);\n    float lightDistance = length(lightPos) * 1.5;\n    float light = smoothstep(0.4, 0.8, sin(lightDistance*4.0 + iTime)*lightIntensity);\n    finalColor += hsv2rgb(vec3(0.1, 0.8, 0.9)) * light * 0.5;\n    \n    // Add some glowing elements\n    float glow = turbulent(vec3(uv*0.5, iTime*0.1)) * 0.5 + 0.5;\n    finalColor += baseColor * glow * 0.4;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_545.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating triangle pattern\n    vec2 st = uv * 5.0; // Scale up for more cells\n    vec2 cell = floor(st);\n    vec2 pos = fract(st) * 2.0 - 1.0;\n    \n    // Rotate each cell based on time\n    float angle = iTime * 0.5 + cell.x * cell.y * 0.1;\n    mat2 rot = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 rotatedPos = rot * pos;\n    \n    // Create triangle pattern using barycentric coordinates\n    float d1 = abs(rotatedPos.x + rotatedPos.y);\n    float d2 = abs(rotatedPos.x - rotatedPos.y);\n    float d3 = abs(rotatedPos.x + rotatedPos.y - 1.0);\n    \n    // Add noise to create dynamic patterns\n    float noiseVal = turbulent(vec2(uv * 5.0)) * 0.5;\n    angle += noiseVal * 0.2;\n    \n    // Create vibrant color gradients using HSL\n    vec3 color = hsl(\n        mod(iTime * 0.1 + cell.x * 0.2, 1.0), // Hue variation over time and space\n        0.8 + noiseVal * 0.2, // Saturation with noise modulation\n        0.5 + rotatedPos.y * 0.3 // Lightness variation based on position\n    );\n    \n    // Combine patterns and colors for final effect\n    float pattern = min(d1, min(d2, d3)) * 0.5;\n    color *= smoothstep(0.0, 1.0, pattern + noiseVal);\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_546.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec2 st = uv - 0.5;\n    \n    // Polar coordinates for rotation\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + time;\n    \n    // Geometric pattern with noise\n    float pattern = sin(theta * 8.0 + time) * cos(r * 4.0 - time) * \n                   abs(sin(theta * 3.0)) / (cos(theta * 5.0 + time) + 0.1);\n    \n    // Add noise for texture\n    vec2 noisePos = st * 5.0 + time;\n    float noiseVal = noise(noisePos);\n    pattern += noiseVal * 0.3;\n    \n    // Color transformation with pulsating effect\n    vec3 baseColor = hsl(\n        sin(time) * 180.0,\n        0.7 + 0.3 * sin(r * 5.0 + time),\n        0.5 + 0.5 * cos(theta * 4.0)\n    );\n    \n    // Mix colors based on pattern\n    vec3 finalColor = mix(\n        baseColor,\n        hsl(\n            theta * 180.0 / PI,\n            0.6,\n            0.7 + 0.3 * sin(r * 2.0 - time)\n        ),\n        abs(pattern) * 0.5 + 0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_547.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    vec2 st = uv - 0.5;\n    float radius = length(st);\n    \n    // Add rotation based on time\n    float angle = iTime * 1.5;\n    st.x = cos(angle)*st.x - sin(angle)*st.y;\n    st.y = sin(angle)*st.x + cos(angle)*st.y;\n    \n    // Create expanding circles pattern\n    radius += sin(iTime) * 0.3;\n    float pattern = sin(radius * 12.0 + iTime * 2.0);\n    \n    // Generate color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        (radius * 0.5 + pattern * 0.5) * PI,\n        0.7 + turbulent(st * 10.0) * 0.3,\n        0.5 + sin(iTime * 0.5) * 0.5\n    ));\n    \n    // Add noise texture for extra detail\n    vec2 noiseScale = st * 8.0;\n    float noiseValue = turbulent(noiseScale);\n    color *= 1.0 + noiseValue * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_548.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 result;\n    \n    // Create rotating pattern using time\n    float angle = iTime * 0.5;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedUV = uv * rotMatrix;\n    \n    // Generate turbulent noise for dynamic movement\n    float turbulence = turbulent(rotatedUV * 5.0);\n    \n    // Create color transitions using HSL\n    vec3 baseColor = hsl(0.5 + turbulence * 0.1, 1.0, 0.7);\n    vec3 secondaryColor = hsl(0.4 + turbulence * 0.2, 1.0, 0.6);\n    \n    // Mix colors based on position and noise\n    float blendFactor = length(uv) * 0.5;\n    vec3 finalColor = mix(baseColor, secondaryColor, blendFactor);\n    \n    result = vec4(finalColor, 1.0);\n    return result;\n}"
  },
  "data_549.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Moving gradient background\n    vec3 grad1 = hsl2rgb(vec3(0.5 * sin(iTime * 0.5) + 0.5, 0.7, 0.8));\n    vec3 grad2 = hsl2rgb(vec3(0.5 * sin(iTime * 0.5 + PI) + 0.5, 0.6, 0.7));\n    \n    // Cellular noise pattern\n    float scale = 0.1;\n    vec2 grid1 = uv * scale;\n    vec2 grid2 = uv * scale + vec2(sin(iTime)*0.1, cos(iTime*0.3)*0.1);\n    \n    float n1 = noise(grid1) * 0.5 + 0.5;\n    float n2 = noise(grid2) * 0.5 + 0.5;\n    \n    // Combine noise patterns\n    float pattern = (n1 + n2) * 0.5;\n    \n    // Animate the pattern\n    vec2 animUV = uv + vec2(sin(iTime*0.3)*0.2, cos(iTime*0.4)*0.2);\n    float animatedPattern = pattern + noise(animUV * scale * 10.0) * 0.3;\n    \n    // Mix gradient and noise\n    vec3 finalColor = mix(grad1, grad2, animatedPattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_55.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n    // Create flower petal shape using sine waves and noise\n    float petal = sin(a * 6.0 + iTime) * 0.5 + 0.5;\n    petal *= cos(a * 3.0 - iTime) * 0.5 + 0.5;\n    petal *= r < 1.0 ? 1.0 : 0.0;\n    // Add noise for organic feel\n    vec2 noisePos = pos * 4.0 + iTime;\n    float n = noise(noisePos) * 0.3;\n    petal += n;\n    // Create color transition from center to edges\n    vec3 color = hsl2rgb(vec3(0.16, 0.8, 0.5)); // Yellow center\n    vec3 edgeColor = hsl2rgb(vec3(0.7, 0.7, 0.5)); // Pink edges\n    float blend = smoothstep(0.5, 1.0, r);\n    color = mix(color, edgeColor, blend);\n    // Add lighting effect\n    vec3 lightDir = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n    vec3 normal = vec3(-pos.x, -pos.y, 1.0);\n    normal = normalize(normal);\n    float ambient = 0.5;\n    float diffuse = max(dot(lightDir, normal), 0.0) * 0.8;\n    color *= (ambient + diffuse);\n    // Combine everything\n    vec3 finalColor = mix(vec3(0.0), color, petal);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_550.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create rotating pattern using time\n    theta += iTime * 0.5;\n    // Add noise and turbulence to create dynamic patterns\n    vec3 noisePos = vec3(uv * 10.0 + iTime, 0.0);\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    \n    // Create kaleidoscopic effect by repeating pattern\n    theta = mod(theta, pi * 2.0);\n    float angle = theta / (pi * 2.0);\n    \n    // Generate color transitions using HSL\n    vec3 color1 = hsl(angle * 360.0, 0.8, 0.5);\n    vec3 color2 = hsl((angle + 0.3) * 360.0, 0.8, 0.5);\n    \n    // Combine colors and noise\n    vec3 finalColor = mix(color1, color2, turb);\n    finalColor *= r < 1.0 ? smoothstep(0.0, 1.0, r) : 0.0;\n    \n    return vec4(finalColor * 2.0, 1.0);\n}"
  },
  "data_551.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a pulsating pattern using time and UV coordinates\n    float mirrors = 8.0 + sin(iTime * 0.5) * 4.0;\n    vec2 grid = floor(uv * mirrors + 0.5);\n    vec2 mirroredUV = fract(abs(grid - uv * mirrors));\n    \n    // Add turbulence for dynamic patterns\n    float t = turbulent(mirroredUV * 10.0 + sin(iTime) * 3.0);\n    \n    // Create kaleidoscopic color pattern using HSL\n    vec3 hslColor = vec3(\n        fract(sin(grid.x + iTime) * 2.0),\n        0.7 + t * 0.3,\n        0.5 + sin(iTime * 0.8) * 0.5\n    );\n    \n    // Convert to RGB and return as fragment color\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_552.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for better coverage\n    vec2 st = uv * 8.0 - 4.0;\n    \n    // Create base sine wave pattern with time-based pulsing\n    float baseWave = sin(st.x * 0.5 + iTime) * 0.5 + 0.5;\n    \n    // Add secondary ripple effect using higher frequency sine waves\n    float ripples = sin(st.x * 3.0 + iTime * 2.0) * 0.3;\n    \n    // Combine waves and add noise for organic feel\n    float finalPattern = baseWave + ripples + turbulent(st * 0.5);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.0, 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.6, 1.0, 0.5));\n    \n    // Mix colors based on pattern and time\n    vec3 finalColor = mix(color1, color2, sin(iTime * 0.5) * 0.5 + 0.5);\n    \n    // Apply the pattern to the color\n    finalColor *= finalPattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_553.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position over time\n    vec2 st = uv - vec2(0.5);\n    st.x += iTime * 0.1;\n    \n    // Create flowing sine wave patterns\n    float flow = sin(2.0 * st.x + iTime) * 0.5;\n    flow += sin(4.0 * st.x + iTime * 0.5) * 0.3;\n    flow += turbulent(st * 10.0 + vec2(iTime)) * 0.2;\n    \n    // Create color transitions\n    vec3 color1 = hsl2rgb(vec3(\n        (st.x + iTime) * 0.4,   // Hue\n        0.8,                    // Saturation\n        0.5 + flow * 0.2        // Lightness\n    ));\n    \n    vec3 color2 = hsl2rgb(vec3(\n        (st.x + iTime) * 0.4 + 0.5,   // Hue offset\n        0.8,                            // Saturation\n        0.5 + sin(1.5 * st.y + iTime) * 0.3  // Lightness variation\n    ));\n    \n    // Mix colors based on flow pattern\n    vec3 finalColor = mix(color1, color2, smoothstep(-0.5, 0.5, flow));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_554.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color - dark blue background\n    vec3 baseColor = hsl(230.0, 0.1, 0.05);\n    \n    // Create island shapes using noise and turbulence\n    float islandNoise = turbulent(uv * 8.0 + iTime * 0.1) * 0.5 + 0.5;\n    vec3 islandColor = hsv2rgb(vec3(140.0, 0.6, islandNoise * 0.7));\n    \n    // Add fireflies with trails\n    float decay = 0.98;\n    vec3 glow = vec3(0.0);\n    \n    // Firefly 1\n    vec2 pos1 = sin(vec2(iTime * 2.0, iTime * 3.0) + uv * 4.0) * 0.5 + 0.5;\n    float dist1 = length(uv - pos1);\n    glow += decay * exp(-dist1 * 8.0) * vec3(1.0, 0.8, 0.2);\n    \n    // Firefly 2\n    vec2 pos2 = sin(vec2(iTime * 2.5 + pi, iTime * 4.0 - pi) + uv * 6.0) * 0.5 + 0.5;\n    float dist2 = length(uv - pos2);\n    glow += decay * exp(-dist2 * 8.0) * vec3(1.0, 0.8, 0.2);\n    \n    // Combine elements\n    vec3 finalColor = mix(baseColor, islandColor, islandNoise * 0.5 + 0.3);\n    finalColor += glow;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_555.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for radial effects\n    vec2 uv_centered = uv - 0.5;\n    float radius = length(uv_centered);\n    float angle = atan2(uv_centered.y, uv_centered.x);\n    // Create pulsating effect using time and sine function\n    float pulse = sin(iTime * 0.5) + 1.0;\n    radius *= pulse;\n    // Generate fractal noise pattern with turbulence\n    vec3 pos = vec3(uv_centered * 2.0, iTime);\n    float noise_value = turbulent(pos * 4.0);\n    // Mix radial and noise patterns for color variation\n    float color_value = mix(angle * 0.5 + 0.5, noise_value, 0.3);\n    \n    // Add depth with additional turbulence layer\n    color_value += turbulent((uv_centered + iTime) * 2.0) * 0.2;\n    // Convert to HSL for vibrant colors and time-based shifts\n    vec3 final_color = hsl(iTime * 0.1 + noise_value, 1.0, 0.5);\n    return vec4(final_color, 1.0);\n}"
  },
  "data_556.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create rotating pattern with time offset\n    theta += iTime * 0.5;\n    \n    // Add noise and turbulence for dynamic patterns\n    float noise1 = noise(vec3(r*0.5 + iTime*0.2, theta, 0.0));\n    float noise2 = noise(vec3(r*2.0 - iTime*0.3, theta*2.0, 0.0));\n    \n    // Create color shifts using HSL\n    vec3 baseColor = hsl(theta * 0.5 + iTime * 0.1, 0.7, 0.6);\n    vec3 finalColor = mix(baseColor,\n                         hsl(theta * 0.5 + iTime * 0.2, 0.8, 0.7),\n                         noise1 * 0.5 + 0.5);\n    \n    // Combine patterns and colors\n    float pattern = sin(r * 4.0 - iTime) * 0.5 + 0.5;\n    pattern *= sin(theta * 3.0 + iTime * 2.0) * 0.5 + 0.5;\n    pattern += noise1 * 0.3 + noise2 * 0.2;\n    \n    // Final color transformation\n    vec3 color = mix(finalColor,\n                    hsl2rgb(vec3(theta*0.5, 0.6, 0.8)),\n                    pattern);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_557.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base wave pattern using sine function\n    float wave = sin(uv.x * 5.0 + iTime) * 0.5;\n    wave += sin(uv.x * 10.0 + iTime * 2.0) * 0.3;\n    \n    // Add pulsation effect\n    float pulse = cos(iTime * 2.0);\n    wave *= (pulse * 0.5 + 0.5);\n    \n    // Add turbulence based on UV coordinates and time\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float turb = turbulent(noiseUV) * 0.3;\n    wave += turb;\n    \n    // Create color transitions using HSL\n    float hue = uv.x * 5.0 + iTime * 2.0;\n    vec3 hslColor = vec3(hue, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Output the final color with alpha\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_558.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create rotating geometric pattern using turbulence\n    vec3 noiseParams = vec3(st.x, st.y, iTime * 0.2);\n    float baseNoise = turbulent(noiseParams);\n    \n    // Add multiple layers of turbulence for more complex patterns\n    float layer1 = turbulent(vec3(st * 2.0 + theta, iTime * 0.1)) * 0.5;\n    float layer2 = turbulent(vec3(st * 4.0 - theta, iTime * 0.2)) * 0.3;\n    \n    // Combine layers and create color transitions\n    float combined = (baseNoise + layer1 + layer2) * 0.5 + 0.5;\n    vec3 hslColor = vec3(theta * 0.1, combined, 0.7);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Apply gamma correction and return final color\n    return vec4(pow(rgbColor, vec3(2.2)), 1.0);\n}"
  },
  "data_559.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create color transitions using time and angle\n    vec3 color = hsl(\n        sin(theta + iTime) * 0.5 + 0.5,\n        sin(iTime * 0.5 + theta * 4.0) * 0.5 + 0.5,\n        0.7\n    );\n    // Add turbulence for dynamic patterns\n    float turb = turbulent(vec3(r, theta, iTime * 0.1));\n    \n    // Create concentric circles with shifting colors\n    vec3 finalColor = hsl2rgb(\n        vec3(\n            sin(iTime + r * 5.0) * 0.5 + 0.5,\n            cos(iTime * 0.7 + theta * 4.0) * 0.5 + 0.5,\n            0.6\n        )\n    );\n    // Combine everything and output\n    return vec4(finalColor * (1.0 + turb * 0.3), 1.0);\n}"
  },
  "data_56.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a polar coordinate system centered at the screen center\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Generate body segments using sine wave with noise modulation\n    float body = sin(theta * 4.0 + iTime) * turbulent(vec3(r * 0.5, theta, iTime * 0.1));\n    \n    // Create legs using rotated polar coordinates\n    vec2 legPos[8];\n    for(int i = 0; i < 8; i++) {\n        float rot = radians(45.0 * float(i));\n        mat2 rotMat = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n        legPos[i] = (st) * rotMat;\n    }\n    // Combine body and legs with noise\n    vec3 color = hsl2rgb(vec3(0.5 + 0.5 * turbulent(vec3(r, theta, iTime)), \n                              0.7 + 0.3 * turbulent(vec3(r*0.1, theta*0.1, iTime)),\n                              0.3 + 0.7 * turbulent(vec3(r*0.2, theta*0.2, iTime))));\n    // Add leg details\n    for(int i = 0; i < 8; i++) {\n        float legDist = length(legPos[i]) * 0.5;\n        float legAngle = atan2(legPos[i].y, legPos[i].x);\n        float claw = sin(legAngle * 4.0 + iTime) * turbulent(vec3(legDist * 0.5, legAngle, iTime * 0.1));\n        \n        color += hsl2rgb(vec3(0.7 + 0.3 * turbulent(vec3(legDist, legAngle, iTime)),\n                              0.8 + 0.2 * turbulent(vec3(legDist*0.1, legAngle*0.1, iTime)),\n                              0.4 + 0.6 * turbulent(vec3(legDist*0.2, legAngle*0.2, iTime)))) * \n                 (1.0 - abs(claw)) * 0.5;\n    }\n    return vec4(color, 1.0);\n}"
  },
  "data_560.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv * 1.5); // Scale coordinates\n    \n    // Create pulsating effect using time and sine function\n    float pulse = sin(iTime + radius * 3.0) * 0.5 + 0.5;\n    \n    // Generate color transitions using HSL colors\n    vec3 hslColor = vec3(\n        iTime * 0.1 + radius * 0.2, // Hue variation over time and space\n        0.7,                        // Saturation\n        0.5                         // Lightness\n    );\n    \n    // Convert HSL to RGB\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise for dynamic texture\n    float noiseValue = noise(vec2(angle * 10.0, radius * 10.0)) * 0.5 + 0.5;\n    \n    // Create opacity based on distance and time\n    float opacity = pulse * (1.0 - radius * 0.3);\n    \n    // Combine color and noise for final effect\n    vec3 finalColor = rgbColor * (noiseValue * 0.8 + 0.2) * opacity;\n    \n    return vec4(finalColor, max(opacity, 0.0));\n}"
  },
  "data_561.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 center = vec2(0.5);\n    vec2 coord = uv - center;\n    float theta = atan(coord.y, coord.x);\n    float r = length(coord);\n    // Create slow-moving wave distortion\n    float time = iTime * 0.1;\n    float waveX = sin(uv.x * 4.0 + time) * 0.2;\n    float waveY = cos(uv.y * 4.0 - time) * 0.2;\n    \n    // Apply distortion to coordinates\n    vec2 distortedUV = uv + vec2(waveX, waveY);\n    \n    // Calculate new polar coordinates after distortion\n    coord = distortedUV - center;\n    theta = atan(coord.y, coord.x);\n    r = length(coord);\n    // Create color variations based on angle and radius\n    vec3 color1 = hsl(theta * 0.5 + time, 0.8, 0.6);\n    vec3 color2 = hsl(theta * 0.7 - time, 0.7, 0.5);\n    \n    // Add turbulence for dynamic effects\n    float turb = turbulent(vec3(r * 0.5, theta * 0.5 + time, 0.0)) * 0.3;\n    vec3 finalColor = mix(color1, color2, turb);\n    \n    // Combine colors and apply light rays effect\n    finalColor *= smoothstep(0.0, 1.0, r * 4.0 - 1.0) * 1.5;\n    finalColor += vec3(turb * 0.3);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_562.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan(st.y, st.x);\n    // Add time-based rotation and scaling\n    theta += iTime * 0.5;\n    r *= 0.5 + 0.5 * sin(iTime) + 0.2 * turbulent(vec2(r, theta));\n    // Create geometric patterns using sine waves\n    float pattern = sin(theta * 6.0 + iTime) * cos(r * 10.0);\n    \n    // Add noise and turbulence for dynamic effects\n    vec2 noiseCoords = vec2(r, theta) * 5.0;\n    float noiseValue = noise(noiseCoords + iTime);\n    pattern += turbulent(noiseCoords + iTime * 0.5);\n    // Convert to HSL and adjust colors based on mouse movement\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + pattern),\n        0.7 + 0.3 * noiseValue,\n        0.5 + 0.5 * sin(r * 10.0 + iTime)\n    );\n    \n    // Convert to RGB and add glow effect\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= 1.0 + 0.5 * noiseValue;\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_563.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create mirrored patterns using symmetry\n    vec2 st = fract(uv * 8.0);\n    st = abs(st - 0.5) * 2.0;\n    \n    // Add rotating sine wave movement\n    float time = iTime * 0.1;\n    float sinX = sin(time + uv.x * pi);\n    float sinY = cos(time + uv.y * pi);\n    \n    // Combine mirrored patterns with sine waves\n    vec2 motion = vec2(sinX, sinY) * 0.5 + 0.5;\n    vec2 finalUV = mix(uv, motion, 0.5);\n    \n    // Add turbulence for dynamic effect\n    float turb = turbulent(finalUV * 4.0) * 0.5 + 0.5;\n    \n    // Create smooth color transitions using HSL\n    vec3 hslColor = vec3(turb * 360.0, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_564.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal grid pattern\n    a += iTime * 0.5; // Rotate pattern over time\n    float angleStep = pi / 3.0;\n    float grid = sin(a * 6.0) * 0.5 + 0.5;\n    \n    // Add pulsating effect\n    float pulse = sin(iTime * 2.0 + r * 10.0) * 0.5 + 0.5;\n    grid *= mix(0.3, 0.7, pulse);\n    \n    // Create color transitions using HSL colors\n    vec3 hslColor = vec3(\n        a * 180.0 / pi + iTime * 60.0,\n        0.7 + noise(vec2(a, r)) * 0.3,\n        0.5 + sin(iTime) * 0.2\n    );\n    \n    // Convert HSL to RGB and add turbulence effect\n    vec3 rgbColor = hsl2rgb(hslColor);\n    float turb = turbulent(vec3(uv * 10.0, iTime));\n    rgbColor *= mix(0.8, 1.2, turb);\n    // Combine grid pattern with color transitions\n    float proximity = smoothstep(0.7, 1.0, grid);\n    vec3 finalColor = mix(\n        rgbColor,\n        hsl2rgb(vec3(hslColor.x + 180.0, hslColor.y * 0.5, hslColor.z)),\n        proximity\n    );\n    // Add noise and smooth transitions\n    finalColor += noise(vec2(uv * 10.0)) * 0.2;\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.95, 1.0, r));\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_565.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates and scale them\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create polar coordinates from UV\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Calculate base color using HSL\n    vec3 baseColor = hsl(theta * 0.5, 1.0, 0.5);\n    \n    // Add noise and turbulence to create variations\n    float noiseVal = noise(vec2(st.x * 0.5 + iTime, st.y * 0.5));\n    float turb = turbulent(vec3(st.x, st.y, iTime));\n    \n    // Combine multiple patterns with different rotations\n    vec2 rotatedSt = vec2(\n        cos(theta) * st.x - sin(theta) * st.y,\n        sin(theta) * st.x + cos(theta) * st.y\n    );\n    \n    // Create a second pattern layer\n    float r2 = length(rotatedSt);\n    theta += 1.5708; // Offset by 90 degrees\n    \n    // Mix colors using noise and turbulence\n    vec3 color = mix(baseColor, hsl(r * 4.0 + iTime, 1.0, 0.5), noiseVal * 0.5 + 0.5);\n    color = mix(color, hsv2rgb(vec3((r2 * 2.0 + iTime) * 0.2, 1.0, 1.0)), turb * 0.5 + 0.5);\n    \n    // Add depth and layers\n    vec3 finalColor = mix(color, hsl(theta * 0.5, 1.0, 0.5), r * 0.2);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_566.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating pattern by converting UV to polar coordinates\n    vec2 pos = uv - 0.5;\n    float radius = length(pos);\n    float angle = atan2(pos.y, pos.x) + iTime * 0.5;\n    \n    // Generate noise patterns with different frequencies\n    float n1 = noise(vec3(pos * 4.0 + iTime, 0.0)) * 0.5 + 0.5;\n    float n2 = turbulent(vec3(pos * 8.0 + iTime * 2.0, 0.0)) * 0.5 + 0.5;\n    \n    // Combine noise layers with color transformations\n    vec3 color1 = hsl2rgb(vec3(angle * 0.1, n1, 0.6));\n    vec3 color2 = hsl2rgb(vec3((angle * 0.1) + 0.5, n2, 0.4));\n    \n    // Mix colors based on radius and time\n    float mixAmount = sin(radius * 8.0 + iTime) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_567.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create a grid of hexagons\n    vec2 st = uv * 5.0;\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Calculate rotation for each hexagon\n    float angle = sin(ipos.x + ipos.y) * time * 0.2;\n    mat2 rot = mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    vec2 pos = rot * (fpos - 0.5);\n    \n    // Create pulsating effect\n    float pulse = (sin(time * 0.5) + 1.0) * 0.5;\n    float radius = 0.4 + 0.2 * pulse;\n    \n    // Calculate distance from center\n    float dist = length(pos);\n    \n    vec3 color = vec3(0.0);\n    \n    if (dist < radius) {\n        // Create color based on position and time\n        float hue = fract(time * 0.1 + pos.x * 2.0 + pos.y * 3.0);\n        vec3 hslColor = vec3(hue, 0.8, 0.5 + dist * 0.5);\n        color = hsl2rgb(hslColor);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_568.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates by 30 degrees for hexagonal alignment\n    float theta = atan2(uv.y, uv.x);\n    vec2 rotatedUv = vec2(\n        cos(theta + pi/6.0) * length(uv),\n        sin(theta + pi/6.0) * length(uv)\n    );\n    // Scale and grid transformation for hexagonal tiling\n    const float scale = 5.0;\n    vec2 gridCoords = rotatedUv * scale;\n    \n    // Calculate cell indices\n    vec2 cell = floor(gridCoords);\n    \n    // Smooth color transitions using HSL\n    float hue = (iTime + cell.x * 0.1) * 0.1;\n    vec3 hslColor = vec3(hue, 0.7, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise for dynamic variations\n    float noiseValue = noise(vec3(cell.x, cell.y, iTime * 0.1));\n    rgbColor *= 1.0 + noiseValue * 0.3;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_569.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv - 0.5;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5f;\n    \n    // Create color wheels using HSL colors\n    vec3 color1 = hsl(angle * 0.5f + 0.5f, 1.0f, 0.5f);\n    vec3 color2 = hsl(angle * 0.5f + 0.5f + 0.333f, 1.0f, 0.5f);\n    vec3 color3 = hsl(angle * 0.5f + 0.5f - 0.333f, 1.0f, 0.5f);\n    \n    // Add turbulence for plasma effect\n    float turb = turbulent(uv * 4.0f + iTime) * 0.5f + 0.5f;\n    vec3 plasmaColor = mix(color1, color2, turb);\n    plasmaColor = mix(plasmaColor, color3, turb * 0.5f);\n    \n    // Add radius variation\n    float rVariation = sin(iTime * 0.5f + radius * 4.0f) * 0.2f;\n    radius += rVariation;\n    \n    // Combine everything\n    vec3 finalColor = hsl2rgb(vec3(\n        angle * 0.1f + 0.5f,\n        1.0f,\n        radius * 0.5f + 0.5f\n    ));\n    \n    finalColor = mix(finalColor, plasmaColor, 0.7f);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_57.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create spider web pattern using noise and turbulence\n    float radial = sin(50.0 * a + iTime) * noise(vec3(a, r, iTime));\n    float spiral = sin(r * 10.0 - a) * turbulent(vec2(r, a));\n    // Combine patterns\n    float filament = (radial + spiral) * 0.5;\n    \n    // Add color variation\n    vec3 color = hsl(a / (2.0 * PI), r * 0.5 + 0.5, 0.7);\n    vec3 rgbColor = hsl2rgb(color);\n    // Add noise to value channel for depth\n    float valueNoise = noise(vec3(r, a, iTime));\n    rgbColor *= 1.0 + valueNoise * 0.3;\n    return vec4(rgbColor, filament * 0.8 + 0.2);\n}"
  },
  "data_570.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Add time-based rotation and turbulence\n    vec3 p = vec3(uv.x, uv.y, iTime * 0.5);\n    float t = turbulent(p * 0.5) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 colorHSL = vec3(\n        theta / (2.0 * PI) + t * 0.5,\n        0.7 + sin(r * 10.0 + iTime) * 0.3,\n        0.5 + cos(r * 10.0 + iTime) * 0.5\n    );\n    \n    // Convert to RGB and return\n    vec3 rgb = hsl2rgb(colorHSL);\n    return vec4(rgb, 1.0);\n}"
  },
  "data_571.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise values with time offset\n    float t = iTime * 0.5;\n    vec3 noise1 = vec3(noise(uv + vec2(t, t)), noise(uv + vec2(-t, t)), noise(uv + vec2(t, -t)));\n    \n    // Generate color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        sin(t * 0.5) * 0.5 + 0.5,\n        1.0,\n        0.5\n    ));\n    \n    // Add geometric pattern with turbulence\n    float dist = length(uv - 0.5);\n    float angle = atan2(uv.y - 0.5, uv.x - 0.5);\n    float pattern = sin(dist * 10.0 + t) * cos(angle * 3.0 + t);\n    \n    // Combine noise and pattern for final color\n    vec3 finalColor = mix(\n        color,\n        hsl2rgb(vec3(\n            (sin(t) + 1.0) * 0.5,\n            1.0,\n            abs(pattern * 0.5 + 0.5)\n        )),\n        turbulent(uv * 4.0 + vec2(t)) * 0.5 + 0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_572.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating grid pattern using sine functions\n    float speed = 0.5;\n    float time = iTime * speed;\n    \n    // Rotate coordinates over time\n    vec2 rotatedUV = uv * 0.5 + 0.5;\n    rotatedUV -= 0.5;\n    rotatedUV = vec2(\n        rotatedUV.x * cos(time) - rotatedUV.y * sin(time),\n        rotatedUV.x * sin(time) + rotatedUV.y * cos(time)\n    );\n    rotatedUV += 0.5;\n    \n    // Create grid lines with color shifting\n    float gridSize = 0.1;\n    vec2 gridPos = rotatedUV / gridSize;\n    \n    // Use fract and sin to create alternating colors\n    vec3 color = vec3(\n        sin(gridPos.x * pi + time) * 0.5 + 0.5,\n        sin(gridPos.y * pi + time * 0.7) * 0.5 + 0.5,\n        sin((gridPos.x + gridPos.y) * pi + time * 0.4) * 0.5 + 0.5\n    );\n    \n    // Add turbulence effect\n    vec2 noiseUV = rotatedUV * 10.0;\n    float turbulence = turbulent(noiseUV);\n    color *= 1.0 + turbulence * 0.3;\n    \n    // Convert to HSL and back for color shifting\n    vec3 hslColor = hsl(\n        mod(time * 0.2 + rotatedUV.x * 5.0, 1.0),\n        0.7,\n        0.6\n    );\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_573.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a noise-textured background\n    vec3 baseColor = hsl2rgb(vec3(0.5, 1.0, 0.5));\n    float noiseScale = 0.05;\n    float timeScale = iTime * 0.1;\n    vec2 noiseUV = uv * noiseScale + timeScale;\n    float noiseValue = noise(noiseUV);\n    \n    // Create rotating geometric pattern\n    vec2 center = uv - 0.5;\n    float radius = length(center) * 3.0;\n    float angle = atan2(center.y, center.x) + iTime;\n    \n    // Create pulsating color effect\n    float hue = fract(iTime * 0.2);\n    vec3 geometricColor = hsl2rgb(vec3(hue, 1.0, 0.5));\n    \n    // Combine noise and geometric patterns\n    float pattern = sin(radius + angle) * 0.5 + 0.5;\n    pattern *= turbulent(vec2(angle, radius)) * 0.5 + 0.5;\n    \n    // Overlay the geometric shapes on the noise background\n    vec3 finalColor = mix(baseColor, geometricColor, pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_574.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create expanding circles pattern\n    vec2 st = uv - 0.5;\n    float d = length(st);\n    \n    // Add time-based expansion and noise\n    float t = iTime * 0.1;\n    float radius = mod(iTime, 20.0) * 0.1;\n    float circle = smoothstep(radius - 0.1, radius + 0.1, d);\n    \n    // Create color with dynamic hue shift\n    vec3 color = hsl2rgb(vec3(\n        mod(d * 5.0 + iTime, 1.0),\n        0.7,\n        0.5\n    ));\n    \n    // Add noise variation\n    float noiseValue = turbulent(vec3(st * 4.0, t)) * 0.5;\n    color *= 1.0 - noiseValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_575.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based modulation\n    float t = iTime * 0.5;\n    \n    // Add some noise to create interesting patterns\n    vec3 noise1 = vec3(noise(uv + vec2(sin(t), cos(t))), \n                       noise(uv + vec2(cos(t), sin(t)) * 0.5),\n                       noise(uv + vec2(0.0, t) * 0.7));\n    \n    // Create a color palette using HSL\n    vec3 color1 = hsl(sin(t * 0.5) * 0.5 + 0.5, \n                      sin(t * 0.6) * 0.5 + 0.5,\n                      sin(t * 0.7) * 0.5 + 0.5);\n    \n    // Create another color palette with phase shift\n    vec3 color2 = hsl(sin(t * 0.5 + PI) * 0.5 + 0.5, \n                      sin(t * 0.6 + PI) * 0.5 + 0.5,\n                      sin(t * 0.7 + PI) * 0.5 + 0.5);\n    \n    // Mix colors based on noise values\n    vec3 finalColor = mix(color1, color2, noise1.x);\n    \n    // Add some distortion to the UV coordinates\n    vec2 distortedUV = uv + vec2(sin(uv.y * 10.0 + t) * 0.1,\n                                 cos(uv.x * 10.0 + t) * 0.1);\n    \n    // Create a light effect using noise and time\n    float light = turbulent(vec3(distortedUV, t)) * 0.5 + 0.5;\n    \n    // Combine everything for the final effect\n    return vec4(finalColor * light, 1.0);\n}"
  },
  "data_576.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base sphere shape\n    vec2 st = uv * 2.0 - 1.0;\n    float dist = length(st);\n    float glow = 1.0 - smoothstep(0.8, 1.0, dist);\n    \n    // Add noise and turbulence for dynamic effects\n    vec3 noisePos = vec3(uv * 5.0 + iTime, iTime * 0.2);\n    float turb = turbulent(noisePos) * 0.5;\n    \n    // Create color shifts using HSL\n    float hue = (iTime * 0.1 + dist * 0.5) * 360.0;\n    vec3 hslColor = vec3(hue, 0.7, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add surface ripples\n    float ripple = sin(dist * 10.0 + iTime * 2.0) * 0.1;\n    dist += ripple;\n    \n    // Combine effects with lighting\n    vec3 lightDir = normalize(vec3(sin(iTime), cos(iTime), 0.5));\n    vec3 normal = normalize(vec3(st.x, st.y, sqrt(1.0 - dot(st,st))));\n    float light = max(0.0, dot(normal, lightDir)) * 0.6 + 0.4;\n    \n    // Final color\n    vec3 finalColor = rgbColor * (glow + turb) * light;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_577.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 6; i++) {\n        vec2 pos = uv * pow(1.5, float(i)) + time * vec2(0.5, 0.7);\n        float n = turbulent(pos * 4.0) * 0.5 + 0.5;\n        color += hsl2rgb(vec3((time + float(i)) * 0.2, 0.8, n));\n    }\n    \n    return vec4(color / 6.0, 1.0);\n}"
  },
  "data_578.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create base color with shifting hues\n    float hue = 0.2 + 0.3 * sin(iTime * 0.5);\n    vec3 baseColor = hsl(hue, 1.0, 0.5);\n    \n    // Add flowing noise pattern\n    float flow = turbulent(vec3(uv * 4.0, iTime));\n    color += baseColor * (flow + 0.5);\n    \n    // Add secondary noise layer for detail\n    float detail = noise(vec2(uv * 2.0) + vec2(iTime)) * 0.5;\n    color += mix(baseColor, vec3(1.0), detail);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_579.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create rotating sine wave pattern with multiple frequencies\n    float pattern = sin(r * 8.0 + a * 4.0) * 0.5 +\n                   sin(r * 16.0 + a * 2.0) * 0.3 +\n                   sin(r * 32.0 + a) * 0.2;\n    \n    // Add RGB phase shifts\n    vec3 color = vec3(\n        pattern * sin(iTime + 0.0),\n        pattern * sin(iTime + 2.094), // 120 degrees offset\n        pattern * sin(iTime + 4.188)  // 240 degrees offset\n    );\n    \n    // Add noise for texture\n    vec2 noiseUV = uv * 5.0 + iTime;\n    float n = noise(noiseUV);\n    color += n * 0.3;\n    \n    // Convert to HSL and back to RGB for vibrant colors\n    vec3 hslColor = vec3(\n        a * 0.15 + iTime * 0.1,\n        0.7,\n        0.6 + abs(pattern) * 0.4\n    );\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_58.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale\n    vec2 st = (uv - 0.5) * 16.0;\n    \n    // Polar coordinates\n    float angle = atan(st.y, st.x);\n    float radius = length(st);\n    \n    // Create rotating pattern using sawtooth wave\n    float pattern = mod(radius + iTime, 2.0);\n    pattern = fract(pattern); \n    \n    // Color based on angle and time\n    vec3 color = hsl2rgb(vec3(\n        mod(angle * 5.0 + iTime * 2.0, 1.0),\n        0.7,\n        0.8\n    ));\n    \n    // Add noise for complexity\n    float noiseValue = noise(st * 0.5 + vec2(iTime));\n    color *= mix(1.0, 0.5, abs(noiseValue));\n    \n    // Create turbulence effect\n    float turb = turbulent(st * 0.5 + vec2(iTime));\n    pattern += turb * 0.3;\n    \n    // Final color with pattern influence\n    color *= mix(vec3(1.0), vec3(0.0), abs(pattern - 0.5) * 2.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_580.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise pattern\n    float n = noise(uv * 5.0 + iTime);\n    \n    // Add turbulence for more dynamic movement\n    float t = turbulent(uv * 3.0 + vec2(iTime));\n    \n    // Combine noise and turbulence with color shifts\n    vec3 c = hsl(\n        0.7 + n * 0.1,   // Purple base with noise variation in hue\n        1.0 - abs(n) * 0.5, // Vary saturation based on noise\n        0.5 + t * 0.2    // Adjust lightness with turbulence\n    );\n    \n    // Add time-based color shifting\n    c = hsl2rgb(vec3(c.x + iTime * 0.1, c.y, c.z));\n    \n    // Create pulsating effect using distance from center\n    float dist = length(uv);\n    c *= 0.5 * (1.0 + sin(dist * 8.0 + iTime * 2.0));\n    \n    // Add swirling movement using rotated coordinates\n    vec2 rotatedUv = uv * mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    c += hsl(\n        0.3 + n * 0.1,   // Blue base with noise variation in hue\n        1.0 - abs(n) * 0.5,\n        0.3 + t * 0.2\n    ) * (0.5 + rotatedUv.x);\n    \n    return vec4(c, 1.0);\n}"
  },
  "data_581.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates centered at screen center\n    vec2 pos = uv - 0.5;\n    float angle = atan(pos.y, pos.x);\n    float radius = length(pos) * 3.0; // Scale radius for better vortex effect\n    \n    // Create swirling pattern by rotating coordinates based on distance from center\n    float timeRotation = iTime * 0.2;\n    vec2 rotatedPos = vec2(\n        cos(timeRotation + angle) * radius,\n        sin(timeRotation + angle) * radius\n    );\n    \n    // Generate dynamic color using HSL\n    vec3 hslColor = vec3(\n        mod(angle / (pi * 2.0) + iTime, 1.0), // Hue varies with angle and time\n        0.7 + turbulent(vec3(rotatedPos, iTime)) * 0.3, // Saturation with some turbulence\n        0.5 // Mid lightness\n    );\n    \n    // Add particle effect using noise\n    float particleNoise = noise(vec2(iTime * 0.1, rotatedPos.x * 0.1 + iTime));\n    vec3 particles = vec3(1.0) * (particleNoise > 0.98 ? 1.0 : 0.0);\n    \n    // Combine effects\n    vec3 finalColor = hsl2rgb(hslColor) * (1.0 - length(particles)) + particles;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_582.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create pulsating effect with time\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Add layered sine waves in radial direction\n    float wave1 = sin(r * 8.0 + iTime) * 0.3;\n    float wave2 = sin(r * 4.0 + iTime * 0.5) * 0.2;\n    float wave3 = sin(r * 2.0 + iTime * 0.75) * 0.1;\n    \n    // Combine waves and add turbulence\n    float noiseRadial = turbulent(vec2(r, a)) * 0.2;\n    float noiseAngular = turbulent(vec2(a * 0.5, r * 0.5)) * 0.3;\n    \n    // Create color variations using HSL\n    vec3 baseColor = hsl(r * 0.7 + iTime * 0.1, 0.6, 0.5);\n    vec3 colorVariation = hsl(a * 0.5 + noiseRadial, 0.8, 0.6);\n    \n    // Combine all elements\n    float finalRadius = r + wave1 + wave2 + wave3;\n    float finalAngle = a + noiseAngular;\n    \n    // Generate the final color\n    vec3 nebulaColor = mix(baseColor, colorVariation, noiseRadial * 0.5);\n    nebulaColor *= (1.0 - abs(finalRadius - 1.0)) * pulse;\n    \n    // Add brightness and contrast adjustments\n    nebulaColor = pow(nebulaColor, vec3(2.2));\n    nebulaColor = mix(vec3(0.0), nebulaColor, 0.8);\n    \n    return vec4(nebulaColor, 1.0);\n}"
  },
  "data_583.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Flowing liquid metal effect using noise and turbulence\n    \n    // Base noise values\n    float n = noise(uv * 0.5 + iTime);\n    float t = turbulent(uv * 3.0 + vec2(iTime*0.5, 0.0));\n    \n    // Color calculations\n    vec3 color1 = hsl2rgb(vec3(0.6 + t*0.2, 0.8, 0.4)); // Blue-ish metal\n    vec3 color2 = hsl2rgb(vec3(0.3 + t*0.3, 0.7, 0.5)); // Greenish reflection\n    \n    // Mix colors based on noise values\n    vec3 finalColor = mix(color1, color2, n * 0.5 + 0.5);\n    \n    // Add flowing effect\n    finalColor *= sin(uv.x * 4.0 + iTime) * 0.5 + 0.5;\n    finalColor += vec3(turbulent(vec3(uv*2.0, iTime)))*0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_584.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base noise pattern for organic texture\n    float noise1 = turbulent(uv * 8.0 + iTime);\n    \n    // Pulsation effect using sine wave\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    pulse += sin(iTime * 2.0) * 0.3;\n    \n    // Distance from center for radial patterns\n    vec2 center = uv - 0.5;\n    float dist = length(center);\n    \n    // Bioluminescent color transitions\n    vec3 baseColor = hsl2rgb(vec3(0.6 + iTime * 0.1, 1.0, pulse));\n    vec3 glowColor = hsl2rgb(vec3(0.8 + iTime * 0.15, 1.0, pulse * 0.7));\n    \n    // Create layered pulsation effect\n    float layer1 = smoothstep(0.4, 0.6, dist) * baseColor.r;\n    float layer2 = smoothstep(0.3, 0.5, dist) * glowColor.g;\n    float layer3 = smoothstep(0.2, 0.4, dist) * (baseColor.b + glowColor.b);\n    \n    // Combine layers with noise modulation\n    vec3 finalColor = mix(baseColor, glowColor, noise1 * 0.5 + 0.5);\n    finalColor *= layer1 + layer2 + layer3;\n    \n    // Add emission effect\n    finalColor += noise1 * 0.4 * glowColor;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_585.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color using HSL values\n    vec3 baseColor = hsl(uv.x * 0.5 + 0.5, 1.0, 0.5);\n    \n    // Calculate wave offset based on time and position\n    float waveOffset = sin(iTime * 0.5 + uv.y * pi) * 0.2;\n    vec2 shiftedUV = uv + vec2(waveOffset, 0.0);\n    \n    // Add turbulence effect to the color shift\n    float noiseValue = turbulent(shiftedUV * 10.0) * 0.5 + 0.5;\n    \n    // Shift hue using sine function for animation\n    float hueShift = sin(iTime * 0.2 + uv.x * pi) * 0.3 + 0.7;\n    vec3 shiftedColor = hsl(hueShift, noiseValue, 0.5);\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(shiftedColor), 1.0);\n}"
  },
  "data_586.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for rotation effects\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + sin(iTime * 0.5) * 4.0;\n    \n    // Create rotating geometric patterns using sine waves\n    float rotationSpeed = sin(iTime * 0.3 + angle) * 0.5 + 0.5;\n    float pattern = sin(angle * 6.0 + iTime * rotationSpeed) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for dynamic texture\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseValue = noise(noiseUV);\n    float turbulentValue = turbulent(vec3(uv * 5.0, iTime));\n    \n    // Combine colors with HSL transformations\n    vec3 color1 = hsl2rgb(vec3(0.6 + sin(iTime) * 0.3, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.3 + cos(iTime) * 0.4, 1.0, 0.7));\n    \n    // Mix patterns and colors\n    float mixAmount = pattern * noiseValue * turbulentValue;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_587.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a rotating pattern using polar coordinates\n    float angle = atan2(st.y, st.x) + iTime * 0.5;\n    float radius = length(st);\n    \n    // Add fractal noise to create complex patterns\n    float noise1 = turbulent(vec3(st * 5.0, iTime * 0.1));\n    float noise2 = turbulent(vec2(st * 10.0));\n    \n    // Create a radial gradient with pulsating effect\n    float gradient = pow(1.0 - radius, 3.0) + sin(iTime * 0.5);\n    \n    // Combine noise and gradient for the final pattern\n    vec3 color = hsl2rgb(vec3(\n        fract(angle * 0.2 + iTime * 0.1),  // Hue variation over time and space\n        0.7 + 0.3 * noise1,               // Saturation modulation\n        gradient * (0.5 + 0.5 * noise2)    // Brightness with noise\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_588.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate UV coordinates over time\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create displacement pattern using noise\n    float displacement = turbulent(st * 0.5);\n    \n    // Calculate light direction and angle\n    vec3 lightDir = vec3(sin(iTime) * 0.5, cos(iTime) * 0.5, 1.0);\n    lightDir.z += 0.5;\n    \n    // Generate metallic color with shifting hues\n    vec3 color = hsl(\n        mod(length(st) + iTime * 0.2, 1.0), \n        0.7,\n        0.4\n    );\n    \n    // Apply noise-based intensity modulation\n    float intensity = turbulent(vec3(uv * 5.0, iTime)) * 0.5 + 0.5;\n    \n    // Combine elements for final color\n    return vec4(hsl2rgb(color) * intensity, 1.0);\n}"
  },
  "data_589.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Create rotating geometric pattern using sine and cosine functions\n    float pattern = sin(theta * 8.0 + iTime * 2.0) * cos(r * 10.0 - iTime * 3.0);\n    \n    // Add turbulence for dynamic distortion\n    vec2 noiseUV = uv * 5.0 + vec2(iTime, 0.0);\n    float turb = turbulent(noiseUV);\n    \n    // Create color cycling effect using HSL colors\n    vec3 hslColor = vec3(theta * 180.0 / PI + iTime * 60.0, 0.7, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine pattern and noise for final effect\n    float finalPattern = (pattern + turb) * 0.5 + 0.5;\n    \n    return vec4(finalPattern * rgbColor, 1.0);\n}"
  },
  "data_59.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a wobbling pattern using noise and turbulence\n    vec2 st = uv * 5.0;\n    \n    // Add some time-based movement\n    float time = iTime * 0.5;\n    \n    // Create a base checkerboard pattern with noise warping\n    vec2 warp = vec2(\n        sin(time + st.x) * 0.3,\n        cos(time + st.y) * 0.3\n    );\n    \n    // Add turbulence for more complex movement\n    vec2 p = st + warp;\n    float n1 = noise(p*2.0) * 0.5;\n    float n2 = noise(p*4.0) * 0.5;\n    float turb = turbulent(p);\n    \n    // Create color from HSL values\n    vec3 hslColor = vec3(\n        (n1 + 0.5) * 360.0,   // Hue varies with noise\n        0.7,                  // Saturation fixed\n        0.5 + turb*0.5        // Lightness varies with turbulence\n    );\n    \n    // Convert HSL to RGB and mix with another color layer\n    vec3 color = hsl2rgb(hslColor);\n    \n    // Add some depth using multiple noise layers\n    float depth = (noise(st) + noise(st * 2.0)) * 0.5;\n    color *= 1.0 - abs(depth * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_590.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates\n    float t = iTime * 0.5;\n    vec2 q = uv - 0.5;\n    q = mat2(cos(t), sin(t), -sin(t), cos(t)) * q;\n    \n    // Create stripe pattern with sine waves and turbulence\n    float v = sin(q.y * 10.0 + t) + turbulent(q.xy * 4.0 + vec2(sin(t), cos(t))) * 0.5;\n    v = sin(v * pi + t) * 0.5 + 0.5;\n    \n    // Convert to HSL color with dynamic shifts\n    vec3 c = hsl2rgb(vec3(\n        sin(q.x * 5.0 + t) * 0.5 + 0.5,   // Hue variation\n        1.0,                               // Full saturation\n        v                                  // Intensity modulation\n    ));\n    \n    return vec4(c, 1.0);\n}"
  },
  "data_591.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Calculate distance from center\n    float dist = length(st);\n    \n    // Create rotating pattern using cosine waves\n    float theta = atan(st.y, st.x) + iTime * 0.5;\n    float val = cos(theta * 4.0 + iTime) * 0.5 +\n               cos(theta * 8.0 + iTime * 2.0) * 0.3 +\n               cos(theta * 16.0 + iTime * 3.0) * 0.2;\n    \n    // Create color transitions\n    vec3 color = hsl(\n        sin(iTime * 0.5) * 0.5 + 0.5,   // Hue variation over time\n        0.7,                             // Saturation\n        (sin(dist * 4.0 + iTime) * 0.5 + 0.5) * 0.8 + 0.2  // Value variation based on distance and time\n    );\n    \n    return vec4(color * (val + 3.0)/6.0, 0.7);\n}"
  },
  "data_592.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using polar coordinates\n    float angle = atan2(uv.y, uv.x) + iTime * 0.5;\n    float radius = length(uv) * 2.0;\n    \n    // Add expansion/contraction effect\n    radius += sin(iTime * 3.0) * 0.5;\n    radius *= 0.7;\n    \n    // Create color variations using HSL\n    vec3 color = hsl(angle * 0.1, 0.6 + noise(vec2(radius, iTime)) * 0.4, 0.8);\n    \n    // Add turbulence effect\n    float turb = turbulent(vec2(uv.x * 5.0, uv.y * 5.0) + vec2(iTime));\n    color *= 1.0 + turb * 0.3;\n    \n    // Mix in noise for additional texture\n    float n = noise(vec2(radius, angle)) * 0.4;\n    color += n;\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_593.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of nodes with spacing based on UV coordinates\n    vec2 st = fract(uv * 10.0);\n    \n    // Calculate distance from cursor for interactivity\n    float dist = length(st - 0.5);\n    \n    // Time-based pulsing effect\n    float timePulse = sin(iTime * 0.5 + mod(gl_FragCoord.x, 100.0) * 0.1);\n    \n    // Node color based on distance and time\n    vec3 nodeColor = hsl2rgb(vec3(\n        fract(timePulse * 0.1 + dist * 2.0) * PI,\n        0.7 + turbulent(vec3(st, iTime)) * 0.3,\n        0.5 + sin(iTime * 0.2 + mod(gl_FragCoord.y, 100.0) * 0.1) * 0.5\n    ));\n    \n    // Add interactive response to cursor proximity\n    float interaction = smoothstep(0.4, 0.1, dist);\n    nodeColor *= 1.0 + interaction * 0.5;\n    \n    // Combine with turbulent noise for complex patterns\n    vec2 noiseUV = uv * 5.0 + iTime;\n    float turbulence = turbulent(noiseUV) * 0.5 + 0.5;\n    \n    // Final color combining node and turbulence effects\n    return vec4(mix(nodeColor, hsl2rgb(vec3(\n        fract(timePulse * 0.1 + dist * 2.0 + PI),\n        0.7,\n        0.5\n    )), turbulence), 1.0);\n}"
  },
  "data_594.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position over time\n    vec2 st = uv + sin(iTime * 0.5 + uv.xyy * 10.0).xy;\n    \n    // Create flowing noise pattern with multiple frequencies\n    float n1 = noise(st * 3.0 + iTime);\n    float n2 = noise(st * 6.0 + iTime * 0.7);\n    float pattern = sin(n1 * 0.5 + n2) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL\n    vec3 colorHSL;\n    colorHSL.x = (sin(iTime * 0.2 + st.x * 4.0) + sin(st.y * 3.0)) * 0.5 + 0.5;\n    colorHSL.y = 0.7 + pattern * 0.3;\n    colorHSL.z = 0.5 + turbulent(uv * 2.0) * 0.5;\n    \n    // Convert to RGB and return\n    return vec4(hsl2rgb(colorHSL), 1.0);\n}"
  },
  "data_595.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create hexagonal grid pattern\n    vec2 st = uv * 5.0;\n    vec2 ipos = floor(st + iTime*0.5);\n    vec2 pos = fract(st + iTime*0.5) - 0.5;\n    \n    // Convert to polar coordinates for hexagons\n    float theta = atan(pos.y, pos.x);\n    float r = length(pos);\n    \n    // Create hexagonal shape using trigonometric functions\n    float hex = cos(theta * 3.0 + iTime*2.0) * 0.5 + 0.5;\n    hex *= sin(theta * 3.0 + iTime*2.0) * 0.5 + 0.5;\n    \n    // Add turbulence for dynamic distortion\n    float turb = turbulent(vec2(r, theta + iTime));\n    hex += turb * 0.3;\n    \n    // Create color transitions\n    vec3 hslColor = vec3(\n        fract(iTime*0.1 + ipos.x * 0.5) * 360.0,\n        0.7,\n        0.5 + sin(r * 20.0 + iTime) * 0.2\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine patterns with wave distortion\n    float wave = sin(r * 8.0 + theta * 4.0 + iTime*2.0) * 0.1;\n    hex += wave;\n    \n    // Add to final color\n    color += hex * rgbColor * (1.0 - abs(pos.y));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_596.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a gradient background using polar coordinates\n    vec2 center = vec2(0.5);\n    vec2 toCenter = uv - center;\n    float dist = length(toCenter);\n    float angle = atan2(toCenter.y, toCenter.x);\n    \n    // Create rotating hexagonal pattern\n    float time = iTime * 0.5;\n    mat2 rot = mat2(cos(time), sin(time), -sin(time), cos(time));\n    vec2 st = uv * 4.0; // Scale up for multiple hexagons\n    st = rot * (st - 1.0) + 1.0; // Rotate around center\n    \n    // Hexagonal tiling pattern\n    vec2 q = fract(st);\n    float d = max(abs(q.x - 0.5), abs(q.y - 0.5));\n    \n    // Pulsating color effect\n    float hue = time * 0.1 + angle * 0.3;\n    vec3 color1 = hsl(hue, 0.7, 0.6);\n    vec3 color2 = hsl(hue + 0.5, 0.7, 0.6);\n    \n    // Add noise and turbulence\n    float noiseVal = noise(vec3(st * 0.5, time)) * 0.1;\n    float turbulentVal = turbulent(vec2(st.x * 0.5, st.y * 0.5)) * 0.1;\n    \n    // Combine effects\n    vec3 finalColor = mix(color1, color2, smoothstep(0.4, 0.6, d + noiseVal + turbulentVal));\n    finalColor *= 1.0 - dist * 0.8; // Gradient falloff\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_597.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create position relative to center\n    vec2 pos = (uv - 0.5) * 3.0;\n    \n    // Calculate distance from center\n    float dist = length(pos);\n    \n    // Add fractal noise for nebula texture\n    float noise1 = turbulent(pos * 0.5 + iTime);\n    float noise2 = turbulent(pos * 2.0 + iTime * 0.5);\n    float noise3 = turbulent(pos * 4.0 + iTime * 0.75);\n    \n    // Combine noise layers\n    float nebulaNoise = (noise1 + noise2 + noise3) / 3.0;\n    \n    // Create radial gradient with color variations\n    vec3 baseColor = hsl(dist * 0.5, 0.8, 0.6);\n    vec3 timeColor = hsl(sin(iTime * 0.2 + dist * 2.0) * 0.4 + 0.1, 0.7, 0.7);\n    \n    // Combine colors and noise\n    vec3 finalColor = mix(baseColor, timeColor, abs(nebulaNoise * 0.5 + 0.5));\n    \n    // Add pulsating effect\n    float pulse = sin(iTime * 0.2) * 0.5 + 0.5;\n    finalColor *= (1.0 - dist * 0.3) * pulse;\n    \n    // Add some movement and rotation\n    vec2 rotatedPos = vec2(\n        pos.x * cos(iTime * 0.1) - pos.y * sin(iTime * 0.1),\n        pos.x * sin(iTime * 0.1) + pos.y * cos(iTime * 0.1)\n    );\n    \n    // Add angular variations\n    float angle = atan2(rotatedPos.y, rotatedPos.x);\n    finalColor += hsl(angle * 0.5 + iTime * 0.2, 0.6, 0.4) * nebulaNoise * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_598.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float angle = sin(iTime * 0.5);\n    vec2 rotatedUV = cos(angle) * uv + sin(angle) * (uv.yx * vec2(1,-1));\n    \n    // Create base color using distance from center and time\n    float dist = length(rotatedUV - 0.5);\n    vec3 baseColor = hsl(dist * pi, 0.7, 0.5);\n    \n    // Add dynamic shifts to hue and saturation using turbulence\n    float t1 = turbulent(rotatedUV * 10.0 + iTime) * 0.5;\n    float t2 = turbulent(rotatedUV * 20.0 - iTime) * 0.3;\n    \n    vec3 color = hsl(\n        baseColor.x + t1,\n        baseColor.y + t2,\n        0.5\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_599.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate based on time\n    float time = iTime * 0.5;\n    \n    // Create flowing liquid effect using noise and turbulence\n    vec3 noisePos = vec3(uv * 2.0 + time, time);\n    float flow = turbulent(noisePos * 0.5) * 0.5 + 0.5;\n    \n    // Add ripples with varying frequency\n    vec2 rippleUV = uv * 4.0 + time * 0.1;\n    float ripple = noise(rippleUV) * 0.3;\n    \n    // Combine effects for final position distortion\n    vec2 distortedUV = uv + (flow + ripple) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(time * 0.1, 0.7, 0.6);\n    vec3 color2 = hsl((time * 0.1) + 0.5, 0.8, 0.4);\n    \n    // Mix colors based on noise\n    float mixAmount = turbulent(vec3(uv * 2.0, time)) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    // Add metallic effect with highlights\n    float highlight = noise((uv * 4.0) + time * 0.1) * 0.5 + 0.5;\n    finalColor *= 1.0 + highlight * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_6.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 uvTime = uv + vec2(sin(iTime), cos(iTime)) * 0.3;\n    \n    float scale = 5.0;\n    vec2 noiseUV = (uvTime * scale) * 0.1;\n    \n    float baseNoise = noise(noiseUV);\n    float turbulence1 = turbulent(vec2(noiseUV.x * 3.0, noiseUV.y * 3.0));\n    float turbulence2 = turbulent(vec2(noiseUV.x * 6.0, noiseUV.y * 6.0)) * 0.5;\n    \n    float displacement = baseNoise + (turbulence1 + turbulence2) * 0.7;\n    \n    vec3 colorParams = vec3(\n        sin(displacement * PI + iTime) * 0.5 + 0.5,\n        cos(iTime * 2.0) * 0.4 + 0.6,\n        sin((displacement * PI) * 0.5 + iTime * 1.5) * 0.3 + 0.7\n    );\n    \n    vec3 color = hsl2rgb(colorParams);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_60.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create base noise pattern with time variation\n    float baseNoise = noise(rotatedUv * 10.0 + vec2(sin(t), cos(t)));\n    \n    // Add turbulence for more complex patterns\n    float turb = turbulent(rotatedUv * 5.0) * 0.5;\n    \n    // Create color variations using HSL\n    vec3 color1 = hsl(baseNoise * 360.0, 0.7, 0.5);\n    vec3 color2 = hsl((baseNoise + turb) * 360.0, 0.8, 0.6);\n    \n    // Mix colors based on noise values\n    vec3 finalColor = mix(color1, color2, abs(turb));\n    \n    // Add some distortion to the pattern\n    vec2 warp = sin(rotatedUv * 5.0) * 0.1;\n    vec2 finalUv = rotatedUv + warp;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_600.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Create geometric pattern using sine waves in polar space\n    vec3 baseColor = hsl(theta * 8.0 + iTime, 0.8, 0.5);\n    \n    // Add time-based distortion using noise and turbulence\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseValue = noise(noiseUV) * 0.5;\n    float turbulentValue = turbulent(uv * 4.0 + iTime);\n    \n    // Mix colors with distortion\n    vec3 color = mix(baseColor, hsv2rgb(vec3(theta * 0.1 + iTime, 1.0, 0.8)), noiseValue);\n    color *= 1.0 + turbulentValue * 0.5;\n    \n    // Add radial variation\n    color *= 1.0 - r * 0.5;\n    color = mix(color, vec3(1.0), smoothstep(0.9, 1.0, r));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_601.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of hexagons based on time\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Transform coordinates for hexagonal tiling\n    vec2 grid = floor(st);\n    vec2 center = fract(st - 0.5);\n    \n    // Calculate distance from center with hexagonal warping\n    float dist = length(center.x * cos(60.0) + center.y * sin(60.0));\n    \n    // Pulsating effect using sine wave\n    float pulse = sin(iTime * 2.0 + dist * 10.0);\n    \n    // RGB color shift based on time and position\n    vec3 color = hsl(dist * 0.5 + iTime, 0.7, 0.5);\n    \n    // Add radial gradient effect\n    float gradient = smoothstep(0.0, 1.0, dist * 2.0 - 0.5);\n    color *= mix(vec3(1.0), vec3(0.5), gradient);\n    \n    // Add turbulence for extra detail\n    vec3 noiseColor = hsv2rgb(vec3(turbulent(uv * 4.0 + iTime) * 0.3, 0.7, 0.5));\n    color = mix(color, noiseColor, 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_602.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for rotation effect\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create a base color using HSL with RGB shift\n    vec3 hslColor = vec3(theta * 0.15, 0.7, 0.6);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add turbulence effect to create dynamic patterns\n    float t = turbulent(vec2(uv.x + iTime*0.5, uv.y));\n    float t3d = turbulent(vec3(uv, sin(iTime)*0.5));\n    \n    // Combine effects with geometric pattern\n    vec3 finalColor = rgbColor * (turbulent(st * 4.0) * 0.5 + 0.5);\n    finalColor *= smoothstep(1.0, 0.0, r); // Add circular falloff\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_603.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave patterns\n    float time = iTime * 0.5;\n    \n    // X direction sine wave with turbulence\n    float xSine = sin(uv.x * 10.0 + time) * 0.5 + 0.5;\n    float xTurb = turbulent(vec2(uv.x * 5.0, time)) * 0.5 + 0.5;\n    \n    // Y direction sine wave with turbulence\n    float ySine = sin(uv.y * 10.0 - time) * 0.5 + 0.5; \n    float yTurb = turbulent(vec2(time, uv.y * 5.0)) * 0.5 + 0.5;\n    \n    // Combine patterns\n    float d = (xSine * xTurb) + (ySine * yTurb);\n    d = mod(d * 10.0, 1.0); // Create interesting interference pattern\n    \n    // Dynamic color transitions using HSL\n    vec3 hslColor;\n    hslColor.x = mod(time * 0.2, 1.0); // Changing hue over time\n    hslColor.y = 0.7; // Saturation\n    hslColor.z = d * 0.5 + 0.5; // Lightness based on pattern\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_605.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating patterns using sine waves at different frequencies\n    float time = iTime * 0.5;\n    \n    // Base pattern with UV coordinates transformed by time\n    vec2 st = uv * 10.0 + vec2(sin(time), cos(time));\n    \n    // Add multiple layers of sine wave interference\n    float pattern = sin(st.x * 0.5 + time) * \n                   sin(st.y * 0.5 + time * 0.7) +\n                   sin(st.x * 1.5 - time * 0.3) *\n                   sin(st.y * 1.5 + time * 0.5);\n    \n    // Add turbulent noise for extra complexity\n    pattern += turbulent(vec2(uv * 8.0 + time)) * 0.5;\n    \n    // Create dynamic color shifts using HSL to RGB conversion\n    vec3 color = hsl(\n        sin(time) * 120.0,   // Hue variation over time\n        0.7 + pattern * 0.3, // Saturation modulation\n        0.5 + sin(time*0.5)*0.4 // Brightness pulsation\n    );\n    \n    // Add depth with noise-based color shifts\n    vec2 noiseCoords = uv * 16.0;\n    float noiseVal = noise(noiseCoords);\n    color += hsv2rgb(vec3(\n        time * 180.0,\n        0.5,\n        noiseVal * 0.4\n    )) * 0.3;\n    \n    // Combine patterns and colors for final output\n    return vec4(color * (0.5 + sin(time*0.7) * 0.5), 1.0);\n}"
  },
  "data_606.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float a = atan2(uv.y, uv.x);\n    float r = length(uv * 1.5); // Scale radius for better ring spacing\n    \n    // Add time-based rotation\n    a += iTime * 0.2;\n    \n    // Create orbiting rings using sine waves with different frequencies\n    float ring1 = sin(a * 4.0 + iTime) * 0.5 + 0.5;\n    float ring2 = sin(a * 6.0 + iTime * 0.7) * 0.5 + 0.5;\n    \n    // Combine rings with different radii\n    float ringPattern = ring1 * (r * 0.8) + ring2 * (r * 0.4);\n    \n    // Add chromatic aberration by offsetting colors\n    vec3 color;\n    color.r = sin(ringPattern * pi + a * 0.5) * 0.5 + 0.5;\n    color.g = sin(ringPattern * pi + a * 0.4) * 0.5 + 0.5;\n    color.b = sin(ringPattern * pi + a * 0.3) * 0.5 + 0.5;\n    \n    // Add noise for texture\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float n = noise(noiseUV);\n    color += n * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_607.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create two sine waves at different angles and frequencies\n    float wave1 = sin(uv.x * 8.0 + iTime * 2.0);\n    float wave2 = cos((uv.y - 0.5) * 6.0 + iTime * 3.0 + PI/4.0);\n    \n    // Combine waves and add noise for complexity\n    vec2 st = uv;\n    float noiseVal = noise(st * 10.0 + iTime);\n    float combined = (wave1 + wave2) / 2.0 + noiseVal * 0.5;\n    \n    // Create dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.5 + uv.x * 2.0, 1.0),  // Hue\n        0.7 + abs(sin(iTime)) * 0.3,          // Saturation\n        0.5 + combined * 0.4                 // Lightness\n    );\n    \n    // Convert to RGB and add turbulence effect\n    vec3 color = hsl2rgb(hslColor);\n    color *= turbulent(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_608.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Dynamic fiery color parameters with time\n    float hue = sin(iTime * 0.5 + uv.x * pi) * 0.5 + 0.5;\n    vec3 baseColor = hsl(hue, 0.8, 0.6);\n    \n    // Create circular pattern for glowing edges\n    vec2 center = uv - 0.5;\n    float dist = length(center);\n    float glow = exp(-dist * 10.0) * (sin(iTime * 0.3 + dist * pi) * 0.5 + 0.5);\n    \n    // Add noise texture for detail\n    vec2 noiseScale = uv * 8.0 + iTime;\n    float noiseVal = turbulent(noiseScale) * 0.3;\n    \n    // Combine elements with smooth transitions\n    vec3 finalColor = mix(baseColor, vec3(1.0), glow);\n    finalColor *= sin(iTime * 0.2 + dist * pi) * 0.5 + 0.75;\n    finalColor += noiseVal;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_609.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    // Create rotating color wheels using HSL colors\n    vec3 wheel1 = hsl(theta * 0.5 + iTime * 2.0, 0.7, 0.6);\n    vec3 wheel2 = hsl(theta * 1.5 - iTime * 1.5, 0.8, 0.5);\n    \n    // Create pulsating rings using noise and turbulence\n    float ring1 = sin(r * 4.0 + iTime) * 0.5 + 0.5;\n    float ring2 = sin(r * 6.0 - iTime * 0.5) * 0.3 + 0.7;\n    \n    // Combine wheels and rings with noise\n    vec3 color = mix(wheel1, wheel2, smoothstep(0.5, 1.0, r));\n    color += mix(ring1, ring2, smoothstep(0.3, 0.8, r));\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(uv * 4.0 + iTime, 0.0)) * 0.2;\n    color += turb;\n    return vec4(color, 1.0);\n}"
  },
  "data_610.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates around cursor position (0.5 is center)\n    vec2 uv_cursor = uv - 0.5;\n    \n    // Scale coordinates for better ripple spacing\n    uv_cursor *= 8.0;\n    \n    // Calculate distance from cursor\n    float d = length(uv_cursor);\n    \n    // Create time-based ripple effect\n    float ripples = sin(d * 2.0 + iTime) * 0.5 + \n                   sin(d * 4.0 + iTime * 2.0) * 0.3;\n    \n    // Add turbulence for more dynamic effect\n    vec2 noise_coords = uv_cursor * 0.5 + iTime;\n    float turb = turbulent(noise_coords);\n    \n    // Combine effects and scale to [0,1] range\n    float final = (ripples + turb) * 0.5 + 0.5;\n    \n    // Convert to HSL color with time-based hue shift\n    vec3 color = hsl2rgb(vec3(final * 0.7 + iTime, 0.8, 0.6));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_611.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float theta = atan2(uv.y, uv.x);\n    theta += iTime * 0.5; // Rotate over time\n    \n    // Create radial gradient\n    float r = length(uv);\n    float gradient = sin(r * pi); // Smooth transition from center to edge\n    \n    // Create color wheel effect with HSL colors\n    vec3 hslColor = hsl(theta, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add pulsing effect\n    float pulse = sin(iTime) * 0.3;\n    rgbColor *= (0.5 + pulse);\n    \n    // Add dynamic RGB shifts\n    vec3 rgbShifts = vec3(\n        sin(iTime + 0.0) * 0.2,\n        sin(iTime + 2.0) * 0.2,\n        sin(iTime + 4.0) * 0.2\n    );\n    \n    // Combine effects\n    vec3 finalColor = rgbColor * gradient;\n    finalColor += rgbShifts * 0.5; // Add dynamic shifts\n    \n    return vec4(clamp(finalColor, 0.0, 1.0), 1.0);\n}"
  },
  "data_612.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create dynamic sine wave patterns\n    float time = iTime * 0.5;\n    \n    // Wave parameters\n    vec2 st = uv * 10.0 + time;\n    float waveX = sin(st.x * 0.5 + time) * 0.5 + 0.5;\n    float waveY = sin(st.y * 0.7 - time) * 0.5 + 0.5;\n    \n    // Combine waves and add turbulence\n    float d = (waveX + waveY) * 0.5;\n    d += turbulent(vec2(uv * 4.0 + time)) * 0.3;\n    \n    // Convert to HSL color with dynamic shifts\n    vec3 hslColor = vec3(\n        mod(time * 0.1, 1.0),  // Hue\n        0.7 + d * 0.3,       // Saturation\n        0.5                  // Lightness\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_613.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec4 fragColor = vec4(0.0);\n    \n    // Create grid points\n    vec2 st = floor(uv * 10.0 + 0.5);\n    \n    // Calculate distance from center of each square\n    vec2 pos = (st - uv) * 0.1;\n    float dist = length(pos);\n    \n    // Add rotation based on time\n    float angle = atan2(pos.y, pos.x) + sin(iTime * 0.5);\n    float rotatedDist = max(abs(cos(angle)), abs(sin(angle))) * 0.5;\n    \n    // Create square shape with varying opacity\n    if (dist < 0.5) {\n        fragColor.rgb = vec3(1.0);\n        fragColor.a = turbulent(vec2(st)) * 0.5 + 0.5;\n    }\n    \n    return fragColor;\n}"
  },
  "data_614.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = hsl(0.5 + 0.1 * sin(iTime * 0.5), 0.8, 0.6);\n    \n    float time = iTime * 0.5;\n    vec2 st = uv * 4.0; // Scale up for more detail\n    \n    // Create a swirling pattern using polar coordinates\n    vec2 pos = vec2(\n        sin(time + st.x) * 0.5 + 0.5,\n        cos(time + st.y) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence for dynamic effect\n    float noise1 = turbulent(vec3(st, time));\n    float noise2 = noise(vec2(pos.x + time, pos.y + time));\n    \n    // Combine patterns with color transformations\n    vec3 finalColor = hsl2rgb(vec3(\n        0.5 * noise1 + 0.5,\n        0.8,\n        0.6 + 0.4 * noise2\n    ));\n    \n    // Add light trails effect\n    float glow = sin(time + st.x * 0.5) * cos(st.y * 0.5);\n    finalColor += vec3(1.0, 0.8, 0.6) * max(glow, 0.0) * 2.0;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_615.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating coordinate system\n    vec2 st = uv - 0.5;\n    \n    // Polar coordinates with rotation\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.1;\n    \n    // Sine wave pattern with multiple frequencies\n    float wave = sin(r * 5.0 + theta * 3.0) * 0.5 +\n                 sin(r * 7.0 - theta * 2.0) * 0.3 +\n                 sin(r * 9.0 + theta * 4.0) * 0.2;\n    \n    // Color based on angle and time\n    vec3 color = hsl(theta / (2.0 * PI), 0.8, 0.5);\n    \n    // Add noise for texture\n    float noiseVal = noise(vec2(r, theta)) * 0.1;\n    color *= 1.0 + noiseVal;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_616.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying pattern using sine and cosine functions\n    float t = iTime * 0.5;\n    \n    // Generate rotating geometric patterns\n    vec2 st = uv * 10.0 + vec2(sin(t), cos(t));\n    float f = sin(st.x) * cos(st.y) + sin(t * 2.0);\n    \n    // Add turbulence for dynamic movement\n    f += turbulent(uv * 5.0 + vec2(sin(t), cos(t))) * 0.5;\n    \n    // Create shifting color palette using HSL\n    vec3 color = hsl2rgb(vec3(\n        sin(f * 0.5 + t) * 0.5 + 0.5,   // Hue\n        0.7,                              // Saturation\n        0.5                               // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_617.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate UV coordinates with time\n    vec2 st = uv * 5.0 + vec2(sin(iTime)*3.0, cos(iTime*0.7)*2.0);\n    \n    // Create a flowing plasma effect using noise and turbulence\n    float t1 = turbulent(st + vec2(iTime*0.5, iTime*0.3));\n    float t2 = turbulent(st * 2.0 + vec2(iTime*0.7, iTime*0.4));\n    \n    // Combine multiple layers of noise for more complex patterns\n    float value = (t1 + t2) * 0.5;\n    \n    // Create color transitions using HSL colors\n    vec3 hslColor = vec3(\n        sin(iTime*0.2 + value*2.0)*0.5 + 0.5,   // Hue\n        0.7 + abs(sin(iTime*0.3 + value))*0.3,   // Saturation\n        0.5 + t1 * 0.4                         // Lightness\n    );\n    \n    // Convert HSL to RGB and mix with UV gradients\n    vec3 color = hsl2rgb(hslColor);\n    color *= sin(uv.x * 8.0 + iTime) * 0.5 + 0.5;\n    color += pow(abs(sin(iTime*0.4 + uv.y*10.0)), 2.0) * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_618.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base frequency\n    float time = iTime * 0.5;\n    \n    // Convert UV coordinates to polar form\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + time;\n    \n    // Create a complex pattern using turbulence\n    float t1 = turbulent(vec3(r * 8.0 + time, a * 4.0, 0.0));\n    float t2 = turbulent(vec2(r * 16.0 - time * 2.0));\n    \n    // Combine turbulence results with noise\n    float pattern = (t1 + t2) * 0.5;\n    \n    // Create a vibrant color palette using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(a * 0.2 + time * 0.1),\n        0.7 + noise(vec2(time)) * 0.3,\n        0.5 + pattern * 0.4\n    ));\n    \n    // Add depth and movement to the color\n    vec3 finalColor = mix(\n        color,\n        hsl2rgb(vec3(\n            fract(a * 0.1 + time * 0.3),\n            0.6,\n            0.7\n        )),\n        smoothstep(0.0, 1.0, r)\n    );\n    \n    // Apply some transparency based on distance from center\n    return vec4(finalColor, 1.0 - smoothstep(0.0, 1.0, r * 2.0));\n}"
  },
  "data_619.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 polar = vec2(length(uv - 0.5), atan2(uv.y - 0.5, uv.x - 0.5));\n    \n    // Create rotating pattern by adding time-based rotation\n    float angle = polar.y + iTime * 0.5;\n    \n    // Use noise to add some variation\n    float n = noise(vec3(polar.x * 10.0, angle * 2.0, iTime * 0.5));\n    \n    // Create color wheel effect using HSL colors\n    vec3 color = hsl(\n        mod(angle + n * 0.5, 2.0 * PI) / (2.0 * PI),  // Hue\n        smoothstep(0.0, 1.0, polar.x * 2.0) * 0.7 + n * 0.3,  // Saturation\n        0.5 + turbulent(vec3(polar.x, angle, iTime)) * 0.3  // Lightness\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_62.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating color wheel effect\n    float time = iTime * 0.5;\n    \n    // Generate base pattern using polar coordinates\n    vec2 st = uv;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add noise and turbulence\n    float pattern = sin(r * 10.0 + time) * cos(theta * 5.0 + time);\n    pattern += turbulent(vec3(uv * 4.0, time)) * 0.5;\n    \n    // Color transformation using HSL\n    vec3 color = hsl(\n        mod(pattern * 0.5 + time, 1.0),  // Hue\n        0.8,                              // Saturation\n        0.5 + pattern * 0.2               // Lightness\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_620.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating pattern using polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create kaleidoscope effect by reflecting around center point\n    int slices = 8;\n    a = mod(a * float(slices), PI * 2.0);\n    vec2 reflected = vec2(cos(a), sin(a)) * r;\n    \n    // Add noise and turbulence for dynamic patterns\n    vec2 noiseCoords = reflected * 5.0 + iTime;\n    float noiseVal = turbulent(noiseCoords) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1, 1.0),   // Hue variation over time\n        0.7 + noiseVal * 0.3,    // Saturation modulation\n        0.5 + sin(iTime) * 0.2   // Brightness modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_621.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create rotating hexagon pattern using sine wave with 6-fold symmetry\n    float d = sin(6.0 * (a + iTime * 0.5)) * 0.5 + 0.5;\n    float shape = smoothstep(0.4, 0.6, r) * d;\n    \n    // Create pulsating color using HSL\n    vec3 hslColor = vec3(a * 0.1, 0.7, 0.5 + 0.5 * sin(iTime * 0.5 + r * pi));\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise and turbulence for dynamic effect\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float noiseVal = turbulent(noiseUV) * 0.5 + 0.5;\n    shape *= noiseVal;\n    \n    // Combine shape and color\n    vec3 finalColor = rgbColor * shape;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_622.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create rotating sine wave pattern with multiple frequencies\n    float wave = sin(theta * 2.0) * 0.5 +\n                 sin(theta * 3.0) * 0.3 +\n                 sin(r * 10.0 + iTime * 2.0) * 0.2;\n    \n    // Add noise and turbulence\n    vec2 noiseScale = uv * 4.0;\n    float turb = turbulent(noiseScale);\n    wave += turb * 0.3;\n    \n    // Scale and offset for better contrast\n    wave *= 1.5;\n    wave = sin(wave + iTime) * 0.5 + 0.5; // Ensure positive values\n    \n    // Create color cycling effect using HSL\n    vec3 hslColor = vec3(iTime * 0.2, 1.0, wave); // Hue cycles over time\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_623.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Time-based rotation\n    float time = iTime * 0.5; // Speed control\n    mat2 rot = mat2(cos(time), sin(time), -sin(time), cos(time));\n    vec2 rotated = rot * st * 1.0;\n    \n    // Kaleidoscope effect using modulo and symmetry\n    vec2 tile = abs(mod(rotated + 0.5, 1.0) - 0.5);\n    vec2 mirrored = sign(tile) * (abs(tile) * 4.0 - 1.0);\n    \n    // Add noise for pulsating effect\n    float noiseVal = noise(vec3(mirrored, time));\n    mirrored *= 1.0 + sin(time + noiseVal * 2.0) * 0.5;\n    \n    // Color inversion based on noise\n    vec3 color = hsl2rgb(vec3(\n        mod(length(mirrored) * 4.0 + time, 1.0),\n        0.7,\n        0.6\n    ));\n    \n    if (noiseVal > 0.5) {\n        // Invert color\n        color = vec3(1.0) - color;\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_624.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create dynamic sine waves with different frequencies\n    float wave1 = sin(4.0*st.x + iTime * 0.5) * cos(3.0*st.y + iTime);\n    float wave2 = sin(5.0*st.x + iTime * 0.6) * cos(4.0*st.y + iTime * 0.8);\n    \n    // Combine waves with dynamic phase shift\n    float combined = (wave1 + wave2) * 0.5;\n    combined += sin(iTime * 0.2) * 0.3; // Add time-based modulation\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(combined * 6.0 + iTime, 1.0), // Hue variation\n        0.7,                               // Saturation\n        0.5 + noise(st * 4.0) * 0.2       // Lightness with noise variation\n    );\n    \n    // Convert to RGB and add brightness modulation\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= 0.8 + abs(sin(iTime)) * 0.2;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_625.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 20.0;\n    \n    // Get cell position and center offset\n    vec2 pos = mod(st, 1.0) - 0.5;\n    \n    // Calculate distance from center\n    float d = length(pos);\n    \n    // Create pulsing effect with time\n    float pulse = sin(iTime + d * 10.0) * 0.5 + 0.5;\n    \n    // Add turbulence for dynamic effect\n    float turb = turbulent(vec3(pos, iTime)) * 0.2;\n    \n    // Combine effects\n    float circle = smoothstep(pulse + turb, pulse - turb, d);\n    \n    // Generate color based on distance and time\n    vec3 color = hsl(\n        sin(iTime * 0.5 + d * 2.0) * 0.5 + 0.5,\n        1.0,\n        circle * 0.8 + 0.2\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_626.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create hexagonal grid pattern\n    float ring = floor(r * 5.0); // Number of rings\n    float angle = theta + iTime; // Add rotation over time\n    \n    // Calculate hexagon position\n    vec2 hexPos = vec2(\n        r * cos(angle),\n        r * sin(angle)\n    );\n    // Add noise and turbulence for dynamic effect\n    float noiseVal = turbulent(hexPos * 0.5 + iTime);\n    \n    // Create pulsating color pattern\n    vec3 hslColor = vec3(\n        mod(ring * 0.2 + iTime, 1.0), // Pulsating hue\n        0.7 + noiseVal * 0.3,          // Saturation with noise\n        0.5 + sin(iTime) * 0.5         // Pulsating lightness\n    );\n    // Convert HSL to RGB and output\n    vec3 color = hsl2rgb(hslColor);\n    \n    return vec4(color * (1.0 + noiseVal * 0.5), 1.0);\n}"
  },
  "data_627.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime * 0.5; // Add rotation\n    \n    // Create radial sine waves with different frequencies\n    float wave1 = sin(radius * 3.0 + angle * 4.0);\n    float wave2 = sin(radius * 5.0 + angle * 6.0);\n    \n    // Combine waves and add noise for texture\n    float pattern = (wave1 + wave2) * 0.5;\n    pattern += turbulent(uv * 2.0 + iTime); // Add pulsing noise\n    \n    // Create pulsing color transitions using HSL\n    vec3 color = hsl(sin(iTime * 0.5) * 0.5 + 0.5, 1.0, 0.5);\n    \n    // Combine pattern with color and white for final effect\n    float brightness = (pattern * 0.5 + 0.5) * 0.8;\n    vec3 finalColor = mix(color, vec3(1.0), brightness);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_628.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create rotating pattern using sine waves\n    float pattern = sin(theta * 4.0 + iTime) * cos(r * 10.0 - iTime * 2.0);\n    \n    // Color based on angle and time\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.5 + iTime,\n        0.7,\n        0.8\n    ));\n    \n    // Add noise and turbulence\n    float noiseValue = turbulent(st * 10.0) * 0.5 + 0.5;\n    color *= noiseValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_629.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Base noise pattern with turbulence\n    float baseNoise = turbulent(uv * 5.0 + iTime) * 0.5 + 0.5;\n    \n    // Calculate distance from center and angle\n    float dist = length(uv);\n    float angle = atan2(uv.y, uv.x);\n    \n    // Create swirling pattern with time\n    float swirl = sin(iTime * 0.5 + angle * 4.0) * dist * 0.5;\n    \n    // Combine noise and swirling effect\n    float finalNoise = baseNoise + swirl;\n    \n    // Color based on position and noise\n    vec3 hslColor = vec3(\n        fract(angle * 0.1 + iTime * 0.1),\n        0.7,\n        mix(0.2, 0.9, finalNoise)\n    );\n    \n    // Convert to RGB and add glow effect\n    color = hsl2rgb(hslColor) * (1.0 - dist * 0.5) * exp(-dist * 3.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_63.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + iTime / 2.0;\n    \n    // Create turbulence pattern\n    float t = turbulent(st);\n    t += turbulent(st * 3.0 + 1.0) * 0.5;\n    \n    // Generate color from HSL values\n    vec3 color = hsl(\n        sin(t * 4.0 + iTime) * 0.5 + 0.5,\n        abs(sin(iTime / 2.0)) * 0.7 + 0.3,\n        abs(cos(t * 2.0 + iTime)) * 0.6 + 0.4\n    );\n    \n    // Add some color variation\n    color = mix(color, hsl(\n        sin(t * 5.0 + iTime) * 0.5 + 0.5,\n        abs(sin(iTime / 3.0)) * 0.7 + 0.3,\n        abs(cos(t * 4.0 + iTime)) * 0.6 + 0.4\n    ), 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_630.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying color shift\n    float time = iTime * 0.5;\n    \n    // Create a noise-based pattern with turbulence\n    vec2 st = uv * 10.0 + time;\n    float n = noise(st);\n    float t = turbulent(vec3(uv, time));\n    \n    // Combine noise and turbulence for dynamic color transitions\n    vec3 color = hsl2rgb(vec3(\n        (n + t) * 0.5 + 0.5,\n        sin(time * 0.1) * 0.5 + 0.5,\n        cos(time * 0.1) * 0.5 + 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_631.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Generate particles with noise and motion\n    for (int i = 0; i < 3; i++) {\n        float scale = pow(2.0, float(i)) * 5.0;\n        float timeScale = iTime * (1.0 + float(i) * 0.5);\n        \n        // Particle position with noise offset\n        vec2 pos = uv * scale + noise(vec3(uv * scale, iTime)) * 4.0;\n        \n        // Add motion to particles\n        pos += sin(timeScale + pos.x * pi) * 0.5;\n        \n        // Calculate distance from center\n        float dist = length(pos);\n        \n        // Create glowing effect with turbulence\n        float glow = turbulent(vec2(dist, iTime)) * 0.5 + 0.5;\n        \n        // Dynamic color shifts using HSL\n        vec3 hslColor = vec3(\n            timeScale * 0.1,\n            0.7 + sin(iTime) * 0.3,\n            glow * 0.8 + 0.2\n        );\n        vec3 rgbColor = hsl2rgb(hslColor);\n        \n        // Add to final color with trail effect\n        color += rgbColor * (1.0 - dist * 0.1) * pow(glow, 2.0);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_632.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation effects\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv * 1.5 - 0.5); // Scale and offset radius\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create geometric pattern using sine waves\n    float pattern = sin(theta * 12.0) * 0.5 + 0.5;\n    pattern *= r < 0.8 ? 1.0 : 0.0; // Apply circular mask\n    \n    // Dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(theta * 0.5 + iTime) * 0.5 + 0.5, // Hue\n        0.7, // Saturation\n        0.8 // Lightness\n    );\n    \n    // Add layered sine wave interference\n    float wave1 = sin(r * 80.0 - iTime * 2.0) * 0.3;\n    float wave2 = sin(r * 40.0 + theta * 5.0 + iTime) * 0.2;\n    float wave3 = sin(r * 20.0 - theta * 3.0 + iTime * 0.5) * 0.1;\n    \n    // Combine patterns and add noise\n    vec3 color = hsl2rgb(hslColor);\n    color *= pattern;\n    color += vec3(wave1, wave2, wave3);\n    color += noise(uv * 10.0) * 0.2;\n    \n    return vec4(color * 1.5 - 0.2, 1.0); // Scale and clamp\n}"
  },
  "data_633.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Add time-based rotation and create concentric circles\n    a += iTime * 0.5;\n    r = mod(r * 8.0 + iTime, 4.0) / 4.0;\n    // Create swirling pattern using turbulence\n    float t = turbulent(vec3(a, r, iTime * 0.2));\n    \n    // Convert to HSL and back to RGB for color transformation\n    vec3 hslColor = vec3(\n        a * 0.5 + 0.5,\n        1.0 - abs(r - 0.5) * 2.0,\n        0.8 + t * 0.2\n    );\n    \n    // Create fading trails effect\n    float fade = 1.0 - r * 0.7;\n    vec3 color = hsl2rgb(hslColor);\n    \n    return vec4(color, max(fade, 0.0));\n}"
  },
  "data_634.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base color shift\n    vec3 colorParams = vec3(\n        0.5 * sin(iTime * 0.5 + uv.x * 10.0),\n        0.5 * cos(iTime * 0.6 + uv.y * 10.0),\n        0.0\n    );\n    \n    // Add noise and turbulence effects\n    float noise1 = turbulent(uv * 5.0);\n    float noise2 = turbulent(vec3(uv * 2.0, iTime));\n    \n    // Create flowing liquid effect with color shifts\n    vec2 flowUV = uv + vec2(0.1 * sin(iTime), 0.1 * cos(iTime)) * noise1;\n    vec3 metalColor = hsl(\n        0.5 + 0.5 * noise2,\n        0.7 + 0.3 * noise1,\n        0.3 + 0.2 * turbulent(flowUV * 4.0)\n    );\n    \n    // Add dynamic color shifts based on mouse movement (simulated with time and noise)\n    vec3 finalColor = metalColor * mix(\n        hsl2rgb(vec3(0.5, 1.0, 0.5)),\n        hsl2rgb(vec3(0.2, 1.0, 0.8)),\n        0.5 + 0.5 * turbulent(uv * 10.0 + iTime)\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_635.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern\n    vec2 st = uv - 0.5;\n    float angle = iTime * 0.1;\n    st = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * st;\n    \n    // Add pulsating effect\n    float dist = length(st) * 4.0;\n    float pulse = sin(iTime * 0.5 + dist) * 0.5 + 0.5;\n    \n    // Generate noise patterns\n    vec3 noise1 = vec3(noise(vec2(dist, iTime)), noise(vec2(st.x*2.0, st.y*2.0)), noise(vec3(st*4.0, iTime)));\n    float turbulence = turbulent(vec2(st * 2.0)) * 0.5 + 0.5;\n    \n    // Create color gradients\n    vec3 color1 = hsl2rgb(vec3(0.6 + pulse * 0.3, 0.7, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.9 - pulse * 0.2, 0.5, 0.7));\n    \n    // Combine patterns and colors\n    vec3 finalColor = mix(color1, color2, turbulence);\n    finalColor *= pulse;\n    finalColor += noise1 * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_636.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position over time\n    vec2 pos = uv * 10.0 + iTime;\n    \n    // Create noise pattern with turbulence\n    float noiseVal = turbulent(pos);\n    \n    // Use HSL to create shifting colors\n    vec3 color = hsl(\n        mod(iTime * 0.5, 1.0),   // Hue shift over time\n        0.7 + noiseVal * 0.3,    // Saturation modulation\n        0.5 + sin(pos.x * 0.5) * 0.25 // Lightness variation\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_637.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate color shifts over time\n    float hue = sin(iTime * 0.5 + 1.0) * 0.5 + 0.5;\n    \n    // Create sine wave distortion pattern\n    vec2 distort = vec2(\n        sin(uv.y * 4.0 + iTime) * 0.3,\n        cos(uv.x * 4.0 + iTime * 0.7) * 0.3\n    );\n    \n    // Combine original UV with distortion\n    vec2 distortedUV = uv + distort;\n    \n    // Add noise for extra detail\n    float noiseVal = noise(vec3(distortedUV, iTime));\n    \n    // Create plasma effect using HSL to RGB conversion\n    vec3 color = hsl(\n        hue * 360.0,\n        0.7 + sin(iTime) * 0.2,\n        0.5 + noiseVal * 0.4\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_638.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create a grid of points that move over time\n    vec2 st = uv * 10.0; // Scale up for more cells\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Add some movement to the grid points using sine waves\n    vec2 pos = ipos + vec2(sin(time + ipos.x) * 0.5, cos(time + ipos.y) * 0.5);\n    \n    // Calculate distance from current point to moving grid points\n    float d = length(fpos - fract(pos));\n    \n    // Add some turbulence to create an evolving pattern\n    float turb = turbulent(uv * 10.0 + time);\n    \n    // Combine cellular noise with sine waves\n    float wave = sin(st.x * 4.0 * PI) + cos(st.y * 4.0 * PI);\n    float final = d * 0.5 + wave * 0.3 + turb * 0.2;\n    \n    // Convert to color using HSL\n    vec3 color = hsl(final * 0.5 + time, 0.6, 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_639.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color using HSL with time-based hue variation\n    vec3 baseColor = hsl(\n        sin(iTime * 0.5 + uv.x * 10.0) * 0.5 + 0.5,  // Hue (with time animation)\n        0.7,  // Saturation\n        0.6   // Lightness\n    );\n    \n    // Add layered sine wave patterns with varying frequencies and amplitudes\n    float pattern = \n        sin(uv.x * 4.0 + iTime) * 0.5 +\n        sin(uv.y * 3.0 + iTime * 2.0) * 0.3 +\n        sin((uv.x + uv.y) * 6.0 + iTime * 1.5) * 0.2;\n    \n    // Add noise and turbulence for more dynamic effect\n    float noiseValue = turbulent(uv * 8.0 + vec2(iTime)) * 0.3;\n    \n    // Combine patterns and noise to create final color variation\n    vec3 finalColor = hsl2rgb(vec3(\n        (baseColor.r + pattern * 0.4 + noiseValue) * 0.8,\n        baseColor.g,\n        baseColor.b\n    ));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_64.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    // Add time-based wobble to angle and radius\n    theta += sin(r * 5.0 + iTime) * 0.5;\n    theta += turbulent(vec3(theta, r, iTime * 0.1)) * 0.2;\n    \n    r += sin(iTime * 2.0 + theta * 4.0) * 0.3;\n    r = mod(r, 2.0);\n    // Create color based on polar coordinates\n    vec3 color = hsl2rgb(vec3(\n        (theta / (2.0 * PI) + 0.5) * 0.7 + 0.3,\n        1.0 - abs(r - 1.0),\n        0.5\n    ));\n    return vec4(color, 1.0);\n}"
  },
  "data_640.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create mirrored patterns by transforming UV coordinates\n    vec2 st = fract(uv * 8.0);\n    st = mix(st, 1.0 - st, step(0.5, st));\n    \n    // Convert to polar coordinates for geometric shapes\n    vec2 polar = vec2(length(st - 0.5), atan2(st.y - 0.5, st.x - 0.5));\n    \n    // Add time-based color transitions\n    float hue = iTime * 0.1 + sin(polar.y) * 0.5;\n    vec3 color = hsl(hue, 1.0, 0.5);\n    \n    // Add noise and turbulence for dynamic patterns\n    float noiseVal = turbulent(vec2(polar.x * 4.0, polar.y));\n    color *= mix(1.0, noiseVal, 0.5);\n    \n    // Create layered effect with multiple frequencies\n    vec3 finalColor = mix(color, hsv2rgb(vec3(hue + 0.5, 1.0, 0.5)), 0.3);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_641.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv - 0.5;\n    st *= 4.0;\n    \n    float time = iTime * 0.1;\n    st.x += sin(time) * 0.5;\n    st.y += cos(time) * 0.5;\n    \n    vec2 p = st;\n    float freq = 0.1 + 0.1 * sin(iTime * 0.5);\n    float n = turbulent(p * freq);\n    \n    float r = length(st);\n    vec3 color = hsl2rgb(vec3(0.5 + n * 0.5, 1.0, 0.5 + r * 0.5));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_642.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate direction from center\n    vec2 dir = normalize(uv - 0.5);\n    \n    // Convert to polar coordinates\n    float angle = atan2(dir.y, dir.x);\n    float radius = length(uv - 0.5);\n    \n    // Create dynamic rays using sine waves and time\n    float segments = 16.0;\n    float rayIntensity = sin(angle + iTime * 0.5) / segments;\n    rayIntensity = abs(fract(rayIntensity + 0.5));\n    \n    // Add noise for organic feel\n    float noiseValue = noise(uv * 100.0);\n    float intensity = mix(noiseValue, rayIntensity, 0.7);\n    \n    // Create color using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.5 + angle / (2.0 * PI)),  // Hue over time and angle\n        0.8,                                      // Saturation\n        mix(0.5, 1.0, intensity)                  // Lightness based on intensity\n    ));\n    \n    return vec4(color, 0.9);\n}"
  },
  "data_643.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create dynamic sine wave patterns in both X and Y directions\n    float xWave = sin(uv.x * 8.0 + iTime) * 0.5 + 0.5;\n    float yWave = sin(uv.y * 8.0 + iTime * 0.5) * 0.5 + 0.5;\n    \n    // Combine waves with noise and turbulence\n    float pattern1 = sin(xWave * PI + yWave * PI) * 0.5 + 0.5;\n    float pattern2 = noise(uv * 4.0 + iTime) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor1 = vec3(\n        (pattern1 + pattern2) * 360.0,\n        0.7,\n        0.8\n    );\n    \n    vec3 hslColor2 = vec3(\n        (turbulent(uv * 16.0 + iTime) + 0.5) * 360.0,\n        0.6,\n        0.7\n    );\n    \n    // Mix colors based on patterns\n    color += hsl2rgb(hslColor1) * pattern1;\n    color += hsl2rgb(hslColor2) * (1.0 - pattern1);\n    \n    // Add time-based variations\n    float timeFactor = sin(iTime * 0.5) * 0.5 + 0.5;\n    color *= timeFactor + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_644.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern with triangles\n    vec2 center = uv * 2.0 - 1.0;\n    float angle = atan(center.y, center.x);\n    float radius = length(center);\n    \n    // Add animation over time\n    float animTime = iTime * 0.5;\n    \n    // Create triangle pattern using polar coordinates\n    vec3 color = vec3(0.0);\n    for(float i = 0.0; i < 3.0; i++) {\n        float triAngle = angle + (i * 2.0 * PI / 3.0) + animTime;\n        vec2 triPos = vec2(cos(triAngle), sin(triAngle)) * radius;\n        \n        // Apply RGB displacement\n        vec2 displacedPos = triPos + \n            vec2(sin(animTime + i * PI), cos(animTime + i * PI)) * 0.5;\n        \n        // Add noise and turbulence\n        float noiseVal = turbulent(displacedPos * 10.0 + animTime);\n        color += hsl2rgb(vec3(triAngle, 1.0, 0.5)) * (noiseVal * 0.5 + 0.5);\n    }\n    \n    // Combine with original position\n    vec2 finalPos = center + vec2(sin(animTime), cos(animTime)) * 0.3;\n    float finalRadius = length(finalPos) * 0.5 + 0.5;\n    \n    return vec4(color * finalRadius, 1.0);\n}"
  },
  "data_645.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise values\n    float n = noise(uv * 5.0 + iTime);\n    vec2 distortedUV = uv + sin(uv * 10.0 + iTime) * 0.1;\n    \n    // Add flowing motion\n    vec2 flow = vec2(\n        sin(uv.x * 3.0 + iTime * 2.0),\n        cos(uv.y * 3.0 + iTime * 2.0)\n    ) * 0.5;\n    \n    // Create ripples effect\n    float ripples = turbulent(distortedUV * 4.0 + iTime) *\n                   turbulent(distortedUV * 2.0 + iTime);\n    \n    // Generate color based on noise and time\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime * 0.5 + n * pi) * 0.5 + 0.5,\n        0.7 + ripples * 0.3,\n        0.1 + abs(sin(iTime)) * 0.4\n    ));\n    \n    // Add brightness variation\n    color *= 0.8 + sin(n * 2.0 + iTime) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_646.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    float time = iTime * 0.5;\n    \n    // Create rotating shape layers\n    for(float i = 0.0; i < 3.0; i++) {\n        float angle = time + i * PI/2.0;\n        mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n        \n        vec2 st = uv * rot;\n        st *= 5.0 + turbulent(vec3(st, time)) * 2.0;\n        \n        float d = length(st);\n        float c = sin(d * 10.0) * 0.5 + 0.5;\n        \n        vec3 col = hsl2rgb(vec3(\n            (time + i * 0.4) * 0.2,\n            0.7,\n            0.5 + turbulent(st.xy) * 0.2\n        ));\n        \n        color += mix(color, col, c);\n    }\n    \n    // Add noise texture overlay\n    vec2 noiseScale = uv * 10.0;\n    float n = noise(noiseScale) * 0.3;\n    color += n;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_647.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float angle = sin(iTime * 0.5) * 0.5 + 0.5;\n    vec2 rotatedUv = vec2(\n        uv.x * cos(angle) - uv.y * sin(angle),\n        uv.x * sin(angle) + uv.y * cos(angle)\n    );\n    \n    // Create sine wave patterns with time-based rotation\n    float waveX = sin(rotatedUv.x * 10.0 + iTime) * 0.5 + 0.5;\n    float waveY = sin(rotatedUv.y * 10.0 - iTime) * 0.5 + 0.5;\n    \n    // Mix waves with turbulence\n    float mixAmount = turbulent(vec2(waveX, waveY) * 4.0);\n    vec3 colorBase = hsl(\n        (iTime * 0.1 + rotatedUv.x * 0.5 + rotatedUv.y * 0.5) * 360.0,\n        0.7,\n        mixAmount * 0.6 + 0.4\n    );\n    \n    // Add dynamic color transitions\n    vec3 finalColor = hsv2rgb(vec3(\n        (iTime * 0.1 + waveX * 0.5 + waveY * 0.5) * 360.0,\n        0.7,\n        mixAmount * 0.6 + 0.4\n    ));\n    \n    // Add noise and brightness variation\n    float brightness = turbulent(rotatedUv * 8.0) * 0.2 + 0.8;\n    finalColor *= brightness;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_648.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating geometric patterns using sine and cosine functions\n    vec2 pos = uv * 10.0 - 5.0;\n    vec3 color = vec3(0.0);\n    \n    // Add circular motion with noise modulation\n    float angle = atan2(pos.y, pos.x) + time;\n    float radius = length(pos) + sin(time * 0.7) * 0.5;\n    vec2 polar = vec2(radius, angle);\n    \n    // Create shifting color palette using HSL conversion\n    vec3 hslColor = vec3(0.6 + sin(time * 0.3), 1.0, 0.5);\n    color += hsl2rgb(hslColor) * smoothstep(4.0, 5.0, radius);\n    \n    // Add square pattern with turbulence\n    vec2 squarePos = uv * 8.0 - 4.0;\n    float squareDist = max(abs(squarePos.x), abs(squarePos.y));\n    color += hsl2rgb(vec3(0.3 + cos(time * 0.5), 1.0, 0.5)) * \n             smoothstep(3.8, 4.2, squareDist);\n    \n    // Mix in noise patterns for added complexity\n    vec3 noisePos = vec3(uv * 4.0, time);\n    float noiseVal = turbulent(noisePos) * 0.5 + 0.5;\n    color += noiseVal * hsl2rgb(vec3(0.9 + sin(time * 0.4), 1.0, 0.3));\n    \n    // Combine all elements with blending\n    vec3 finalColor = mix(color, \n                         hsl2rgb(vec3(0.5 + time*0.1, 1.0, 0.8)),\n                         smoothstep(0.0, 1.0, sin(time * 0.2) * 0.5 + 0.5));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_649.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color with time-based hue\n    vec3 color = hsl(0.5 + turbulent(uv * 10.0) * 0.5, 1.0, 0.5);\n    \n    // Add noise layer with time animation\n    float n = noise(vec2(uv.x + iTime, uv.y)) * 50.0;\n    color += hsl(0.3 + n * 0.1, 0.8, 0.6);\n    \n    // Create pulsing effect\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    color *= hsv2rgb(vec3(0.0, 0.0, pulse));\n    \n    return vec4(clamp(color, 0.0, 1.0), 1.0);\n}"
  },
  "data_65.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates from UV\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan(st.y, st.x) + iTime * 0.5; // Rotate over time\n    float r = length(st);\n    \n    // Add wobbly effect using sine waves\n    theta += sin(theta * 3.0 + iTime) * 0.2;\n    r += sin(theta * 4.0 + iTime * 2.0) * 0.1;\n    \n    // Create twirly pattern using polar coordinates\n    vec2 twirl = vec2(\n        cos(theta) * r,\n        sin(theta) * r\n    );\n    \n    // Add sparkles using noise\n    float sparkle = turbulent(vec3(twirl * 5.0, iTime)) *\n                   turbulent(vec3(twirl * 10.0, iTime));\n    \n    // Create color transitions\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.5 + iTime * 0.2,\n        0.7 + sparkle * 0.3,\n        0.5 + sin(iTime) * 0.2\n    ));\n    \n    // Add sparkles overlay\n    color = mix(color, vec3(1.0), sparkle * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_650.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Transform UV coordinates to create hexagonal grid pattern\n    mat2 m = mat2(0.5, sqrt(3.0)/2.0, -sqrt(3.0)/2.0, 0.5);\n    vec2 st = fract(uv * 10.0) * 2.0 - 1.0;\n    st = m * st;\n    \n    // Calculate distance from center\n    float d = length(st);\n    vec2 coord = abs(st);\n    \n    // Create hexagonal pattern using transformed coordinates\n    float hex = max(coord.x, (coord.y * sqrt(3.0) + 1.0)/2.0);\n    \n    // Add pulsing effect using sine waves\n    float timePulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    vec3 color = hsl(hex * 360.0, 0.7, 0.5 * (sin(d * 4.0 - iTime * 2.0) * 0.5 + 0.5));\n    \n    // Apply turbulence and noise for additional effects\n    vec3 noiseVec = vec3(noise(vec3(uv * 10.0, iTime)), noise(vec3(uv * 10.0 + 1.0, iTime)), noise(vec3(uv * 10.0 + 2.0, iTime)));\n    float turb = turbulent(vec3(uv * 5.0, iTime));\n    \n    // Combine effects\n    color *= mix(1.0, 1.0 - turb * 0.3, timePulse);\n    color += noiseVec * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_651.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for spiral effect\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add time-based rotation and pulsing\n    theta += iTime * 0.5;\n    r += sin(theta + iTime) * 0.3;\n    \n    // Create spiraling rings using modular arithmetic\n    float ring = mod(r * 10.0 + iTime, 2.0);\n    float intensity = abs(1.0 - ring);\n    \n    // Add turbulence for dynamic texture\n    vec2 noiseUV = uv * 5.0 + iTime;\n    float noiseVal = turbulent(noiseUV) * 0.3;\n    intensity += noiseVal;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 hslColor = vec3(theta / (2.0 * PI), 1.0, 0.5 + intensity * 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_652.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to create a grid of triangles\n    vec2 st = uv * 16.0;\n    \n    // Get cell position and offset within cell\n    vec2 ipos = floor(st);\n    vec2 pos = fract(st);\n    \n    // Calculate triangle check based on position\n    bool insideTriangle = (pos.x + pos.y) < 1.0;\n    \n    // Create color variations using HSL to HSV conversion\n    float hueBase = mod(iTime * 0.5 + ipos.x * 0.2 + ipos.y * 0.3, 1.0);\n    vec3 baseColor = hsl(hueBase, 0.7, 0.6);\n    \n    // Add noise and turbulence for dynamic effects\n    float noiseVal = turbulent(vec3(st + iTime, 0.0)) * 0.5 + 0.5;\n    vec3 finalColor = insideTriangle ? \n        hsv2rgb(vec3(hueBase + noiseVal * 0.3, 0.8, 0.7)) : \n        baseColor * noiseVal;\n    \n    // Output the color\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_653.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal pattern\n    vec2 st = uv * 5.0; // Scale up for more cells\n    float theta = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Create hexagonal grid pattern using sine and cosine\n    float pattern = sin(theta * 6.0) + cos(theta * 6.0);\n    pattern += turbulent(vec3(st, iTime)) * 0.5; // Add turbulence\n    \n    // Pulsating effect with time\n    float pulse = sin(iTime * 2.0 + radius * 10.0) * 0.5 + 0.5;\n    \n    // Mouse interaction (assuming mouse position is available)\n    vec2 mousePos = vec2(0.5, 0.5); // Replace with actual mouse input\n    float mouseDist = length(mousePos - uv);\n    float glow = max(1.0 - mouseDist * 4.0, 0.0) * pulse;\n    \n    // Color calculation using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        (theta + iTime) * 180.0 / PI,\n        1.0,\n        0.5 + glow * 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_654.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base frequency using sine waves with varying frequencies\n    float wave1 = sin(uv.x * 8.0 + iTime * 2.0) * 0.5;\n    float wave2 = cos(uv.y * 6.0 - iTime * 3.0) * 0.4;\n    float wave3 = sin((uv.x + uv.y) * 12.0 + iTime) * 0.3;\n    \n    // Combine waves with different frequencies and phases\n    float combined = wave1 + wave2 + wave3;\n    \n    // Add turbulence to create more dynamic patterns\n    vec2 noiseUV = uv * 4.0; // Scale UV for higher frequency noise\n    float turb = turbulent(noiseUV) * 0.5;\n    combined += turb;\n    \n    // Create color from HSL values with time-based hue variation\n    vec3 color = hsl(\n        fract(iTime * 0.2 + uv.x * 10.0), // Hue varies over time and space\n        0.7, // Saturation\n        0.5 + combined * 0.4 // Lightness modulated by wave pattern\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_655.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV coordinates based on mouse position\n    vec2 st = (uv - 0.5) * 2.0;\n    \n    // Add time-based rotation\n    float t = iTime * 0.5;\n    float angle = atan(st.y, st.x);\n    angle += t; // Continuous rotation\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    vec2 polar = vec2(r, angle);\n    \n    // Create swirling pattern with turbulence\n    float swirl = sin(polar.y * 5.0 + t) * cos(polar.x * 10.0);\n    float noiseVal = turbulent(vec3(st * 10.0, t));\n    \n    // Calculate color using HSL to RGB conversion\n    vec3 color;\n    color.r = 0.5 + sin(t + polar.y * 2.0) * 0.5;\n    color.g = 0.5 + cos(t + polar.y * 2.0) * 0.5;\n    color.b = 0.5 + sin(t + polar.x * 2.0) * 0.5;\n    \n    // Add noise and swirl effect\n    color *= 1.0 + noiseVal * 0.3;\n    color += vec3(swirl * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_656.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create movement vector with time offset\n    vec2 st = uv * 5.0 + vec2(sin(iTime), cos(iTime)) * 3.0;\n    \n    // Add noise-based movement\n    vec2 movement = vec2(\n        noise(st + vec2(0.0, iTime * 0.5)),\n        noise(st + vec2(iTime * 0.5, 0.0))\n    ) * 0.4;\n    \n    // Calculate base color with time-based hue\n    vec3 baseColor = hsl2rgb(vec3(\n        fract(iTime * 0.1) * 360.0,\n        0.7,\n        0.5\n    ));\n    \n    // Add noise and turbulence for liquid effect\n    float liquidNoise = turbulent(st + movement);\n    vec3 finalColor = baseColor * (0.5 + liquidNoise * 0.5);\n    \n    // Add depth and lighting effects\n    finalColor *= mix(\n        vec3(1.0),\n        vec3(0.3, 0.4, 0.6),\n        smoothstep(0.0, 1.0, uv.y)\n    );\n    \n    // Add specular highlights\n    float spec = pow(max(dot(normalize(vec2(sin(iTime), cos(iTime))), vec2(1.0)), 0.0), 30.0);\n    finalColor += vec3(spec * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_657.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + sin(iTime * 0.5) * 0.5;\n    \n    // Create rotating geometric pattern with noise texture\n    float angle = theta + iTime * 0.2;\n    float sector = mod(angle * 4.0, PI);\n    float shape = turbulent(vec2(r * 10.0, angle)) * 0.5 + 0.5;\n    \n    // Dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(iTime * 0.3 + sector) * 0.5 + 0.5,\n        0.7 + turbulent(vec2(r * 5.0, iTime)) * 0.3,\n        0.5 + sin(r * 10.0 + iTime) * 0.5\n    );\n    \n    // Combine noise texture with color transitions\n    vec3 finalColor = hsl2rgb(hslColor) * shape;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_658.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create multiple frequency components for more interesting patterns\n    vec3 layers = vec3(\n        sin(r * 10.0 + theta * 3.0) * 0.5 + 0.5,\n        sin(r * 20.0 + theta * 5.0) * 0.5 + 0.5,\n        sin(r * 40.0 + theta * 7.0) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence\n    float noise1 = turbulent(vec2(theta, r)) * 0.5 + 0.5;\n    float noise2 = turbulent(vec2(theta * 2.0, r * 2.0)) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl(\n        theta * 0.1 + iTime * 0.1,\n        noise1 * 0.7 + 0.3,\n        noise2 * 0.6 + 0.4\n    );\n    \n    // Combine layers and colors\n    color *= mix(layers.x, layers.y, noise1);\n    color = mix(color, vec3(1.0), layers.z * 0.5);\n    \n    // Add some contrast\n    color = (color - 0.5) * 2.0;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_659.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form centered at (0.5, 0.5)\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create rotating radial waves\n    float wave = sin(r * 10.0 + theta * 3.0) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for more dynamic effect\n    vec2 noisePos = uv * 4.0; // Scale up for higher frequency noise\n    float noiseVal = noise(noisePos);\n    wave += turbulent(vec3(r, theta, iTime)) * 0.3;\n    \n    // Create color fade using HSL\n    vec3 hslColor = vec3(\n        sin(iTime) * 0.5 + 0.5, // Hue variation over time\n        1.0 - wave * 0.5,       // Saturation based on wave value\n        0.8 + noiseVal * 0.2    // Lightness with noise modulation\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_66.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create wobbly motion using sine waves and time\n    vec2 offset = sin(iTime * 0.5 + uv * 10.0) * 0.3;\n    vec2 distortedUV = uv + offset;\n    \n    // Add twirling effect by rotating coordinates around center\n    vec2 center = vec2(0.5);\n    vec2 polar = distortedUV - center;\n    float angle = atan(polar.y, polar.x) + iTime * 2.0;\n    float dist = length(polar) * 0.8;\n    \n    // Create sparkles using noise and turbulence\n    float sparkle = turbulent(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    float blend = sin(dist * 10.0 + iTime) * 0.5 + 0.5;\n    \n    // Combine colors with HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(angle * 0.1, 0.7, 0.8));\n    vec3 color2 = hsl2rgb(vec3(angle * 0.1 + 0.5, 0.6, 0.7));\n    \n    // Mix colors and add sparkle effect\n    vec3 finalColor = mix(color1, color2, blend) * (1.0 + sparkle * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_660.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float scale = 8.0;\n    vec2 st = uv * scale;\n    \n    // Create grid pattern with noise variations\n    vec2 cell = floor(st);\n    vec2 pos = fract(st + sin(iTime * 0.5 + cell.x * 10.0) * 0.3);\n    \n    // Add movement and complexity\n    float timeFactor = iTime * 0.1;\n    pos += vec2(sin(timeFactor + cell.y * 10.0), cos(timeFactor + cell.x * 10.0)) * 0.2;\n    \n    // Use noise to create organic patterns\n    float n = noise(vec3(pos, iTime * 0.5));\n    n = mod(n * 4.0 + timeFactor, 1.0);\n    \n    // Create color transitions with shifting hues\n    vec3 hslColor = vec3((n * 0.6 + 0.2) + timeFactor * 0.2, 0.8, 0.7);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add smooth transitions between colors\n    float gradient = smoothstep(0.1, 0.9, n);\n    rgbColor = mix(vec3(0.1), rgbColor, gradient);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_661.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create two sine waves with different frequencies and offsets\n    float wave1 = sin(uv.x * 5.0 + iTime) * 0.5;\n    float wave2 = sin(uv.y * 5.0 + iTime * 0.7) * 0.5;\n    \n    // Combine the waves with varying amplitudes\n    vec2 combined = vec2(wave1, wave2);\n    combined *= turbulent(vec3(uv * 4.0, iTime * 0.1)) * 0.5 + 0.5;\n    \n    // Create color variations using HSL\n    vec3 color = hsl(\n        (wave1 + wave2) * 0.5 + 0.5,\n        0.7,\n        0.6\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_662.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and rotate UV coordinates\n    vec2 st = uv * 5.0;\n    \n    // Create a grid of hexagons using polar coordinates\n    vec2 grid = floor(st + 0.5);\n    vec2 center = grid + 0.5;\n    vec2 toCenter = st - center;\n    \n    // Convert to polar coordinates\n    float theta = atan(toCenter.y, toCenter.x) + 0.5 * iTime;\n    float r = length(toCenter);\n    \n    // Create expanding rings with time-based pulsing\n    float ring = sin(r * 10.0 - iTime * 2.0) * 0.5 + 0.5;\n    \n    // Add turbulence and noise to the pattern\n    vec3 color = hsv2rgb(vec3(\n        theta * 0.5 + 0.5 * iTime,\n        ring * 0.7 + turbulent(vec3(st, iTime)) * 0.3,\n        1.0 - ring * 0.5 - noise(vec3(st, iTime)) * 0.2\n    ));\n    \n    // Combine the effects and output the final color\n    return vec4(color, 1.0);\n}"
  },
  "data_663.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 8.0 + iTime;\n    \n    // Create multi-scale noise patterns\n    float n1 = turbulent(st);\n    float n2 = turbulent(st * 0.5 + vec2(123.45, 678.9));\n    float n3 = turbulent(st * 0.25 + vec2(987.65, 432.1));\n    \n    // Create rotating gradient effect\n    vec2 polar = uv - 0.5;\n    float angle = atan2(polar.y, polar.x) + iTime * 0.2;\n    float radius = length(polar);\n    \n    // Combine noise and rotation effects\n    vec3 color = hsl2rgb(vec3(\n        mod(angle * 0.1 + n1 * 0.5, 1.0),\n        0.7 + n2 * 0.3,\n        0.8 + n3 * 0.2\n    ));\n    \n    // Add brightness variation\n    color *= 0.8 + n1 * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_664.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create radial gradient from center\n    vec2 pos = uv - 0.5;\n    float dist = length(pos);\n    dist *= 10.0; // Scale the distance\n    \n    // Add oscillating sine wave effect\n    float timeFactor = sin(iTime * 4.0) * 0.5 + 0.5;\n    float value = dist + sin(dist * 2.0 + iTime * 2.0) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(value * 0.6 + timeFactor, 1.0, 0.5);\n    \n    // Add noise for texture\n    float noiseValue = noise(uv * 8.0 + iTime) * 0.2;\n    value += noiseValue;\n    \n    // Final color with alpha\n    return vec4(hsl2rgb(vec3(value * 0.6 + timeFactor, 1.0, 0.5)), 1.0);\n}"
  },
  "data_665.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x);\n    // Add time-based rotation\n    theta += iTime * 0.5;\n    // Create a swirling pattern using sine distortion\n    r *= sin(theta * 3.0 + iTime) * 0.5 + 1.0;\n    \n    // Convert back to Cartesian coordinates\n    vec2 newUv = vec2(\n        cos(theta) * r,\n        sin(theta) * r\n    );\n    // Add turbulence for dynamic effect\n    float turb = turbulent(newUv * 4.0 + iTime);\n    turb += turbulent(vec3(newUv * 16.0, iTime)) * 0.5;\n    \n    // Create color based on polar coordinates and turbulence\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.15 + 0.5,\n        0.7 + turb * 0.3,\n        0.5 + (1.0 - r) * 0.5\n    ));\n    // Add noise for texture\n    color += noise(pos * 8.0 + iTime) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_666.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create wave patterns using sine and cosine functions\n    float speed = 0.5;\n    float time = iTime * speed;\n    \n    // Wave parameters\n    vec2 freq1 = vec2(4.0, 3.0);\n    vec2 freq2 = vec2(2.0, 4.0);\n    \n    // Generate wave patterns with different frequencies and phases\n    float wave1 = sin(uv.x * freq1.x + time) + cos(uv.y * freq1.y + time + PI/2.0);\n    float wave2 = sin(uv.y * freq2.x - time) + cos(uv.x * freq2.y - time + PI);\n    \n    // Combine waves and add turbulence\n    vec2 combined = vec2(wave1, wave2);\n    float turb = turbulent(combined * 5.0 + time);\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(time * 0.1, 1.0),   // Hue variation over time\n        0.7,                    // Saturation\n        0.5 + turb * 0.5        // Lightness influenced by turbulence\n    );\n    \n    // Convert HSL to RGB and mix with wave patterns\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = rgbColor * abs(wave1) * abs(wave2);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_667.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 centered = uv - 0.5;\n    \n    // Convert to polar coordinates\n    float radius = length(centered);\n    float angle = atan2(centered.y, centered.x);\n    \n    // Create a time-based rotation effect\n    angle += iTime * 0.5;\n    \n    // Add noise and turbulence\n    float noiseValue = noise(vec3(uv * 10.0 + iTime, 0.0)) * 0.5 + 0.5;\n    float turbulentValue = turbulent(vec2(angle * 10.0, radius * 10.0));\n    \n    // Create geometric pattern using sine waves\n    float pattern = sin(radius * 8.0 + iTime) * cos(angle * 4.0);\n    \n    // Combine patterns and add noise\n    float finalPattern = (pattern + turbulentValue) * 0.5 + noiseValue;\n    \n    // Convert to HSL and shift colors over time\n    vec3 hslColor = vec3(\n        fract(sin(angle + iTime) * 2.0),\n        abs(sin(radius * 4.0 + iTime)),\n        abs(cos(iTime))\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_668.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using sine waves with different frequencies\n    float pattern = sin(uv.x * 4.0 + iTime) * cos(uv.y * 3.0 + iTime * 2.0);\n    \n    // Add noise and turbulence for more dynamic patterns\n    vec2 noiseUV = uv * 10.0 + vec2(iTime, iTime * 0.5);\n    float noiseVal = noise(noiseUV) * 0.5;\n    pattern += turbulent(vec3(uv * 4.0, iTime)) * 0.3;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.5 + sin(iTime * 0.5) * 0.5, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.3 + cos(iTime * 0.6) * 0.5, 1.0, 0.7));\n    \n    // Mix colors based on pattern and noise\n    vec3 finalColor = mix(color1, color2, abs(pattern * 0.5 + noiseVal * 0.5));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_669.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 uv_centered = uv - 0.5;\n    float radius = length(uv_centered);\n    float angle = atan2(uv_centered.y, uv_centered.x);\n    // Create concentric circles pattern using radius\n    float circlePattern = sin(radius * 10.0 + iTime) * 0.5 + 0.5;\n    \n    // Add some noise and turbulence to create interesting patterns\n    vec2 noiseScale = uv * 400.0;\n    float noiseValue = noise(noiseScale);\n    circlePattern += noiseValue * 0.3;\n    // Create color transitions from red to blue using HSL\n    float hue = (radius * 0.6) + mod(iTime * 0.1, 1.0); // Shift hues over time\n    vec3 hslColor = vec3(hue, 1.0, 0.5);\n    \n    // Convert to RGB and mix with noise pattern\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = rgbColor * circlePattern;\n    // Add some angular variation for more dynamic effect\n    float angleFactor = sin(angle + iTime) * 0.3;\n    finalColor += angleFactor;\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_67.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale UV coordinates\n    vec2 st = (uv - 0.5) * 2.0;\n    \n    // Add rotation based on time\n    float angle = iTime * 2.0 * PI;\n    float ca = cos(angle);\n    float sa = sin(angle);\n    vec2 rotated = vec2(\n        st.x * ca - st.y * sa,\n        st.x * sa + st.y * ca\n    );\n    \n    // Create tiling pattern\n    vec2 tile = fract(abs(rotated) * 4.0);\n    \n    // Generate vibrant colors using HSL\n    float hue = (iTime * 0.5 + length(tile)) * PI;\n    vec3 color = hsl(hue, 1.0, 0.5);\n    \n    // Add noise and turbulence for dynamic effect\n    float noiseVal = turbulent(vec2(iTime, tile.x));\n    color *= mix(0.8, 1.2, noiseVal);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_670.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing pattern using noise and time\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Add turbulence for cascading effect\n    float t = turbulent(st);\n    \n    // Calculate depth based on position and time\n    float d = length(uv - vec2(0.5, 0.5)) * 3.0 + iTime * 2.0;\n    \n    // Create shimmering color transitions using HSL\n    vec3 c = hsl(d * 0.1, sin(iTime) * 0.5 + 0.5, cos(d * 0.5 + iTime) * 0.5 + 0.5);\n    \n    // Convert to RGB and apply turbulence for dynamic effect\n    vec3 color = hsl2rgb(c) * (1.0 + sin(t * 4.0 + iTime * 2.0)) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_671.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base coral structure using noise\n    float noise1 = noise(uv * 5.0 + iTime);\n    float noise2 = turbulent(uv * 3.0 + iTime * 0.5);\n    \n    // Generate pulsating color patterns\n    vec3 color1 = hsl(noise1 * pi, 0.8, 0.6);\n    vec3 color2 = hsl((noise2 + noise1) * pi, 0.7, 0.5);\n    \n    // Combine colors with time-based variation\n    float mixAmount = sin(iTime * 0.5 + uv.x * 4.0) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    // Add pulsating effect using sine wave\n    float pulse = sin(iTime * 2.0 + noise1 * pi) * 0.3 + 0.7;\n    finalColor *= pulse;\n    \n    // Create depth variation\n    vec2 st = uv * 4.0;\n    float depth = length(st);\n    depth = smoothstep(0.0, 4.0, depth);\n    finalColor *= depth;\n    \n    // Add turbulence effect\n    vec3 turbPos = vec3(uv * 2.0 + iTime, iTime * 0.5);\n    float turb = turbulent(turbPos) * 0.5 + 0.5;\n    finalColor = mix(finalColor, finalColor * turb, 0.4);\n    \n    // Final output with gamma correction\n    return vec4(pow(finalColor, vec3(1.2)), 1.0);\n}"
  },
  "data_672.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of triangles with dynamic tessellation\n    vec2 st = uv * 10.0 + iTime; // Scale and animate the grid\n    \n    // Calculate triangle rotation\n    float angle = sin(iTime * 0.5 + st.x * 3.14159) * 0.5;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    // Create rotating triangles pattern\n    vec2 rotatedUV = rot * (st - floor(st)) * 0.5 + 0.5;\n    \n    // Generate color gradients using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.1 + rotatedUV.x * 2.0, 1.0), // Hue variation over time and space\n        0.7, // Saturation\n        0.5 // Lightness\n    );\n    \n    // Convert HSL to RGB\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add turbulence for dynamic effect\n    float turb = turbulent(rotatedUV * 10.0 + iTime);\n    rgbColor *= 1.0 + turb * 0.5;\n    \n    // Create gradient from center of triangles\n    vec2 centerDist = rotatedUV - 0.5;\n    float dist = length(centerDist) * 3.0;\n    float gradient = smoothstep(0.0, 1.0, sin(dist * pi + iTime));\n    \n    // Combine everything for final color\n    return vec4(rgbColor * gradient, 1.0);\n}"
  },
  "data_673.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    float speed = 0.7;\n    float scale = 3.0;\n    float decay = 0.9;\n    // Particle position with oscillation\n    vec2 pos = uv * 2.0 - 1.0;\n    pos.x += sin(time + pos.y * scale) * 0.5;\n    pos.y += cos(time * speed + pos.x * scale) * 0.5;\n    \n    // Color based on position and time\n    vec3 color = hsl2rgb(vec3(\n        sin(pos.x * 10.0 + time) * 0.5 + 0.5,\n        abs(sin(time * 0.7 + pos.y * 5.0)) * 0.5 + 0.5,\n        0.8\n    ));\n    \n    // Add glow effect using turbulence\n    float glow = turbulent(vec3(pos, time)) * 0.2;\n    color += vec3(glow) * 1.5;\n    \n    // Control particle existence over time\n    float exist = sin(time * PI + pos.x * 10.0);\n    exist = abs(exist);\n    exist = pow(exist, decay);\n    \n    return vec4(color * exist, 1.0);\n}"
  },
  "data_674.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create pulsating sine wave pattern with time-based RGB shifts\n    \n    // Base wave pattern\n    vec2 st = sin(uv * 10.0 + iTime);\n    st += sin(uv * 5.0 - iTime); // Add another wave for complexity\n    \n    // Pulsating effect using time modulation\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    \n    // RGB color shifts with different frequencies\n    vec3 color = vec3(\n        sin(st.x * 2.0 + iTime * 0.5), // Red channel\n        sin(st.y * 2.0 + iTime * 0.7 + 1.0), // Green channel\n        sin((st.x + st.y) * 2.0 + iTime * 1.0 + 2.0) // Blue channel\n    );\n    \n    // Add noise and turbulence for more dynamic effect\n    float noiseVal = noise(uv * 5.0 + vec2(iTime));\n    color += turbulent(vec3(uv, iTime)) * 0.3;\n    \n    // Scale and mix colors\n    color *= pulse * 1.5;\n    color = mix(vec3(0.0), color, 0.6);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_675.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add rotation\n    \n    // Create hexagonal grid pattern\n    const float hexScale = 8.0;\n    vec2 hexCoords = vec2(r * cos(theta), r * sin(theta)) * hexScale;\n    \n    // Use turbulence to create dynamic patterns\n    float turb = turbulent(hexCoords + iTime);\n    \n    // Calculate color based on position and time\n    vec3 colorHSL = vec3(\n        fract((theta / (pi * 2.0)) + iTime * 0.1), // Hue variation\n        0.8, // Saturation\n        0.5 + 0.5 * sin(iTime) // Pulsating lightness\n    );\n    \n    // Convert HSL to RGB and mix with turbulence\n    vec3 finalColor = hsl2rgb(colorHSL) * (0.5 + 0.5 * turb);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_676.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of rotating triangles\n    vec2 st = fract(uv * 10.0); // Tile the space\n    \n    // Add rotation based on time\n    float angle = sin(iTime + 5.0 * (st.x + st.y)) * 0.5;\n    vec2 rotatedUV = cos(angle) * uv - sin(angle) * uv.yx;\n    \n    // Create triangle pattern\n    vec2 triangle = fract(rotatedUV * 10.0);\n    float triangleMask = step(1.0, triangle.x + triangle.y);\n    \n    // Add noise overlay\n    float noiseValue = noise(uv * 5.0 + iTime);\n    vec3 noiseColor = hsl2rgb(vec3(noiseValue * 0.6 + 0.3, 0.8, 0.7));\n    \n    // Create color transitions based on time\n    vec3 baseColor = hsl2rgb(vec3(iTime * 0.1, 0.5, 0.5));\n    vec3 finalColor = mix(baseColor, noiseColor, triangleMask * 0.6);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_677.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create a complex noise pattern using multiple octaves\n    float n = turbulent(st);\n    \n    // Generate color based on position and time\n    vec3 color = hsl(\n        0.5 + turbulent(vec2(uv * 20.0 + iTime)) * 0.5, \n        0.7,\n        0.5 + sin(iTime) * 0.2\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_678.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create expanding rings effect with time\n    r *= iTime * 0.5;\n    \n    // Generate base color using HSL\n    vec3 color = hsl(r + theta * 0.1, 0.7, 0.6);\n    \n    // Add noise texture for complexity\n    float noiseVal = noise(vec2(uv.x * 4.0, uv.y * 4.0) + iTime);\n    color += vec3(noiseVal * 0.3);\n    // Create turbulence effect\n    float turb = turbulent(vec2(r * 0.5, theta));\n    color *= mix(1.0, 1.5, turb);\n    // Add lighting effects\n    float glow = smoothstep(0.8, 1.0, r);\n    color += vec3(glow * 0.4);\n    return vec4(color, 1.0);\n}"
  },
  "data_679.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create a grid of nodes using noise and time\n    float nodePulse = turbulent(uv * 10.0 + iTime) * sin(iTime * 0.5) + 0.5;\n    \n    // Calculate distance to nearest node points\n    vec2 distToNode = min(abs(uv - floor(uv)), abs(uv - ceil(uv)));\n    float nodeDistance = length(distToNode);\n    \n    // Create glowing nodes\n    if (nodeDistance < 0.05) {\n        color += vec3(1.0) * (1.0 + nodePulse * 2.0);\n    }\n    \n    // Calculate distance to edges between nodes\n    float edgeDistance = min(length(uv - vec2(0.5)), length(uv - vec2(0.5, 0.0)));\n    edgeDistance = min(edgeDistance, length(uv - vec2(0.0, 0.5)));\n    \n    // Create pulsing connections between nodes\n    if (edgeDistance < 0.1) {\n        float hue = fract(iTime * 0.3 + uv.x * 0.7);\n        color += hsl(hue, 1.0, 0.5).rgb;\n    }\n    \n    // Add some glow around the nodes\n    if (nodeDistance < 0.1) {\n        color += vec3(1.0) * (1.0 - nodeDistance / 0.1);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_68.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create three prongs for biohazard symbol\n    float angleStep = pi / 3.0;\n    float prongWidth = 0.15;\n    \n    // Calculate each prong position with turbulence\n    float prong1 = step(r, 0.8 - turbulent(vec2(theta + angleStep * 0.0, iTime * 0.1)));\n    float prong2 = step(r, 0.8 - turbulent(vec2(theta + angleStep * 1.0, iTime * 0.1)));\n    float prong3 = step(r, 0.8 - turbulent(vec2(theta + angleStep * 2.0, iTime * 0.1)));\n    // Combine prongs and add noise to center\n    float combined = (prong1 + prong2 + prong3) / 3.0;\n    combined += step(r, 0.4) * turbulent(vec2(iTime * 0.5));\n    // Create color transitions using HSL\n    vec3 color1 = hsl(0.6, 0.8, 0.7);\n    vec3 color2 = hsl(0.3, 0.8, 0.7);\n    vec3 color3 = hsl(0.0, 0.8, 0.7);\n    // Mix colors based on position\n    float mix1 = smoothstep(0.6, 0.9, r) * sin(theta + iTime);\n    float mix2 = smoothstep(0.6, 0.9, r) * cos(theta + iTime);\n    \n    vec3 finalColor = mix(color1, color2, mix1) + mix(color3, color1, mix2);\n    // Apply combined shape to colors\n    return vec4(finalColor * combined, 1.0);\n}"
  },
  "data_680.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Grid coordinates\n    vec2 st = uv * 20.0;\n    vec2 i = floor(st + 0.5);\n    \n    // Time-based animation\n    float time = iTime * 0.5;\n    \n    // Calculate distance from grid points\n    vec2 pos = fract(st) - 0.5;\n    float dist = length(pos);\n    \n    // Pulsating effect with noise modulation\n    float pulse = sin(time + dist * 10.0 + noise(vec3(i, time))) * 0.5 + 0.5;\n    \n    // Color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract((i.x + i.y) * 0.1 + time),\n        0.7,\n        0.5 + pulse * 0.3\n    ));\n    \n    // Add depth variation\n    color *= 0.8 + noise(vec3(uv * 2.0, time)) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_682.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a flowing pattern using noise and turbulence\n    vec3 color = vec3(0.0);\n    \n    // Generate base noise patterns with time variation\n    float n1 = noise(uv * 100.0 + iTime);\n    float n2 = turbulent(uv * 50.0 + iTime) * 0.5;\n    float flow = (n1 + n2) * 0.5;\n    \n    // Add movement to the pattern\n    vec2 pos = uv - 0.5;\n    float dist = length(pos);\n    float angle = atan2(pos.y, pos.x);\n    \n    // Create color variations using HSL\n    vec3 hslColor = vec3(\n        sin(iTime * 0.1 + flow * 2.0) * 0.5 + 0.5,\n        0.7 + abs(flow) * 0.3,\n        0.5 + dist * 0.5\n    );\n    \n    // Convert to RGB and mix with distance-based color\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor = mix(rgbColor, vec3(1.0), turbulent(vec3(uv * 20.0, iTime)) * 0.5 + 0.5);\n    \n    // Add glowing effect using distance from center\n    float glow = smoothstep(0.7, 1.0, dist) * 0.5;\n    rgbColor += glow;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_683.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying distortion pattern\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Add turbulence to create complex patterns\n    float turb = turbulent(st);\n    \n    // Generate color using noise and HSL conversion\n    vec3 color = hsl2rgb(vec3(\n        noise(vec3(uv, iTime)) * 0.6 + 0.4,\n        0.7,\n        0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_684.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 centered = uv - 0.5;\n    float r = length(centered);\n    float theta = atan2(centered.y, centered.x);\n    \n    // Create rotating pattern with triangular symmetry\n    float timeRotation = iTime * 0.5;\n    theta += timeRotation;\n    \n    // Use mod to create repeating sectors\n    theta = mod(theta, PI * 2.0);\n    float triangleSector = mod(theta * 3.0, PI * 2.0);\n    \n    // Create color variations using noise and turbulence\n    vec2 noiseCoords = vec2(triangleSector, r) * 10.0;\n    float c = 0.5 * r + 0.5 * turbulent(noiseCoords);\n    \n    // Convert to RGB with rotating colors\n    vec3 color = hsl2rgb(vec3(triangleSector * 2.0, 1.0, c));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_685.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create base noise patterns\n    vec3 noise1 = vec3(noise(uv + time), noise(uv * 2.0 + time * 0.5), noise(uv * 0.5 + time));\n    vec3 noise2 = vec3(turbulent(uv * 4.0 + time), turbulent(uv * 2.0 + time), turbulent(uv + time));\n    \n    // Create distortion effect\n    vec2 distortedUV = uv + sin(time) * 0.1 * noise1.xy;\n    distortedUV += sin(distortedUV * pi) * 0.2;\n    \n    // Color transformation with metallic feel\n    vec3 color = hsl(\n        mod(time * 0.5 + noise1.x, 1.0), \n        0.7 + noise1.z * 0.3,\n        0.8 + noise2.x * 0.2\n    );\n    \n    // Add shimmer effect\n    float shimmer = sin(uv.x * pi + time) * sin(uv.y * pi + time * 0.5);\n    color += vec3(0.1, 0.1, 0.2) * (1.0 + shimmer * 0.5);\n    \n    // Combine layers with noise\n    color = mix(color, hsl2rgb(vec3(mod(time * 0.3 + noise2.y, 1.0), 0.6, 0.7)), noise2.z * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_686.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using UV coordinates and time\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Add noise to create organic movement\n    float n = noise(st);\n    \n    // Create a turbulence effect that changes over time\n    float t = turbulent(vec3(uv, iTime));\n    \n    // Combine positional and temporal variations\n    vec2 posVar = uv * 5.0 + vec2(sin(iTime), cos(iTime)) * 2.0;\n    float noiseVar = noise(posVar);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        sin(iTime) * 0.5 + 0.5,\n        abs(cos(iTime)) * 0.7 + 0.3,\n        abs(sin(uv.x * PI + iTime)) * 0.6 + 0.4\n    );\n    \n    // Convert to RGB and mix with noise values\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = rgbColor * (1.0 - n) + hsv2rgb(vec3(n, t, 1.0));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_687.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create color from angle and radius\n    vec3 color = hsl2rgb(vec3(\n        fract(a / (pi * 2.0)) * 360.0,\n        sin(r * 5.0 + iTime) * 0.5 + 0.5,\n        cos(r * 10.0 + a * 3.0) * 0.5 + 0.5\n    ));\n    \n    // Add noise and turbulence\n    float noiseVal = noise(vec2(a, r)) * 0.5;\n    float turb = turbulent(vec2(a, r * 0.5)) * 0.5;\n    \n    color *= mix(1.0, 0.5, noiseVal + turb);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_688.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float rot = sin(iTime * 0.5 + 1.0);\n    vec2 rotatedUV = cos(rot) * (uv - 0.5) + sin(rot) * (uv.yx - 0.5) + 0.5;\n    \n    // Create polar coordinates\n    vec2 toCenter = rotatedUV - 0.5;\n    float radius = length(toCenter);\n    float angle = atan2(toCenter.y, toCenter.x) + iTime;\n    \n    // Generate noise values with time variation\n    float n1 = noise(vec3(rotatedUV * 4.0, iTime));\n    float n2 = turbulent(vec2(angle * 2.0, radius * 5.0));\n    float n3 = turbulent(vec3(rotatedUV * 8.0, iTime * 2.0));\n    \n    // Create color variations\n    vec3 color1 = hsl(angle * 0.5 + 0.5, 0.6, 0.5);\n    vec3 color2 = hsl(angle * 0.5 + 0.5 + iTime * 0.1, 0.7, 0.6);\n    \n    // Mix noise and colors\n    vec3 finalColor = mix(color1, color2, n1 * 0.5 + 0.5);\n    finalColor *= sin(radius * 8.0 + iTime) * 0.5 + 0.5;\n    finalColor += n2 * 0.4;\n    finalColor += n3 * 0.3;\n    \n    // Add brightness variation\n    float brightness = sin(iTime * 0.2 + radius * 6.0) * 0.5 + 0.5;\n    finalColor *= brightness;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_689.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 centerUv = uv - 0.5;\n    \n    // Calculate distance from center\n    float dist = length(centerUv);\n    \n    // Create expanding/contracting radius using time and sine function\n    float radius = sin(iTime * 3.0) * 0.4 + 0.6; // Vary radius between 0.2 and 1.0\n    \n    // Add turbulence to create interesting patterns\n    float turbulentRadius = turbulent(vec3(dist, iTime, 0.0)) * 0.1;\n    \n    // Calculate angle for color variation\n    float theta = atan2(centerUv.y, centerUv.x);\n    \n    // Create vibrant colors using HSL\n    vec3 hslColor = vec3(\n        theta / (2.0 * PI) + 0.5 + iTime * 0.1, // Hue\n        0.7 + turbulent(vec3(uv, iTime)) * 0.3,   // Saturation\n        0.5 + sin(iTime + dist * 10.0) * 0.5     // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 color = hsl2rgb(hslColor);\n    \n    return vec4(color, 0.8); // Add some transparency for a softer look\n}"
  },
  "data_69.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Blade parameters\n    float bladeWidth = 0.1;\n    float max_r = 0.4 + turbulent(vec3(iTime * 0.1)) * 0.2;\n    \n    // Create three blades\n    float blade1 = abs(sin(theta - PI/3.));\n    float blade2 = abs(sin(theta + PI/3.));\n    float blade3 = abs(sin(theta + PI));\n    \n    // Combine blades and create mask\n    float blades = (blade1 + blade2 + blade3) / 3.0;\n    blades = smoothstep(0.5, 1.0, blades);\n    \n    // Create circular boundary\n    float circle = smoothstep(max_r - 0.1, max_r, r);\n    \n    // Combine elements\n    vec3 color = hsl2rgb(vec3(60.0/360.0, 0.8, 0.5 + noise(vec3(iTime)) * 0.2));\n    vec3 finalColor = mix(vec3(0.1), color, blades);\n    \n    // Add glow effect\n    float glow = turbulent(vec2(r * 10.0, iTime * 0.1));\n    finalColor += glow * 0.5;\n    \n    return vec4(finalColor * circle, 1.0);\n}"
  },
  "data_690.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create particle positions using noise and time\n    vec3 pos = vec3(uv * 2.0 - 1.0, iTime);\n    float speed = 0.5;\n    \n    // Generate particle movement based on mouse position\n    vec2 mousePos = (uv + sin(iTime)) * 0.5 + 0.5;\n    float distanceToMouse = length(uv - mousePos);\n    \n    // Create attraction/repulsion effect using noise\n    float attract = sin(iTime) * 0.5 + 0.5;\n    float repel = cos(iTime) * 0.5 + 0.5;\n    \n    // Calculate particle velocity\n    vec3 vel = vec3(\n        noise(pos.xz + iTime),\n        noise(pos.yz + iTime + 123.456),\n        noise(pos.xy + iTime + 678.9)\n    ) * speed;\n    \n    // Add turbulence effect\n    float turb = turbulent(pos * 0.5);\n    vel *= 1.0 + turb * 0.5;\n    \n    // Calculate particle position over time\n    pos += vel * iTime;\n    \n    // Create glowing particles with color transitions\n    vec3 color = hsl2rgb(vec3(\n        distanceToMouse * 360.0,\n        0.7,\n        0.5 + sin(iTime) * 0.5\n    ));\n    \n    // Add glow effect based on particle density\n    float glow = length(uv - pos.xy) * 10.0;\n    color *= smoothstep(0.0, 1.0, glow);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_691.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal mapping\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal grid pattern using polar coordinates\n    float theta = a + iTime * 0.1;\n    float x = r * cos(theta) * 0.5;\n    float y = r * sin(theta) * 0.5;\n    // Add noise and turbulence to create organic movement\n    vec2 noisePos = vec2(x, y);\n    float n = noise(noisePos + iTime * 0.1);\n    float t = turbulent(noisePos * 4.0);\n    // Calculate particle intensity with pulsing effect\n    float intensity = sin(r * 5.0 + iTime) * 0.5 + 0.5;\n    intensity *= n * 2.0;\n    intensity += t * 0.3;\n    // Create color based on position and time\n    vec3 color = hsl(a / (2.0 * PI), 1.0, 0.5);\n    color = hsl2rgb(color);\n    // Add pulsing effect to color\n    color *= intensity;\n    color += sin(iTime + a) * 0.3;\n    // Apply radial falloff and return final color\n    float globalIntensity = sin(r * 10.0 - iTime * 2.0);\n    color *= (1.0 - r * 0.5);\n    return vec4(color, 1.0);\n}"
  },
  "data_692.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for swirling effect\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create swirly pattern using sine waves and turbulence\n    float swirl = sin(a * 4.0 + iTime * 2.0) * 0.5 + 0.5;\n    float distortion = sin(r * 10.0 + iTime) * 0.3;\n    \n    // Add noise for organic texture\n    vec2 noisePos = uv * 5.0 + iTime;\n    float n = turbulent(noisePos);\n    \n    // Combine effects\n    a += swirl * 0.2 + distortion;\n    r *= 1.0 + n * 0.3;\n    \n    // Create rotating gradient using HSL colors\n    vec3 color = hsl(a * 0.5, 0.7, 0.6);\n    color = hsl2rgb(color);\n    \n    // Add noise-based modulation to color\n    color *= 1.0 + n * 0.4;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_693.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of cells with noise-based positions\n    vec2 pos = floor(uv * 10.0);\n    vec2 cellPos = pos + turbulent(vec3(pos, iTime)) * 0.5;\n    \n    // Calculate distance to nearby cells\n    float dist = length(uv * 10.0 - cellPos);\n    \n    // Create pulsing color patterns using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.1 + pos.x * 0.5) * 360.0,\n        0.7,\n        0.5\n    ));\n    \n    // Add interaction between cells based on distance\n    float interact = smoothstep(0.0, 1.0, sin(iTime + dist * 2.0));\n    color *= mix(vec3(1.0), vec3(0.5, 0.5, 1.0), interact);\n    \n    // Create glowing effect using turbulence\n    float glow = turbulent(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    color *= mix(color, vec3(1.0), glow * 0.5);\n    \n    // Combine multiple layers of cells\n    for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n            vec2 neighborPos = pos + vec2(i, j);\n            vec2 neighborCell = neighborPos + turbulent(vec3(neighborPos, iTime)) * 0.5;\n            float neighborDist = length(uv * 10.0 - neighborCell);\n            \n            // Blend colors from neighboring cells\n            vec3 neighborColor = hsl2rgb(vec3(\n                fract(iTime * 0.1 + neighborPos.x * 0.5) * 360.0,\n                0.7,\n                0.5\n            ));\n            \n            float blendAmount = smoothstep(1.0, 0.0, neighborDist);\n            color = mix(color, neighborColor, blendAmount * 0.2);\n        }\n    }\n    \n    // Add overall glow and contrast\n    color = pow(color, vec3(2.0));\n    return vec4(color, 1.0);\n}"
  },
  "data_694.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create a rotating beam pattern using noise and time\n    float time = iTime * 0.5;\n    float beamAngle = mod(theta + time, PI);\n    \n    // Add some turbulence to the beam shape\n    vec3 noisePos = vec3(uv * 10.0, time);\n    float turbulence = turbulent(noisePos) * 0.2;\n    \n    // Create color dispersion effect\n    vec3 colorHSL = vec3(beamAngle / PI + 0.5, 1.0, r * 0.5 + 0.5 + turbulence);\n    vec3 rgbColor = hsl2rgb(colorHSL);\n    // Combine beam shape and colors\n    float intensity = max(0.0, cos(r * 4.0 - time) * 0.5 + 0.5);\n    rgbColor *= intensity;\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_695.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate the grid\n    float time = iTime * 0.5;\n    \n    // Create shifting grid pattern using noise\n    vec2 st = uv * 10.0 + time;\n    vec2 cell = floor(st);\n    vec2 pos = fract(st);\n    \n    // Calculate line offsets using noise\n    float noiseX = noise(vec3(cell.x, 0.0, time)) * 0.5;\n    float noiseY = noise(vec3(0.0, cell.y, time)) * 0.5;\n    \n    // Create bending effect with sine waves\n    float waveX = sin(pos.x * pi + time) * 0.2;\n    float waveY = sin(pos.y * pi + time) * 0.2;\n    \n    // Combine offsets and waves for final line positions\n    vec2 lines = vec2(noiseX + waveX, noiseY + waveY);\n    \n    // Calculate distance to nearest line\n    float dist = min(length(lines), length(lines - vec2(1.0)));\n    \n    // Create color based on proximity to lines\n    vec3 color = hsl(dist * 0.6 + 0.3, 1.0, 0.5);\n    color *= 1.0 - abs(sin(time * 0.5) * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_696.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern based on time and UV coordinates\n    float t = iTime * 0.5;\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Polar coordinates for rotation effect\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + t;\n    \n    // Add noise and turbulence to create dynamic patterns\n    float n = noise(uv * 5.0 + vec2(t));\n    float turb = turbulent(uv * 10.0 + vec2(t*0.5));\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(theta * 2.0, r * 0.5 + 0.5, n * 0.5 + 0.5);\n    \n    // Add geometric patterns\n    float pattern = step(0.7, sin(theta * 6.0 + t)) *\n                    step(0.3, cos(theta * 4.0 + t*0.5));\n    \n    // Combine elements for final effect\n    vec3 finalColor = color * (1.0 - turb * 0.5) + pattern * 0.7;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_697.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create expanding circle pattern\n    float dist = length(st);\n    dist += sin(iTime) * 0.5; // Add time-based expansion\n    \n    // Generate color using HSL with shifting hues\n    vec3 color = hsl(\n        mod(dist + iTime, 1.0), // Hue that shifts over time\n        0.7, // Saturation\n        0.5 + noise(uv * 10.0) * 0.2 // Lightness with noise variation\n    );\n    \n    // Add turbulence effect to create more dynamic pattern\n    float turb = turbulent(vec3(st.x, st.y, iTime));\n    color = mix(color, vec3(1.0), abs(turb) * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_698.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a swarm of lights with circular paths and color trails\n    const int numLights = 8;\n    float time = iTime * 0.5;\n    \n    // Array of light parameters (radius, initial angle offset)\n    float radii[numLights] = float[](\n        0.4, 0.35, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05\n    );\n    \n    // Array of initial angle offsets for each light\n    float angles[numLights] = float[](\n        0.0, pi/4.0, pi/2.0, 3.0*pi/4.0,\n        pi, 5.0*pi/4.0, 3.0*pi/2.0, 7.0*pi/4.0\n    );\n    \n    vec3 color = vec3(0.0);\n    \n    // Additive blending of multiple lights with trails\n    for (int i = 0; i < numLights; i++) {\n        float radius = radii[i];\n        float angleOffset = angles[i];\n        \n        // Circular motion with varying speed based on noise\n        float angle = time * mod(noise(vec3(i, time, 0.0)), 2.0) + angleOffset;\n        \n        // Polar to cartesian coordinates\n        vec2 pos = radius * vec2(cos(angle), sin(angle));\n        \n        // Create trailing effect by sampling multiple past frames\n        for (float t = -1.0; t <= 0.0; t += 0.5) {\n            float mixAmount = smoothstep(0.0, 1.0, abs(t));\n            \n            // Calculate position at previous time step\n            vec2 prevPos = radius * vec2(cos(angle + t), sin(angle + t));\n            \n            // Color based on angle and trail length\n            vec3 lightColor = hsv2rgb(vec3(\n                (angleOffset + t) / (2.0*pi) + 0.5,\n                1.0,\n                mix(0.8, 0.3, mixAmount)\n            ));\n            \n            // Additive blending with distance attenuation\n            float dist = length(uv - prevPos);\n            float falloff = smoothstep(0.2, 0.0, dist);\n            \n            color += lightColor * falloff * (1.0 - mixAmount);\n        }\n    }\n    \n    // Post-process the final color\n    color = pow(color, vec3(0.7)); // Gamma correction\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_699.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for radial effect\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    // Create pulsating animation using time and sine waves\n    float timeScale = sin(iTime * 0.5) * 0.5 + 0.5;\n    float radiusPulse = sin(r * 10.0 + iTime * 2.0) * 0.3;\n    \n    // Add turbulence for dynamic texture\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float turb = turbulent(noiseUV);\n    \n    // Create vibrant color gradients using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        sin(theta * 5.0 + iTime) * 0.5 + 0.5,  // Hue variation\n        0.8 + turb * 0.2,                       // Saturation\n        0.5 + radiusPulse                        // Lightness variation\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add radial motion and smooth transitions\n    float radialFactor = sin(r * 10.0 + iTime) * 0.5;\n    rgbColor *= sin(theta * 5.0 + iTime) * 0.5 + 0.5;\n    \n    // Combine all elements for final color\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(1.0, 0.8, 0.6),  // Warm color overlay\n        turb * 0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_7.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using UV coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float dist = length(st);\n    \n    // Add some time-based movement\n    float time = iTime * 0.5;\n    float radius = sin(time + dist * 4.0) * 0.5 + 0.5;\n    \n    // Use noise to create a more organic pattern\n    vec3 color = hsl2rgb(vec3(\n        mod(dist * 10.0 + time, 1.0),\n        1.0,\n        0.5\n    ));\n    \n    // Add some turbulence for dynamic effect\n    float turb = turbulent(st * 4.0 + vec2(time));\n    color *= 1.0 + turb * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_70.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and polar coordinates\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create three blades at 120 degree angles\n    float blade1 = mod(theta + 1.047, 2.094); // 120 degrees in radians\n    float blade2 = mod(theta + 2.094, 2.094);\n    float blade3 = mod(theta + 3.141, 2.094);\n    \n    // Blade shape using sawtooth wave\n    float bladeShape = sin(blade1 * 6.0) + \n                      sin(blade2 * 6.0) + \n                      sin(blade3 * 6.0);\n    \n    // Add noise for dynamic effect\n    float noiseValue = noise(vec2(r, iTime * 0.5));\n    bladeShape += noiseValue * 0.3;\n    \n    // Main circle with glow\n    float mainCircle = 1.0 - smoothstep(0.8, 1.0, r);\n    mainCircle += turbulent(vec2(r, theta)) * 0.2;\n    \n    // Combine elements\n    vec3 color = hsl2rgb(vec3(\n        mod(theta * 5.0 + iTime, 1.0), // Hue variation\n        0.7, // Saturation\n        0.5 // Lightness\n    ));\n    \n    float finalShape = mainCircle * (bladeShape * 0.6 + 0.4);\n    return vec4(color * finalShape, 1.0);\n}"
  },
  "data_700.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 center = uv - 0.5;\n    float r = length(center);\n    float theta = atan2(center.y, center.x);\n    // Create hexagonal shape using polar coordinates\n    theta += sin(iTime * 0.5 + theta) * 0.5; // Add some movement to the angles\n    vec2 rotated = vec2(cos(theta), sin(theta));\n    \n    // Calculate distance from center in a rotating coordinate system\n    float dist = length(vec2(\n        r * cos(6.0 * (theta - iTime)), \n        r * sin(6.0 * (theta - iTime))\n    )) / 15.0;\n    \n    // Create pulsating effect using sine wave with time modulation\n    float pulse = sin(iTime + dist * 2.0) * 0.5 + 0.5;\n    dist *= pulse;\n    // Add noise to create dynamic variations\n    vec3 color = hsl(\n        iTime * 0.1 + fract(dist * 10.0), \n        0.7, \n        0.5 + turbulent(vec2(iTime, dist)) * 0.3\n    );\n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_701.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add time offset for rotation\n    \n    // Create hexagonal pattern using sine waves\n    float angle = fract(theta / (pi * 2.0 / 6.0)); // Divide circle into 6 segments\n    float radius = sin(iTime * 3.0 + theta * 3.0) * 0.5 + 0.5; // Pulsating effect\n    \n    // Add noise for dynamic texture\n    vec2 noisePos = vec2(r, angle);\n    float noiseVal = noise(noisePos * 10.0); // High frequency noise\n    \n    // Combine radius and noise for final shape\n    float d = r + (radius + noiseVal) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(fract(theta / pi + iTime), 1.0, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Mix colors based on distance and noise\n    float mixAmount = smoothstep(0.5, 1.0, d);\n    vec3 finalColor = mix(vec3(0.0), rgbColor, mixAmount);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_702.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create dynamic sine wave patterns with varying frequencies\n    float time = iTime * 0.5;\n    \n    // Wave components with different frequencies and phases\n    float wave1 = sin(uv.x * 4.0 + time) + cos(uv.y * 3.0 + time * 2.0);\n    float wave2 = sin(uv.y * 5.0 - time) + cos(uv.x * 2.0 + time * 3.0);\n    float wave3 = sin(uv.x * uv.y * 10.0 + time) * cos(time * 4.0);\n    \n    // Combine waves with RGB shifts\n    vec3 color = vec3(\n        sin(wave1 * 2.0 + time) * 0.5 + 0.5,   // Red channel\n        sin(wave2 * 2.0 + time * 0.7) * 0.5 + 0.5, // Green channel\n        sin(wave3 * 2.0 + time * 1.4) * 0.5 + 0.5  // Blue channel\n    );\n    \n    // Add turbulence for more dynamic patterns\n    vec2 noiseUV = uv * 8.0 + time;\n    float turb = turbulent(noiseUV);\n    color += turb * 0.3;\n    \n    // Apply HSL transformation for better color control\n    vec3 hslColor = hsl(color.x, color.y, color.z);\n    color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_703.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float angle = iTime * 0.5;\n    vec2 rotatedUV = vec2(\n        uv.x * cos(angle) - uv.y * sin(angle),\n        uv.x * sin(angle) + uv.y * cos(angle)\n    );\n    // Create hexagonal grid pattern\n    vec2 grid = rotatedUV * 10.0; // Scale up for more cells\n    vec2 hexCoords = fract(grid);\n    \n    // Calculate distance to center of hexagon\n    float dist = length(hexCoords - 0.5);\n    \n    // Use HSV color with time-varying hue\n    vec3 hsvColor;\n    hsvColor.x = (length(rotatedUV) + iTime * 0.2) * 0.6; // Hue varies with position and time\n    hsvColor.y = 1.0; // Full saturation for vibrant colors\n    hsvColor.z = 1.0 - dist * 2.0; // Brightness decreases with distance from center\n    \n    // Convert to RGB and apply turbulence effect\n    vec3 rgbColor = hsv2rgb(hsvColor);\n    float turb = turbulent(vec3(rotatedUV, iTime * 0.1)) * 0.5 + 0.5;\n    \n    // Final color with dynamic shifts\n    return vec4(rgbColor * (1.0 + turb * 0.5), 1.0);\n}"
  },
  "data_704.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create undulating pattern using sine waves\n    float wave = sin(uv.x * 4.0 + iTime) + sin(uv.y * 4.0 + iTime);\n    \n    // Add time-based movement to the pattern\n    vec2 st = uv * 3.0 + vec2(iTime, 0.0);\n    \n    // Generate color using HSL with rotating hue\n    vec3 color = hsl2rgb(vec3(sin(iTime * 0.5) * 0.5 + 0.5, 0.7, 0.6));\n    \n    // Combine wave pattern with color\n    vec4 finalColor = vec4(color * (wave * 0.5 + 0.5), 1.0);\n    \n    return finalColor;\n}"
  },
  "data_705.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise pattern with turbulence\n    float noise1 = turbulent(uv * 5.0 + iTime);\n    vec3 color = hsl2rgb(vec3(0.6, 0.7, 0.5));\n    \n    // Add pulsating effect using time and sine wave\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    color *= pulse;\n    \n    // Create flowing lines pattern\n    vec2 flowUV = uv * 10.0 - iTime;\n    float line = sin(flowUV.x * 0.5 + iTime) * 0.5 + 0.5;\n    line = turbulent(vec3(flowUV, 0.0)) * 0.5 + 0.5;\n    \n    // Combine patterns and add glow effect\n    vec3 finalColor = mix(color, hsl2rgb(vec3(0.4, 0.8, 0.6)), line);\n    finalColor *= noise1 * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_706.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // X-direction sine wave with frequency modulation\n    float freqX = 5.0 + sin(time) * 2.0;\n    float waveX = sin(float(freqX) * uv.x * PI * 2.0 + time);\n    \n    // Y-direction sine wave with different frequency and phase\n    float freqY = 4.0 + cos(time) * 2.0;\n    float waveY = sin(float(freqY) * uv.y * PI * 2.0 + time + 1.5708); // Phase shift\n    \n    // Combine waves for interference pattern\n    float interference = (waveX + waveY) * 0.5;\n    \n    // Color shifts using HSL colors\n    vec3 colorR = hsl(0.0, 0.7, 0.5 + abs(sin(time + 0.0)));\n    vec3 colorG = hsl(0.333, 0.7, 0.5 + abs(cos(time + 1.0)));\n    vec3 colorB = hsl(0.666, 0.7, 0.5 + abs(sin(time + 2.0)));\n    \n    // Convert to RGB and combine with interference pattern\n    vec3 finalColor = \n        hsl2rgb(colorR) * (interference + 1.0)/2.0 +\n        hsl2rgb(colorG) * (interference + 1.0)/2.0 +\n        hsl2rgb(colorB) * (interference + 1.0)/2.0;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_707.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a pulsating nebula effect with dynamic colors and motion\n    \n    // Calculate distance from center\n    vec2 pos = uv * 2.0 - 1.0;\n    float dist = length(pos);\n    \n    // Add time-based pulsation\n    float timePulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Create color layers using HSL\n    vec3 baseColor = hsl2rgb(vec3(0.6, 1.0, 0.5));\n    vec3 secondaryColor = hsl2rgb(vec3(0.3, 1.0, 0.7));\n    \n    // Add noise and turbulence for dynamic patterns\n    float noiseVal = turbulent(pos * 4.0 + iTime);\n    float distNoise = turbulent(pos * 2.0 + vec2(iTime)) * 0.5;\n    \n    // Create radial motion effect\n    float angle = atan2(pos.y, pos.x) + timePulse * 2.0;\n    float radius = length(pos) + sin(angle * 3.0 + iTime) * 0.1;\n    \n    // Mix colors based on distance and noise\n    vec3 color = mix(baseColor, secondaryColor, smoothstep(0.5, 1.5, dist + noiseVal));\n    \n    // Add pulsation effect to color intensity\n    float intensity = sin(radius * 8.0 + iTime) * 0.5 + 0.5;\n    color *= (intensity + timePulse) * 0.7;\n    \n    // Create a glowing outer layer\n    float glow = smoothstep(1.2, 1.4, dist);\n    color += secondaryColor * glow * 0.8;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_708.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates centered at screen center\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += iTime * 0.5;\n    // Create rotating geometric pattern using sine waves at different frequencies\n    float pattern = sin(theta * 4.0 + iTime) * 0.5 +\n                   sin(theta * 8.0 - iTime * 2.0) * 0.3 +\n                   sin(r * 16.0 + iTime) * 0.2;\n    // Add noise and turbulence for more dynamic effect\n    pattern += turbulent(vec2(st.x, st.y)) * 0.2;\n    pattern += turbulent(vec2(iTime, r)) * 0.15;\n    // Convert to HSL color space with time-based hue transition\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + pattern) * 360.0,\n        0.7 + abs(sin(iTime * 0.2)) * 0.3,\n        0.5 + r * 0.4\n    );\n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_709.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base pattern\n    float t = iTime * 0.5;\n    \n    // Generate noise layers with different scales\n    vec2 st = uv * 8.0;\n    float n1 = noise(st + t);\n    float n2 = noise(st * 2.0 + t * 0.7) * 0.5;\n    float n3 = noise(st * 4.0 + t * 0.4) * 0.3;\n    \n    // Combine noise layers\n    float pattern = (n1 + n2 + n3) * 0.5 + 0.5;\n    \n    // Add rotation effect using polar coordinates\n    vec2 toCenter = uv - 0.5;\n    float angle = atan(toCenter.y, toCenter.x);\n    float dist = length(toCenter);\n    angle += t * 4.0; // Rotate over time\n    \n    // Create color cycling effect using HSL colors\n    float hue = sin(angle + t) * 0.5 + 0.5;\n    vec3 hslColor = vec3(hue, 1.0, 0.7);\n    \n    // Convert to RGB and mix with noise pattern\n    vec3 color = hsl2rgb(hslColor) * pattern;\n    \n    // Add some transparency for a glowing effect\n    return vec4(color, pattern * 0.8);\n}"
  },
  "data_71.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    \n    // Create basic circle shape\n    float circle = step(0.4, r);\n    \n    // Add rotating prongs using sine waves\n    float time = iTime * 0.1;\n    float angle = atan2(st.y, st.x) + time;\n    float prong1 = sin(angle * 3.0 - time * 2.0) * 0.5 + 0.5;\n    float prong2 = sin(angle * 3.0 + time * 2.0) * 0.5 + 0.5;\n    \n    // Combine shapes with noise and turbulence\n    float noiseVal = noise(vec2(r, angle)) * 0.1;\n    float turbulentVal = turbulent(vec2(r, angle)) * 0.3;\n    \n    // Create color variations\n    vec3 baseColor = hsl(60.0, 1.0, 1.0);\n    vec3 accentColor = hsl(0.0, 1.0, 1.0);\n    vec3 finalColor = mix(baseColor, accentColor, prong1 * prong2 + noiseVal + turbulentVal);\n    \n    // Final composition\n    float alpha = smoothstep(0.35, 0.45, r) * (prong1 + prong2 + 0.5);\n    return vec4(finalColor, alpha);\n}"
  },
  "data_710.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate and animate UV coordinates\n    float time = iTime * 0.5;\n    vec2 rotatedUV = vec2(\n        cos(time)*uv.x - sin(time)*uv.y,\n        sin(time)*uv.x + cos(time)*uv.y\n    );\n    \n    // Create a grid of tiles with noise patterns\n    vec2 tileCoords = rotatedUV * 10.0;\n    vec2 tilePos = fract(tileCoords);\n    \n    // Generate turbulence pattern within each tile\n    float turb = turbulent(vec3(tilePos, time));\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(tileCoords.x + time, 1.0) * 2.0,\n        0.7,\n        0.6\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add glow effect based on turbulence\n    float glow = smoothstep(0.5, 1.0, turb + length(tilePos - 0.5));\n    \n    // Combine color and glow for final output\n    return vec4(rgbColor * (1.0 + glow * 0.5), 1.0);\n}"
  },
  "data_711.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequency components\n    float freq = 5.0;\n    \n    // Add time-based movement\n    vec3 color = vec3(\n        sin(uv.x * freq + iTime) + sin(uv.y * freq/2.0 + iTime*0.5),\n        sin(uv.x * freq*1.5 + iTime*0.7) + sin(uv.y * freq*1.2 + iTime),\n        sin(uv.x * freq*2.0 + iTime*1.4) + sin(uv.y * freq*0.8 + iTime*0.3)\n    );\n    \n    // Add RGB shifts\n    vec3 offsets = vec3(\n        sin(iTime * 0.2) * 0.5 + 0.5,\n        sin(iTime * 0.3 + PI) * 0.5 + 0.5,\n        sin(iTime * 0.4 + PI*2.0) * 0.5 + 0.5\n    );\n    \n    // Add turbulence for organic movement\n    float turb = turbulent(vec3(uv, iTime)) * 0.1;\n    \n    // Combine everything and normalize to [0,1] range\n    color += sin(offsets + uv.xxy * vec3(2.0, 3.0, 4.0) + iTime) + turb;\n    color = (color * 0.5) + 0.5; // Normalize\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_712.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Animate rotation and radius\n    float time = iTime * 0.5;\n    a += time;\n    r *= 0.7 + turbulent(vec3(r, a, time)) * 0.3;\n    // Create orbiting shapes using sine waves\n    float shape = sin(a * 8.0 + time) * 0.5 + 0.5;\n    shape = mix(shape, abs(sin(r * 10.0 - time)), turbulent(vec2(r, a)) * 0.3);\n    // Color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        (sin(time) * 0.5 + 0.5) * 360.0,\n        1.0,\n        0.5 + turbulent(vec3(r, a, time)) * 0.5\n    ));\n    // Combine elements and output\n    float final = mix(shape, r, 0.2);\n    return vec4(color * (final), 1.0);\n}"
  },
  "data_713.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing motion by offsetting UV with time\n    vec2 st = uv * 5.0 + iTime * 0.1;\n    \n    // Add turbulence for dynamic flow patterns\n    float flow = turbulent(st + sin(iTime)*3.0);\n    flow += turbulent(st*0.5 + cos(iTime)*2.0) * 0.5;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(\n        mod(flow * 10.0 + iTime, 1.0),   // Hue variation\n        0.7 + flow * 0.3,                // Saturation\n        0.5 + sin(iTime) * 0.2           // Lightness modulation\n    );\n    \n    // Add metallic sheen using noise patterns\n    float metal = noise(vec3(uv*10.0, iTime)) * 0.5 + 0.5;\n    color *= hsl2rgb(vec3(0.0, 0.0, metal));\n    \n    // Create flowing gradient effect\n    vec2 flowUV = uv * 4.0 + iTime;\n    float gradient = turbulent(flowUV) * 0.5 + 0.5;\n    \n    // Combine effects with depth perception\n    vec3 finalColor = mix(\n        color,\n        hsl2rgb(vec3(0.0, 0.0, 1.0)),  // Add highlight effect\n        gradient * 0.8\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_714.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of points\n    vec2 st = uv * 10.0;\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Calculate rotation angle based on position and time\n    float angle = iTime * (dot(ipos, vec2(1.0, 1.0)) + 1.0);\n    \n    // Convert to polar coordinates for hexagonal pattern\n    vec2 uvPolar;\n    uvPolar.x = length(fpos - 0.5);\n    uvPolar.y = atan2(fpos.y - 0.5, fpos.x - 0.5) + angle;\n    \n    // Create hexagonal shape using polar coordinates\n    float d = max(abs(uvPolar.x * cos(uvPolar.y)), abs(uvPolar.x * sin(uvPolar.y)));\n    \n    // Add noise to create variation in rotation and color\n    angle += noise(vec3(uv * 5.0, iTime)) * 0.2;\n    \n    // Create pulsating RGB colors using HSL\n    float hue = iTime * 0.2 + length(ipos) * 0.1;\n    vec3 color = hsl(hue, 1.0, 0.5);\n    \n    // Create stroke effect for hexagons\n    float alpha = 1.0 - smoothstep(0.45, 0.5, d);\n    \n    return vec4(color * (1.0 - noise(vec3(uv * 2.0, iTime)) * 0.3), alpha);\n}"
  },
  "data_715.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Create 8 orbiting points with random parameters\n    for (int i = 0; i < 8; i++) {\n        float timeOffset = noise(vec3(i, 0.0, 0.0)) * 10.0;\n        float radius = 0.2 + noise(vec3(i, 1.0, 0.0)) * 0.1;\n        float orbitSpeed = 0.5 + noise(vec3(i, 2.0, 0.0)) * 0.3;\n        \n        // Calculate point position in polar coordinates\n        float angle = (iTime + timeOffset) * orbitSpeed;\n        vec2 pointPos = vec2(cos(angle), sin(angle)) * radius;\n        \n        // Convert UV to polar coordinates relative to point\n        vec2 offsetUV = uv - pointPos;\n        float dist = length(offsetUV);\n        float angleUV = atan2(offsetUV.y, offsetUV.x);\n        \n        // Create expanding rings effect\n        float ringWidth = 0.05 + turbulent(vec3(uv * 10.0, iTime)) * 0.03;\n        float ringFactor = mod(dist - iTime * 0.1, ringWidth) / ringWidth;\n        \n        // Calculate color based on distance and time\n        vec3 color = hsl2rgb(vec3(\n            fract((iTime + dist * 5.0) * 0.1) * 360.0,\n            0.7 + turbulent(vec2(uv * 10.0)) * 0.3,\n            0.8 + ringFactor * 0.4\n        ));\n        \n        // Add to final color with distance attenuation\n        float attenuation = smoothstep(radius, 0.0, dist);\n        finalColor += color * attenuation;\n    }\n    \n    // Blend with background color\n    vec3 bgColor = hsl2rgb(vec3(iTime * 0.1 * 360.0, 0.1, 0.2));\n    finalColor = mix(bgColor, finalColor, min(finalColor.r + finalColor.g + finalColor.b, 1.0));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_716.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create center-relative coordinates\n    vec2 center = uv - 0.5;\n    \n    // Calculate distance from center for radial gradient\n    float dist = length(center * 0.7);\n    \n    // Add time-based pulsation using sine wave\n    float pulse = sin(iTime * 0.5) * 0.3 + 0.7;\n    \n    // Create swirling pattern using polar coordinates\n    vec2 polar = vec2(length(center), atan2(center.y, center.x));\n    \n    // Use noise and turbulence for dynamic color variations\n    float noiseVal = turbulent(uv * 10.0 + iTime);\n    \n    // Combine elements into HSL color space\n    vec3 hslColor = vec3(\n        (polar.y / pi + pulse) * 0.5,  // Hue\n        0.7 + noiseVal * 0.3,          // Saturation\n        dist * 0.6 + pulse * 0.4      // Lightness with pulsation\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_717.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    // Create rotating color wheels using HSL colors\n    float hue = (angle + iTime) / (2.0 * PI);\n    vec3 hslColor = vec3(hue, 1.0, 0.5);\n    \n    // Add pulsating rings effect\n    float pulse = sin(iTime * 2.0 + radius * 8.0) * 0.5 + 0.5;\n    float ringIntensity = abs(sin(radius * PI * 4.0 - iTime)) * pulse;\n    // Combine with noise for more complex patterns\n    vec3 noiseColor = vec3(noise(vec2(angle, radius)), \n                          noise(vec2(angle + PI/2.0, radius)),\n                          noise(vec2(angle + PI, radius)));\n    \n    // Mix colors and effects\n    vec3 finalColor = hsl2rgb(hslColor) * (1.0 - ringIntensity) + noiseColor * ringIntensity;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_718.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    vec2 pos = uv - 0.5;\n    float dist = length(pos);\n    \n    // Create radial waves with increasing frequency\n    float t = iTime * 0.5;\n    float radius = dist * 10.0 + sin(t * 2.0) * 3.0;\n    float wave1 = sin(radius + t) * 0.5;\n    float wave2 = sin(radius * 1.5 - t) * 0.4;\n    \n    // Add intertwining sine waves in different directions\n    vec2 st = uv * 8.0;\n    float xWave = sin(st.x * pi + t) * 0.3;\n    float yWave = sin(st.y * pi + t + PI/2.0) * 0.3;\n    float diagWave = sin((st.x + st.y) * pi + t + PI) * 0.2;\n    \n    // Combine waves with dynamic color shifts\n    vec3 color1 = hsl2rgb(vec3(0.5 + wave1, 0.7, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.3 + wave2, 0.6, 0.7));\n    \n    // Create pulsating center effect\n    float pulse = sin(t * 4.0) * 0.5 + 0.5;\n    float centerEffect = smoothstep(0.8, 1.0, dist * 2.0);\n    vec3 finalColor = mix(color1, color2, wave1 + wave2 + xWave + yWave + diagWave);\n    \n    // Add turbulence and noise\n    vec3 noisePos = vec3(uv * 4.0, t);\n    float turb = turbulent(noisePos) * 0.2;\n    finalColor += turb * (1.0 - centerEffect);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_719.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 centered = uv - 0.5;\n    float radius = length(centered);\n    float angle = atan2(centered.y, centered.x);\n    // Add rotation over time\n    angle += iTime * 0.5;\n    \n    // Create kaleidoscope effect by mirroring angles\n    angle = mod(angle + PI, PI); // Mirror every pi radians\n    angle = mod(angle, PI/6.0) * 12.0; // Divide into 12 sectors\n    \n    // Mirror radius based on angle division\n    float mirroredRadius = (mod(floor(angle / (PI/6.0)), 2.0) == 0.0) ? radius : 0.5 - radius;\n    \n    // Create color pattern using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        mod(radius * 10.0 + iTime, 1.0), // Hue variation with time and radius\n        0.7 + turbulent(vec2(uv) * 5.0 + iTime), // Saturation with turbulence\n        0.5 + sin(angle * 3.0 + iTime) * 0.5 // Lightness variation with angle and time\n    );\n    \n    // Convert HSL to RGB and add noise for extra detail\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor += noise(vec3(uv * 10.0, iTime)) * 0.2;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_72.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create center point\n    vec2 st = uv - 0.5;\n    \n    // Add rotation based on time\n    float angle = sin(iTime * 0.5) + cos(iTime);\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotated = rot * st;\n    \n    // Create distance field with noise and turbulence\n    float d = length(rotated);\n    d += noise(vec3(d, iTime * 0.1, 0.0)) * 0.5;\n    d += turbulent(vec2(d, iTime)) * 0.3;\n    \n    // Map distance to color using HSV\n    vec3 hsvColor = vec3(\n        (d + iTime) * 0.2,\n        0.7 + noise(vec3(d, iTime, 1.0)) * 0.3,\n        smoothstep(0.0, 1.0, 1.0 - d)\n    );\n    \n    // Convert to RGB and add ghost effect\n    vec3 color = hsv2rgb(hsvColor);\n    color *= smoothstep(0.8, 1.0, d);\n    \n    // Add inner glow\n    float glow = smoothstep(0.6, 0.7, d) * 0.5;\n    color += glow;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_720.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of light rays with time-based movement\n    vec2 st = uv * 10.0 + sin(iTime) * 5.0;\n    \n    // Add distortion using noise and turbulence\n    vec3 noiseDistort = vec3(st.x, st.y, iTime * 0.5);\n    float distort = turbulent(noiseDistort) * 0.5 + 0.5;\n    \n    // Create a kaleidoscopic pattern by mirroring coordinates\n    vec2 mirroredUv = fract(abs(uv * 4.0)) * 2.0 - 1.0;\n    \n    // Add color variation using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        distort * 360.0,\n        0.7 + sin(iTime) * 0.3,\n        0.5 + cos(iTime * 0.5) * 0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Create radial light rays effect\n    float distanceFromCenter = length(uv - 0.5);\n    float lightIntensity = (1.0 - smoothstep(0.0, 0.8, distanceFromCenter)) * 2.0;\n    \n    // Combine all elements for the final effect\n    vec3 finalColor = rgbColor * lightIntensity;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_721.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * 5.0 + sin(iTime) * 10.0;\n    float n = noise(st);\n    float t = turbulent(st);\n    \n    vec3 color = hsl2rgb(vec3(\n        (sin(iTime * 0.5) + 0.5) * 0.7,\n        0.6 + sin(length(st)) * 0.1,\n        0.5 + n * 0.4\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_722.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a pulsating plasma effect with geometric overlays\n    \n    // Base noise pattern with time transformation\n    float time = iTime * 0.5;\n    vec3 noise1 = vec3(noise(uv * 10.0 + time), \n                       noise(uv * 10.0 + time * 0.7),\n                       noise(uv * 10.0 + time * 0.4));\n    \n    // Add turbulence for more dynamic patterns\n    float turb = turbulent(uv * 5.0 + vec2(time, time)) * 0.5 + 0.5;\n    \n    // Create geometric overlay pattern\n    vec3 geomPattern = vec3(1.0);\n    geomPattern.r *= sin(uv.x * 4.0 + time) * 0.5 + 0.5;\n    geomPattern.g *= cos(uv.y * 4.0 + time * 0.7) * 0.5 + 0.5;\n    geomPattern.b *= sin((uv.x + uv.y) * 6.0 + time * 0.3) * 0.5 + 0.5;\n    \n    // Combine noise and geometric patterns\n    vec3 finalColor = mix(noise1, geomPattern, turb);\n    \n    // Add color shifting based on viewer movement (simulated by time)\n    vec3 hslColor = vec3(finalColor.r * 0.7 + 0.3,\n                         finalColor.g * 0.6 + 0.4,\n                         finalColor.b * 0.5 + 0.5);\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_723.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add time variation\n    vec2 st = uv * 5.0 + iTime * 0.5;\n    \n    // Create a sine wave pattern with time offset\n    float t = iTime * 0.5;\n    float x = sin(st.x * 2.0 + t) * 0.5 + 0.5;\n    float y = sin(st.y * 3.0 + t) * 0.5 + 0.5;\n    \n    // Combine patterns and add turbulence\n    float pattern = abs(x - y) + turbulent(vec2(uv * 10.0));\n    \n    // Convert to HSL color space with time-based hue shift\n    vec3 color = hsl(pattern * 0.6 + 0.3, 0.8, 0.5);\n    color = hsl2rgb(color);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_724.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates based on time for movement\n    vec2 p = uv * (1.0 + sin(iTime) * 0.5);\n    \n    // Apply noise and turbulence to create dynamic patterns\n    float n = noise(vec2(p.x, p.y)) + turbulent(vec2(p.x*0.5, p.y*0.5));\n    \n    // Create pulsating grid lines\n    float gridX = fract(p.x * 10.0);\n    float gridY = fract(p.y * 10.0);\n    float grid = (min(gridX, 1.0 - gridX) + min(gridY, 1.0 - gridY)) * sin(iTime);\n    \n    // Combine noise and grid patterns\n    float value = n + grid;\n    \n    // Convert to RGB using HSL color space for dynamic colors\n    vec3 color = hsl2rgb(vec3(value*0.6 + 0.3, 0.8, 0.5));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_725.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar (distance from center)\n    float d = length(uv);\n    \n    // Create concentric rings using time-based expansion\n    float t = iTime * 0.5;\n    float ring = floor(d + t * 0.2) * 0.2;\n    \n    // Create color cycling effect using HSL colors\n    vec3 color1 = hsl(ring * 360.0, 0.7, 0.5);\n    vec3 color2 = hsl((ring + 1.0) * 360.0, 0.7, 0.5);\n    \n    // Mix colors with time-based fade\n    float mixAmount = sin(t * 0.5 + ring * pi) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    // Add noise for ripples effect\n    vec2 noiseUV = uv * 8.0 + t;\n    float n = noise(noiseUV) * 0.1;\n    d += n;\n    \n    // Create fading rings using distance from center\n    float intensity = sin((d - t) * 4.0) * 0.5 + 0.5;\n    finalColor *= intensity;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_726.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create base geometric pattern using sine waves and noise\n    vec2 st = uv * 16.0 + time;\n    float pattern = sin(st.x * 0.5 + time) * cos(st.y * 0.5) +\n                    sin(st.x * 0.7 + time * 0.3) * cos(st.y * 0.9);\n    \n    // Add noise and turbulence\n    vec2 noiseSt = uv * 8.0;\n    float noiseVal = noise(noiseSt + time) * 0.5;\n    pattern += noiseVal;\n    \n    // Create flowing gradient effect\n    vec3 color1 = hsl2rgb(vec3(0.2, 0.7, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.8, 0.6, 0.4));\n    float mixAmount = sin(uv.x * pi + time) * 0.5 + 0.5;\n    vec3 baseColor = mix(color1, color2, mixAmount);\n    \n    // Add dynamic color shifts\n    float hueShift = sin(time * 0.3) * 0.2;\n    vec3 finalColor = hsv2rgb(vec3(hueShift + uv.x * 0.4, 0.7, pattern * 0.5 + 0.5));\n    \n    // Combine all elements with pow for better contrast\n    float brightness = pow(abs(pattern), 1.5) * 0.6 + 0.4;\n    finalColor *= brightness;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_727.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 baseColor = hsl(0.5 + 0.1 * sin(iTime * 0.1), 0.8, 0.5);\n    float noiseScale = noise(uv * 500.0) * 0.5 + 0.5;\n    float pulse = turbulent(vec3(uv * 20.0, iTime)) * 0.5 + 0.5;\n    \n    vec3 coralColor = hsl2rgb(vec3(\n        0.6 + 0.1 * sin(iTime * 0.1),\n        0.8,\n        0.4 + noiseScale * 0.2\n    ));\n    \n    float lightPulse = sin(iTime) * 0.5 + 0.5;\n    vec3 lighting = vec3(\n        1.0 - length(uv - 0.5),\n        1.0 - length(uv - 0.5),\n        1.0 - length(uv - 0.5)\n    ) * lightPulse;\n    \n    return vec4(coralColor * (pulse + noiseScale) * 0.8 + lighting, 1.0);\n}"
  },
  "data_728.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x);\n    float radius = length(st);\n    \n    // Add rotation over time\n    angle += iTime * 0.5;\n    \n    // Create hexagonal tiling effect\n    float scale = 4.0;\n    vec2 polar = vec2(radius * scale, angle);\n    vec2 tile = floor(polar + 0.5);\n    \n    // Calculate distance from center of nearest hexagon\n    vec2 tileCenter = fract(polar) - 0.5;\n    float dist = length(tileCenter);\n    \n    // Create smooth color transitions using HSL\n    vec3 hslColor = vec3(fract(angle * 0.166 + iTime * 0.1), 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add fading effect based on distance from center\n    float fade = smoothstep(0.4, 0.6, dist);\n    rgbColor *= mix(vec3(1.0), vec3(0.0), fade);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_729.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create rotating sine wave pattern\n    float freq = 8.0;\n    float wave = sin(r * freq + a * 4.0) * 0.5 + 0.5;\n    wave = mix(wave, noise(vec2(uv * 16.0)), 0.3);\n    \n    // Dynamic RGB shifts\n    vec3 color;\n    color.r = sin(a + iTime * 0.7 + 0.0) * 0.5 + 0.5;\n    color.g = sin(a + iTime * 0.5 + 2.0) * 0.5 + 0.5;\n    color.b = sin(a + iTime * 0.3 + 4.0) * 0.5 + 0.5;\n    \n    // Add noise and turbulence\n    float turb = turbulent(vec2(uv * 16.0)) * 0.3;\n    color += vec3(turb);\n    \n    // Create smooth transitions\n    float blend = smoothstep(0.7, 1.0, r);\n    color = mix(color, hsl2rgb(vec3(iTime * 0.1, 1.0, 0.8)), blend);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_73.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Create rotating pattern using time\n    float t = iTime * 0.5;\n    mat2 rot = mat2(cos(t), -sin(t), sin(t), cos(t));\n    vec2 coord = (st - 0.5) * rot;\n    \n    // Add noise and turbulence effects\n    float noise1 = turbulent(coord * 4.0 + t);\n    float noise2 = noise(vec3(coord * 8.0, t));\n    \n    // Create color variations using HSL\n    vec3 color1 = hsl(0.5 + noise1 * 0.2, 0.7, 0.3);\n    vec3 color2 = hsl(0.4 + noise2 * 0.3, 0.6, 0.4);\n    \n    // Combine colors with radial gradient\n    float dist = length(coord) * 1.5;\n    vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, dist));\n    \n    // Add depth effect using distance from center\n    float depth = 1.0 - length(st - 0.5) * 2.0;\n    finalColor *= max(0.0, depth);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_730.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = hsl2rgb(vec3(0.5 + 0.5 * sin(iTime * 0.5), 1.0, 0.5));\n    \n    vec2 st = uv * 8.0;\n    vec2 pos = fract(st - iTime * 0.5) * 2.0 - 1.0;\n    \n    float d1 = length(abs(pos.x) + abs(pos.y)) * 0.7;\n    float d2 = length(abs(pos.x + 0.5) + abs(pos.y + 0.5)) * 0.7;\n    float d3 = length(abs(pos.x - 0.5) + abs(pos.y - 0.5)) * 0.7;\n    \n    float mask = smoothstep(1.0, 0.0, abs(d1 - 0.2)) +\n                 smoothstep(1.0, 0.0, abs(d2 - 0.3)) +\n                 smoothstep(1.0, 0.0, abs(d3 - 0.4));\n    \n    vec2 noisePos = uv * 5.0 + iTime;\n    float n = noise(noisePos) * 0.5 + 0.5;\n    \n    color *= (mask + n * 0.3);\n    color += hsl2rgb(vec3(0.3, 1.0, 0.8)) * turbulent(uv * 4.0 + iTime) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_731.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create base plasma pattern with noise and turbulence\n    vec3 color = hsl(\n        0.5 + turbulent(vec3(r*4.0 + iTime*0.5, a*2.0, 0.0)) * 0.5,\n        1.0,\n        0.5 + sin(iTime*0.5) * 0.5\n    );\n    // Add flowing light trails using noise and time\n    vec3 trail = hsl(\n        0.5 + turbulent(vec3(r*2.0 + iTime, a*4.0, 0.0)) * 0.5,\n        1.0,\n        0.5 + sin(iTime) * 0.5\n    );\n    // Create distance-based blending for core and trails\n    float core = smoothstep(0.8, 1.0, r);\n    float trailBlend = smoothstep(0.9, 1.0, r);\n    // Combine colors with trail effect\n    color = mix(color, trail * 2.0, trailBlend);\n    // Add outer glow effect\n    float glow = smoothstep(0.7, 1.0, r);\n    color *= (1.0 - glow) * 0.5 + 0.5;\n    // Convert HSL to RGB and return as vec4\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_732.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 polar = vec2(length(uv), atan2(uv.y, uv.x));\n    \n    // Create a hexagonal grid pattern\n    float angle = polar.y * 6.0; // Multiply by 6 for hexagon symmetry\n    vec2 q = vec2(cos(angle), sin(angle)) * polar.x;\n    vec2 grid = floor(q + 0.5);\n    \n    // Add pulsating color effect\n    float t = sin(iTime * 0.5 + uv.x * 2.0 + uv.y * 3.0) * 0.5 + 0.5;\n    \n    // Create HSL color based on grid position and time\n    vec3 hslColor = vec3(\n        (grid.x + grid.y) * 0.1 + t,\n        1.0,\n        0.5\n    );\n    \n    // Convert to RGB and add noise for variation\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor += noise(vec3(uv * 10.0, iTime)) * 0.2;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_733.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create layers of rotating shapes\n    float layer1 = turbulent(vec3(r*5.0, a*4.0, iTime*0.5));\n    float layer2 = turbulent(vec3(r*3.0, a*6.0, iTime*0.7));\n    \n    // Combine layers with different frequencies\n    float pattern = mix(layer1, layer2, 0.5);\n    \n    // Add color transformation based on angle and time\n    vec3 baseColor = hsl(a * 0.5 + iTime, 0.8, 0.6);\n    vec3 dynamicColor = hsv2rgb(vec3((a * 0.7 + iTime) * 2.0, 1.0, 1.0));\n    \n    // Combine colors and pattern\n    vec3 finalColor = mix(baseColor, dynamicColor, abs(pattern * 0.5 + 0.5));\n    \n    // Add brightness variation\n    finalColor *= pow(r, 2.0) * 0.8 + 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_734.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Normalize UV coordinates to -1.0 to 1.0 range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add some animation using time\n    float time = iTime * 0.5;\n    \n    // Create orbiting points with expanding rings\n    vec3 color = vec3(0.0);\n    int numPoints = 4;\n    \n    for(int i = 0; i < numPoints; i++) {\n        // Calculate point position with orbital motion\n        float angle = time + float(i) * PI * 2.0 / float(numPoints);\n        vec2 pointPos = vec2(sin(angle), cos(angle)) * 0.5;\n        \n        // Add some noise to the orbit radius\n        float noiseOffset = noise(vec3(pointPos.x, pointPos.y, time)) * 0.1;\n        pointPos *= 1.0 + noiseOffset;\n        \n        // Calculate distance from current fragment to orbiting point\n        vec2 diff = st - pointPos;\n        float dist = length(diff);\n        \n        // Create expanding rings effect\n        float ring = mod(dist - time, 0.5) * 2.0;\n        ring = abs(ring - 1.0);\n        \n        // Add color with HSL to RGB conversion\n        vec3 hslColor = vec3(float(i)/float(numPoints), 1.0, 0.5 + ring*0.5);\n        vec3 rgbColor = hsl2rgb(hslColor);\n        \n        // Combine colors from multiple points\n        color += rgbColor * (1.0 - ring) * 0.4;\n    }\n    \n    // Add some global noise for extra texture\n    float globalNoise = turbulent(vec3(st, time)) * 0.2;\n    color *= 1.0 + globalNoise;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_735.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate and scale UV coordinates\n    float t = iTime * 0.5;\n    vec2 st = uv * 10.0;\n    \n    // Create rotating sine wave patterns\n    float angle = t + sin(t * 0.7);\n    vec2 rotatedUV = vec2(\n        cos(angle) * st.x - sin(angle) * st.y,\n        sin(angle) * st.x + cos(angle) * st.y\n    );\n    \n    // Layered sine waves with different frequencies\n    float wave1 = sin(rotatedUV.x * 0.5 + t) * 0.5 + 0.5;\n    float wave2 = sin(rotatedUV.y * 0.7 - t * 0.3) * 0.4 + 0.4;\n    \n    // Combine waves and add turbulence\n    float combined = (wave1 + wave2) * 0.8;\n    combined += turbulent(vec2(st.x * 0.5, st.y * 0.5)) * 0.2;\n    \n    // Dynamic color palette using HSL\n    vec3 color = hsl(\n        mod(t * 0.1 + combined * 2.0, 1.0),\n        0.7,\n        0.6\n    );\n    \n    // Add noise to colors for extra detail\n    color += vec3(noise(vec3(st.x * 0.5, st.y * 0.5, t)) * 0.2);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_736.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV coordinates to center of screen\n    vec2 st = uv - 0.5;\n    \n    // Rotate coordinates based on time\n    float angle = sin(iTime * 0.5 + PI) * 0.5 + 0.5;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedSt = rotMatrix * st;\n    // Create sine wave patterns with time-based frequency\n    float freq = 4.0 + sin(iTime) * 2.0;\n    float wave1 = sin(rotatedSt.x * freq + iTime) * 0.5;\n    float wave2 = sin(rotatedSt.y * freq + iTime * 0.7) * 0.5;\n    // Combine waves and add turbulence\n    float combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(vec3(rotatedSt, iTime)) * 0.3;\n    // Create RGB cycling effect using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        mod(iTime * 0.5 + rotatedSt.x * 2.0 + rotatedSt.y * 3.0, PI),\n        1.0,\n        0.5 + combined * 0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Add noise for extra detail\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float noiseValue = noise(noiseUV);\n    \n    return vec4(rgbColor * (1.0 + noiseValue * 0.3), 1.0);\n}"
  },
  "data_737.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV to center at (0,0)\n    vec2 st = uv - 0.5;\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create color wheel effect with pulsing\n    vec3 colorHSL = vec3(\n        (theta / (2.0 * PI)) * 0.5 + 0.5 + sin(iTime)*0.2, // Hue with pulsing\n        0.7 + turbulent(vec3(r, iTime*0.1, 0.0))*0.3, // Saturation with turbulence\n        0.5 + r * 0.4 - sin(iTime*0.5)*0.2 // Lightness with radial gradient and pulse\n    );\n    \n    // Convert to RGB and add turbulence effect\n    vec3 color = hsl2rgb(colorHSL) + turbulent(vec3(r, theta, iTime)) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_738.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and add time-based movement\n    vec2 st = fract(uv * 5.0 + sin(iTime) * 0.5);\n    \n    // Create a noise pattern with turbulence\n    float n1 = turbulent(st * 3.0 + sin(iTime * 0.7));\n    float n2 = turbulent(st * 6.0 + cos(iTime * 0.5));\n    \n    // Combine noise patterns\n    float pattern = (n1 * 0.5 + 0.5) * (n2 * 0.3 + 0.7);\n    \n    // Convert to HSL color with dynamic hue\n    vec3 hslColor = vec3(\n        fract(pattern * 0.4 + iTime * 0.1),\n        0.8, // Saturation\n        0.5  // Lightness\n    );\n    \n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_739.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base terrain height using noise\n    float z = turbulent(vec3(uv * 5.0 + iTime, 0.0)) * 0.5 + 0.5;\n    \n    // Add detail with multiple noise layers\n    z += noise(vec3(uv * 2.0 + iTime * 0.5, 0.0)) * 0.3;\n    z += noise(vec3(uv * 1.0 + iTime * 0.2, 0.0)) * 0.2;\n    \n    // Create color transitions based on height\n    vec3 color = hsl(\n        (z * 0.6 + 0.4) * 360.0,   // Hue varies with height\n        1.0 - abs(z - 0.5) * 2.0,  // Saturation peaks in middle heights\n        z * 0.7 + 0.3             // Lightness darkens at lower elevations\n    );\n    \n    // Add time-based color variation\n    color = hsl2rgb(vec3(\n        color.r,\n        color.g,\n        color.b + sin(iTime * 0.1) * 0.2\n    ));\n    \n    // Add lighting effect\n    vec2 dudx = dFdx(uv);\n    vec2 dudy = dFdy(uv);\n    \n    vec3 normal = vec3(\n        dFdx(z),\n        dFdy(z),\n        1.0\n    );\n    normal = normalize(normal);\n    \n    vec3 lightDir = vec3(sin(iTime * 0.1), cos(iTime * 0.1), 1.0);\n    lightDir = normalize(lightDir);\n    \n    float lighting = dot(normal, lightDir) * 0.5 + 0.5;\n    \n    // Combine color with lighting and add fog\n    vec3 finalColor = color * lighting;\n    \n    // Add distance-based fog\n    float depth = length(uv * 2.0 - 1.0);\n    float fogFactor = exp(-depth * 0.7);\n    \n    finalColor = mix(finalColor, vec3(0.15, 0.25, 0.4), 1.0 - fogFactor);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_74.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 st = uv - 0.5;\n    \n    // Create a circular pattern\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add some rotation and turbulence\n    float rot = r * 10.0 + iTime * 2.0;\n    vec2 flow = vec2(sin(theta + rot), cos(theta + rot)) * (1.0 - r) * 0.5;\n    \n    // Use noise to create a more organic pattern\n    vec2 noisePos = st * 4.0 + flow * 2.0;\n    float n = noise(noisePos);\n    \n    // Create color based on HSL values\n    vec3 color = hsl2rgb(vec3(\n        (r * 180.0 + iTime) / 360.0,   // Hue\n        0.7 + n * 0.3,                 // Saturation\n        0.5 + sin(iTime) * 0.2         // Lightness\n    ));\n    \n    // Add some highlights\n    color += cos(theta - iTime) * 0.1;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_740.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Time-based modulation\n    float t = iTime * 0.5;\n    \n    // Scale UV coordinates for wave pattern\n    vec2 st = uv * 8.0 + t; // Increase frequency with scale\n    \n    // Create interweaving sine waves in x and y directions\n    float waveX = sin(st.x + t) * 0.5 + 0.5;\n    float waveY = sin(st.y + t + PI/2.0) * 0.5 + 0.5; // Offset phase for interweaving\n    \n    // Combine waves and add turbulence\n    vec2 noiseUV = uv * 4.0 + vec2(t, 0.0); // Scale for noise pattern\n    float turbulence = turbulent(noiseUV);\n    \n    // Mix wave patterns with turbulence\n    float pattern = (waveX + waveY) * 0.5 + turbulence * 0.3;\n    \n    // Create pulsing effect by modulating the pattern\n    float pulse = sin(t * 2.0) * 0.5 + 0.5; // Pulsation between 0 and 1\n    pattern = mix(pattern, pattern * 2.0, pulse); // Increase contrast with pulse\n    \n    // Convert to color using HSL to RGB conversion\n    vec3 hslColor = vec3(t * 0.2, 1.0, pattern); // Hue varies with time\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_741.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create moving sine wave patterns\n    float wave1 = sin(uv.x * 8.0 + iTime * 2.0);\n    float wave2 = sin(uv.y * 6.0 + iTime * 3.0);\n    \n    // Combine waves with noise texture\n    vec2 noiseUV = uv * 10.0;\n    float noiseValue = noise(noiseUV) * 0.5 + 0.5;\n    \n    // Mix waves and noise\n    float pattern = (wave1 + wave2) * noiseValue;\n    \n    // Add turbulence for more dynamic movement\n    vec3 turbPos = vec3(uv.x, uv.y, iTime);\n    float turb = turbulent(turbPos * 0.5);\n    \n    // Combine everything with color transformation\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1 + pattern * 0.5, 1.0),\n        0.7,\n        0.6\n    )) * (1.0 + turb * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_742.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create grid pattern using floor and fract functions\n    vec2 st = floor(uv * 50.0);\n    \n    // Calculate distance from center of each square\n    vec2 offset = uv - (floor(uv * 50.0) + 0.5)/50.0;\n    float dist = length(offset * 50.0);\n    \n    // Create pulsating animation using sine wave\n    float pulse = sin(iTime + dist * 2.0) * 2.0;\n    \n    // Calculate color transition from red to blue\n    vec3 hslColor = vec3(0.5 + pulse*0.5, 1.0, 0.5);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add turbulence for extra visual interest\n    float turb = turbulent(uv * 10.0) * 0.1;\n    rgbColor += turb;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_743.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base pattern with sine waves\n    vec3 pattern = vec3(\n        sin(uv.x * 4.0 + iTime) * 0.5 + 0.5,\n        sin(uv.y * 4.0 + iTime * 0.7) * 0.5 + 0.5,\n        sin(uv.x * 2.0 + uv.y * 2.0 + iTime * 0.3) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence for more complex patterns\n    vec2 st = uv * 10.0;\n    float n = noise(st);\n    pattern += vec3(n * 0.3, n * 0.4, n * 0.5);\n    \n    // Create time-based color shifts using HSL\n    vec3 hslColor = vec3(\n        sin(iTime * 0.2) * 0.5 + 0.5,\n        0.7,\n        0.8\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine patterns and colors with turbulence\n    float t = turbulent(vec2(uv.x * 4.0, uv.y * 4.0 + iTime));\n    pattern *= mix(rgbColor, vec3(1.0), t * 0.5 + 0.5);\n    \n    // Add brightness variation\n    pattern += sin(iTime) * 0.2;\n    \n    return vec4(pattern, 1.0);\n}"
  },
  "data_744.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    vec2 pos = uv - 0.5;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x);\n    \n    // Create swirling pattern with time-based animation\n    theta += iTime * 10.0;\n    r *= 0.7; // Scale down for multiple layers\n    \n    // Add noise and turbulence to create complex patterns\n    vec3 noiseColor = hsl2rgb(vec3(\n        (theta + turbulent(pos * 5.0)) * 0.1,\n        0.8 + turbulent(pos * 4.0) * 0.2,\n        0.5 + turbulent(pos * 3.0) * 0.2\n    ));\n    \n    // Create fractal layers with iterative pattern\n    for(int i = 0; i < 5; i++) {\n        r = abs(r * 1.7 - 1.0);\n        theta += iTime * float(i+1);\n        \n        color += noiseColor * \n            (sin(theta + iTime) * 0.5 + 0.5) *\n            (turbulent(vec3(pos * float(i+1), iTime)) * 0.5 + 0.5);\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_745.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV to center coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add rotation based on time\n    float angle = sin(iTime * 0.5 + 3.1415926) * 0.5 + 3.1415926;\n    vec2 rotated = vec2(\n        st.x * cos(angle) - st.y * sin(angle),\n        st.x * sin(angle) + st.y * cos(angle)\n    );\n    \n    // Add turbulence\n    float turb = turbulent(rotated * 0.5 + iTime);\n    \n    // Create sine wave patterns with different frequencies and phases\n    float wave1 = sin(rotated.x * 4.0 + iTime) * 0.5;\n    float wave2 = sin(rotated.y * 6.0 - iTime) * 0.3;\n    float wave3 = sin((rotated.x + rotated.y) * 8.0 + iTime * 2.0) * 0.2;\n    \n    // Combine waves and add turbulence\n    float pattern = (wave1 + wave2 + wave3) * 0.5 + turb * 0.3;\n    \n    // Convert to color using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(pattern * 0.5 + iTime) * 360.0,\n        0.7,\n        0.5\n    ));\n    \n    // Mix with dark background\n    vec3 finalColor = mix(vec3(0.1), color, pattern * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_746.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create moving stripes using sine waves\n    float speed = 0.5;\n    float frequency = 10.0;\n    \n    // Calculate base stripe pattern with time offset\n    float stripe = sin(uv.x * frequency + iTime * speed);\n    \n    // Add pulsating effect by varying the color mix over time\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Create color transition from red to blue using HSL\n    vec3 color1 = hsl(0.0, 1.0, 0.5);\n    vec3 color2 = hsl(240.0, 1.0, 0.5);\n    vec3 mixedColor = mix(color1, color2, abs(stripe) * 0.5 + pulse * 0.5);\n    \n    // Add noise for extra texture\n    vec2 noiseUV = uv * 100.0;\n    float noiseValue = noise(noiseUV) * 0.3;\n    mixedColor += noiseValue;\n    \n    // Create pulsating effect by varying stripe intensity\n    float intensity = sin(iTime + uv.y * pi) * 0.5 + 0.5;\n    vec3 finalColor = mixedColor * (intensity + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_747.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Calculate distance from center\n    float dist = length(uv - 0.5);\n    \n    // Create orbiting rings using noise and time\n    for(float i = 0.0; i < 5.0; i++) {\n        float ringRadius = 0.1 + i * 0.15;\n        float speed = 0.3 + i * 0.2;\n        \n        // Add some randomness to radius using noise\n        ringRadius += noise(vec2(iTime * 0.5, i)) * 0.05;\n        \n        // Calculate position of the ring center with orbiting motion\n        vec2 ringCenter = vec2(\n            sin(iTime * speed) * 0.3,\n            cos(iTime * speed) * 0.3\n        );\n        \n        // Calculate distance to current ring\n        float d = length(uv - (0.5 + ringCenter));\n        \n        // Create gradient fill using HSL colors\n        vec3 color = hsl2rgb(vec3(\n            fract(d * 4.0) * 360.0,\n            1.0,\n            0.5 + noise(vec2(iTime, d)) * 0.2\n        ));\n        \n        // Add specular highlights using dot product with light direction\n        vec2 lightDir = vec2(sin(iTime), cos(iTime));\n        float spec = pow(max(dot(uv - 0.5, lightDir), 0.0), 16.0);\n        color += vec3(spec * 0.5);\n        \n        // Add to final color based on proximity\n        float contribution = smoothstep(ringRadius + 0.02, ringRadius - 0.02, d);\n        finalColor += color * (1.0 - contribution);\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_748.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create dynamic color shifts using time\n    float time = iTime * 0.5;\n    \n    // Convert to polar coordinates for radial patterns\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st) * 0.75;\n    \n    // Create layered noise patterns with turbulence\n    float n1 = turbulent(vec3(r + time, theta * 4.0, 0.0));\n    float n2 = turbulent(vec3(r * 2.0 - time, theta * 2.0, 0.0)) * 0.5;\n    float n3 = noise(vec3(r * 4.0 + time, theta * 8.0, 0.0)) * 0.25;\n    \n    // Combine noise layers\n    float pattern = (n1 + n2 + n3) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(\n        theta * 0.5 + time,\n        0.7 + sin(r * 4.0 + time) * 0.3,\n        pattern * 0.6 + 0.2\n    );\n    \n    // Add depth and movement to the colors\n    color *= sin(pattern * pi + time) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_749.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of triangles using polar coordinates\n    vec2 st = uv * 10.0; // Scale up for more cells\n    vec2 ipos = floor(st); // Integer position\n    \n    // Add time-based animation\n    float t = iTime * 0.5;\n    \n    // Calculate angle and radius for polar transformation\n    vec2 pos = st - ipos;\n    float angle = atan(pos.y, pos.x) + t;\n    float radius = length(pos);\n    \n    // Create tessellation pattern using sine waves\n    float pattern = sin(angle * 3.0 + t) * cos(radius * 10.0);\n    \n    // Add noise and turbulence for shimmer effect\n    vec2 noisePos = ipos + 0.5;\n    float noiseVal = noise(noisePos * 0.1 + t);\n    pattern += turbulent(vec3(pos, t)) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(angle * 0.2 + t) * 360.0,\n        0.7 + sin(t * 2.0) * 0.3,\n        0.5 + pattern * 0.5\n    );\n    \n    // Convert to RGB and apply turbulence for shimmer\n    vec3 color = hsl2rgb(hslColor);\n    color *= 1.0 + turbulent(vec3(uv, t)) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_75.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates from UV\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create a mask using noise and turbulence\n    float mask = turbulent(vec3(uv * 5.0 + iTime, 0.0)) * 0.5 + 0.5;\n    mask *= turbulent(vec2(uv * 10.0 + iTime)) * 0.5 + 0.5;\n    // Create a swirling pattern\n    float swirl = sin(theta * 4.0 + iTime) * cos(r * 8.0 - iTime);\n    \n    // Combine mask and swirl to create the river hole effect\n    vec3 color = hsl2rgb(vec3(\n        (theta / (2.0 * PI) + 0.5) * 120.0,   // Hue varies with angle\n        0.7 + 0.3 * mask,                     // Saturation\n        0.8 - 0.5 * swirl                      // Lightness\n    ));\n    return vec4(color, 1.0);\n}"
  },
  "data_750.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale coordinates\n    vec2 centeredUV = (uv - 0.5) * 4.0;\n    \n    // Convert to polar coordinates\n    float angle = atan2(centeredUV.y, centeredUV.x);\n    float r = length(centeredUV);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create square pattern using sine and cosine\n    float sa = abs(sin(angle));\n    float ca = abs(cos(angle));\n    float d = max(sa, ca);\n    \n    // Create gradient effect\n    float gradient = pow(abs(d - 0.5) * 2.0, 2.0);\n    \n    // Generate color based on time\n    float hue = mod(iTime * 0.3, 1.0);\n    vec3 hslColor = hsl2rgb(vec3(hue, 1.0, 0.5));\n    vec3 darkColor = hsl2rgb(vec3(hue + 0.5, 1.0, 0.2));\n    \n    // Mix colors and add noise\n    vec3 finalColor = mix(darkColor, hslColor, gradient);\n    float noiseValue = turbulent(centeredUV * 0.5 + iTime) * 0.2;\n    finalColor += noiseValue;\n    \n    return vec4(finalColor * 1.2, 1.0);\n}"
  },
  "data_751.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create rotating pattern by adding time to angle\n    theta += iTime * 0.5;\n    \n    // Generate geometric patterns using sine and cosine functions\n    float pattern = sin(theta * 4.0) * cos(r * 10.0 + theta) +\n                   abs(sin(theta * 2.0)) * cos(r * 20.0);\n    \n    // Create color variations based on position\n    vec3 baseColor = hsl2rgb(vec3(\n        (theta / (2.0 * PI) + r * 0.5) * 360.0,   // Hue varies with angle and radius\n        0.7 + turbulent(vec3(uv * 10.0, iTime)) * 0.3,  // Saturation with turbulence\n        0.5));                                       // Lightness\n    \n    // Add noise texture for extra detail\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float noiseValue = noise(noiseUV);\n    \n    // Combine patterns and colors\n    vec3 finalColor = mix(baseColor, \n                         hsl2rgb(vec3(\n                             (theta / PI) * 180.0,\n                             0.5,\n                             0.7)),\n                         abs(pattern * 0.5 + noiseValue * 0.5));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_752.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color with time-based pulsing\n    vec3 baseColor = hsl(0.6 + 0.1*sin(iTime*0.5), 0.8, 0.1);\n    \n    // Create dynamic noise pattern with turbulence\n    float t = iTime * 0.2;\n    vec2 st = uv * 4.0; // Scale coordinates for more detail\n    \n    // Mix different noise layers\n    float n1 = turbulent(st + t) * 0.5;\n    float n2 = turbulent(st*2.0 + t*3.0) * 0.3;\n    float n3 = noise(vec3(st, t)) * 0.2;\n    \n    // Combine noise layers with color\n    vec3 color = baseColor * (n1 + n2 + n3);\n    \n    // Add pulsating effect\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    color *= pulse;\n    \n    // Create movement using sine waves\n    vec2 movement = vec2(sin(iTime*0.3)*0.1, cos(iTime*0.4)*0.1);\n    color += hsl(0.2 + movement.x, 0.7, 0.5) * 0.3;\n    \n    // Add glow effect\n    float glow = length(uv - 0.5) * 2.0;\n    glow = 1.0 - smoothstep(0.8, 1.2, glow);\n    color += vec3(0.7, 0.4, 0.9) * glow * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_753.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation\n    theta += iTime * 0.5;\n    // Create hexagonal grid pattern using polar coordinates\n    vec2 tile = vec2(r, theta);\n    tile.y *= 6.0; // Multiply angle by 6 for hexagonal symmetry\n    tile.y = mod(tile.y + PI, 2.0 * PI) - PI;\n    \n    // Use turbulence to create pulsating effect\n    float t = turbulent(vec3(tile.x, tile.y, iTime)) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(theta * 0.1 + iTime * 0.2, 1.0), // Hue variation over time and space\n        0.7 + t * 0.3,                       // Saturation\n        0.5 + sin(iTime) * 0.4               // Lightness with pulsation\n    );\n    \n    // Convert HSL to RGB and apply smooth gradient\n    vec3 rgbColor = hsl2rgb(hslColor);\n    float glow = smoothstep(0.8, 1.0, t); // Create smooth glow effect\n    \n    // Combine colors and glow for final output\n    return vec4(rgbColor * (1.0 - glow) + vec3(0.9, 0.9, 1.0) * glow, 1.0);\n}"
  },
  "data_754.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Generate swarm points using noise and time\n    for (int i = 0; i < 20; i++) {\n        float t = iTime * 0.5 + float(i);\n        vec2 pos = sin(vec2(t, t * 1.3)) * 0.4 + uv;\n        \n        // Add noise to position\n        pos += noise(vec3(pos, iTime)) * 0.1;\n        \n        // Calculate distance from current point\n        vec2 d = uv - pos;\n        float dist = length(d);\n        \n        // Create color based on distance and time\n        vec3 c = hsl(dist * 5.0 + iTime, 0.8, 0.6);\n        \n        // Add glow effect\n        if (dist < 0.1) {\n            color += c * (1.0 - dist * 10.0);\n        }\n    }\n    \n    // Add background turbulence\n    vec2 bgPos = uv * 5.0 + iTime;\n    float bgNoise = turbulent(bgPos);\n    color += hsl(1.0, 0.3, 0.1) * bgNoise * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_755.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 8.0 + iTime;\n    \n    // Add noise and turbulence for dynamic movement\n    vec2 noiseOffset = vec2(noise(st.xy + iTime), noise(st.xy - iTime)) * 0.5;\n    st += noiseOffset;\n    \n    // Create rotating geometric patterns\n    float angle = atan2(uv.y - 0.5, uv.x - 0.5);\n    vec2 line1 = vec2(sin(angle + iTime) * 0.5, cos(angle + iTime) * 0.5);\n    vec2 line2 = vec2(sin(angle - iTime) * 0.5, cos(angle - iTime) * 0.5);\n    \n    // Mix patterns with noise\n    float pattern = turbulent(st.xy) * 0.5 + 0.5;\n    pattern += length(line1 + line2) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(angle * 0.5 + iTime * 0.1, 0.7, 0.6);\n    color = hsl2rgb(color);\n    \n    // Add glowing effect\n    float glow = exp(-length(uv - 0.5));\n    color *= (pattern + glow) * 1.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_756.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base pulsation\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Layered sine waves with noise modulation\n    vec2 st = uv * 10.0;\n    float wave1 = sin(st.x * 3.0 + iTime) * 0.5;\n    float wave2 = sin(st.y * 4.0 + iTime * 0.7) * 0.4;\n    float noiseLayer = turbulent(vec2(uv * 8.0)) * 0.3;\n    \n    // Combine waves and add turbulence\n    float pattern = (wave1 + wave2 + noiseLayer) * 0.5 + 0.5;\n    \n    // Color transformation with pulsation\n    vec3 color = hsl2rgb(vec3(\n        mod(pulse * 360.0, 360.0),\n        0.7,\n        pattern * 0.8 + 0.2\n    ));\n    \n    // Add brightness variation\n    float brightness = sin(iTime) * 0.5 + 0.5;\n    color *= (pattern + noiseLayer * 0.3) * (1.0 + brightness);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_757.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to range [-1, 1]\n    vec2 pos = uv * 2.0 - 1.0;\n    \n    // Calculate distance from center and angle\n    float radius = length(pos);\n    float angle = atan2(pos.y, pos.x);\n    \n    // Add time-based pulsation\n    radius += sin(iTime * 0.5 + angle) * 0.3;\n    \n    // Create color variations using HSL\n    vec3 baseColor = hsl(0.7, 1.0, 0.5); // Purple base color\n    \n    // Add turbulence and noise for dynamic effect\n    float turb = turbulent(vec2(radius * 4.0 + iTime, angle));\n    \n    // Create gradient effect based on radius\n    vec3 color = mix(\n        baseColor,\n        hsl(0.1, 1.0, 0.5), // Orange secondary color\n        smoothstep(0.0, 1.0, radius * 0.8)\n    );\n    \n    // Add pulsating glow effect\n    float glow = sin(iTime + radius * 2.0) * 0.3;\n    color += vec3(glow);\n    \n    // Convert to RGB and return\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_758.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based variation\n    float t = iTime * 0.5;\n    \n    // Add sine wave movement to UV coordinates\n    vec2 st = uv * 10.0 + vec2(sin(t * 3.0), cos(t * 2.0));\n    \n    // Use turbulence for flowing pattern\n    float noise1 = turbulent(st);\n    float noise2 = turbulent(st * 0.5 + t);\n    \n    // Create color gradient using HSL conversion\n    vec3 baseColor = hsl2rgb(vec3(0.5 + noise1 * 0.5, 0.7, 0.8));\n    vec3 mixColor = hsl2rgb(vec3(0.3 + noise2 * 0.5, 0.6, 0.7));\n    \n    // Combine colors with noise\n    vec3 finalColor = mix(baseColor, mixColor, abs(noise(st * 0.1)));\n    \n    // Add glow effect using low-frequency turbulence\n    float glow = turbulent(vec2(uv.x * 5.0 + t, uv.y * 5.0 - t)) * 0.5 + 0.5;\n    finalColor *= glow * 2.0;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_759.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create multiple overlapping sine wave layers with varying frequencies\n    vec3 waves = vec3(\n        sin(uv.x * 10.0 + time) * 0.5 + 0.5,\n        sin(uv.y * 20.0 - time * 2.0) * 0.5 + 0.5,\n        sin((uv.x + uv.y) * 30.0 + time * 3.0) * 0.5 + 0.5\n    );\n    \n    // Add noise and turbulence to create more dynamic patterns\n    vec2 noiseScale = vec2(100.0, 100.0);\n    float noiseValue = noise(uv * noiseScale + time);\n    \n    // Create cyclic color shifts using HSL conversion\n    vec3 color = hsl(\n        mod(time * 0.5, 1.0),   // Hue cycling over time\n        0.7,                    // Saturation\n        waves.x * 0.5 + 0.5     // Value modulation by wave pattern\n    );\n    \n    // Combine everything with noise and turbulence\n    vec3 finalColor = hsl2rgb(color) * (noiseValue * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_76.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base pattern\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add noise layers with different scales\n    float n1 = noise(st * 200.0 + iTime);\n    float n2 = turbulent(st * 50.0 + iTime * 0.5);\n    float n3 = noise(vec3(st * 100.0, iTime));\n    \n    // Create a rotating pattern\n    float angle = atan2(st.y, st.x) + iTime;\n    vec2 rotated = vec2(\n        cos(angle) * st.x - sin(angle) * st.y,\n        sin(angle) * st.x + cos(angle) * st.y\n    );\n    \n    // Combine noise layers with color transformations\n    vec3 color1 = hsl2rgb(vec3(0.5 + n1 * 0.5, 0.7, 0.8));\n    vec3 color2 = hsv2rgb(vec3(0.3 + n2 * 0.3, 0.6, 0.7));\n    \n    // Mix colors based on noise values\n    vec3 finalColor = mix(color1, color2, rotated.x * 0.5 + 0.5);\n    \n    // Add pulsing effect using time\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    finalColor *= 1.0 + n3 * pulse * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_760.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale UV coordinates\n    vec2 st = (uv - 0.5) * 16.0;\n    \n    // Convert to polar coordinates\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create rotating sine wave pattern\n    float wave = sin(theta) * cos(r + iTime) * 4.0 +\n                 sin(2.0*theta + iTime) * r * 0.5 +\n                 cos(3.0*theta - iTime) * r * 0.3;\n    \n    // Add turbulence for more dynamic effect\n    wave += turbulent(vec2(theta, r)) * 0.4;\n    \n    // Convert to color using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(theta + iTime * 0.5, 2.0 * PI) / (2.0 * PI),\n        0.7,\n        0.6\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_761.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n    // Create hexagonal lattice pattern\n    a += iTime * 0.5; // Rotate over time\n    float sa = sin(a + iTime * 0.2);\n    float ca = cos(a + iTime * 0.2);\n    \n    // Hexagon tiling\n    vec2 q = vec2(\n        (pos.x * ca - pos.y * sa) / r,\n        (pos.x * sa + pos.y * ca) / r\n    );\n    \n    // Create hexagonal grid pattern\n    float d = length(q * 0.5 + fract(q * 0.5 + 0.5));\n    \n    // Animate color and radius\n    float time = iTime * 0.2;\n    vec3 color1 = hsl(0.6, 0.8, 0.4); // Deep indigo\n    vec3 color2 = hsl(0.1, 0.8, 0.6); // Fiery orange\n    \n    // Mix colors based on position and time\n    float mixAmount = (sin(r * 5.0 + time) + 1.0) * 0.5;\n    vec3 color = mix(color1, color2, mixAmount);\n    \n    // Add turbulence effect\n    float noiseVal = turbulent(vec3(q.x * 5.0, q.y * 5.0, iTime));\n    d += noiseVal * 0.2;\n    \n    // Create final pattern\n    float pattern = smoothstep(0.4, 0.6, abs(d - 0.5)) * 2.0 - 1.0;\n    pattern = sin(pattern * pi + time) * 0.5 + 0.5;\n    \n    // Output color with alpha\n    return vec4(color * pattern, 1.0);\n}"
  },
  "data_762.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing motion with time-based offsets\n    vec2 st = uv + 0.5 * sin(iTime + uv.x * 10.0);\n    \n    // Add rotating pattern\n    float angle = iTime * 0.2 + length(uv - 0.5) * 2.0;\n    vec2 rotated = vec2(\n        (st.x - 0.5) * cos(angle) - (st.y - 0.5) * sin(angle),\n        (st.x - 0.5) * sin(angle) + (st.y - 0.5) * cos(angle)\n    ) + 0.5;\n    \n    // Create scaling effect\n    float scale = 1.0 + 0.3 * sin(iTime * 0.8 + length(uv));\n    rotated *= scale;\n    \n    // Generate noise-based pattern with turbulence\n    vec2 noisePos = rotated * 4.0 + iTime;\n    float n = turbulent(noisePos);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        mod(iTime * 0.1, 1.0),   // Hue shifting over time\n        0.7 + 0.3 * sin(n * pi), // Saturation variation\n        0.5 + 0.5 * n           // Lightness modulation\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine patterns and colors for final effect\n    float shape = length(rotated - 0.5) * 1.4;\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(0.8, 0.9, 1.0),\n        smoothstep(0.7, 1.0, shape)\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_763.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing noise pattern with time component\n    vec3 p = vec3(uv * 5.0 + iTime, iTime * 0.5);\n    float n1 = turbulent(p);\n    float n2 = turbulent(p * 0.5 + 100.0);\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(0.6 + sin(iTime*0.5)*0.2, 0.8, 0.4);\n    vec3 color2 = hsl(0.9 + cos(iTime*0.5)*0.2, 0.8, 0.4);\n    \n    // Combine noise layers with different frequencies\n    float totalNoise = n1 * 0.5 + n2 * 0.3;\n    \n    // Create flowing pattern by mixing colors based on noise\n    vec3 finalColor = mix(color1, color2, totalNoise);\n    \n    // Add metallic sheen effect using sine wave modulation\n    float highlight = sin(uv.x * 10.0 + iTime) * sin(uv.y * 10.0 + iTime*0.5);\n    finalColor += vec3(0.8) * highlight;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_764.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 0.5 + 0.5;\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv) * 0.75;\n    \n    // Add time-based rotation\n    angle += iTime * 0.1;\n    \n    // Create a base pattern using noise and turbulence\n    vec2 noiseSt = st + vec2(sin(iTime)*0.3, cos(iTime)*0.3);\n    float baseNoise = noise(noiseSt * 5.0);\n    float turbulentVal = turbulent(st * 4.0 + iTime);\n    \n    // Create color variations using HSL\n    vec3 color1 = hsl2rgb(vec3(angle*0.1, 0.7, 0.8));\n    vec3 color2 = hsl2rgb(vec3((angle + iTime)*0.15, 0.6, 0.7));\n    \n    // Combine patterns with turbulence\n    float pattern = mix(baseNoise, turbulentVal, 0.5);\n    pattern += sin(radius * 8.0 + iTime) * 0.2;\n    \n    // Create layered effect\n    vec3 finalColor = mix(color1, color2, pattern);\n    finalColor *= 1.0 - abs(pattern - 0.5) * 2.0;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_765.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 5.0; // Scale up for better coverage\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create hexagonal pattern using sine waves\n    float hexPattern = sin(6.0 * (theta + iTime)) * 0.5 + 0.5;\n    \n    // Calculate distance from center with rotation\n    float distFromCenter = abs(r - hexPattern) * 2.0;\n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        sin(iTime * 0.5 + theta) * 0.5 + 0.5, // Hue\n        0.7, // Saturation\n        0.5 + sin(r * 10.0 + iTime) * 0.2 // Lightness\n    );\n    // Convert HSL to RGB and mix with noise\n    vec3 color = hsl2rgb(hslColor);\n    float noiseValue = noise(vec2(uv.x * 10.0, uv.y * 10.0)) * 0.2;\n    \n    // Combine elements for final output\n    return vec4(color * (1.0 - distFromCenter) + noiseValue, 1.0);\n}"
  },
  "data_766.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Generate random positions for fireflies using noise\n    vec3 pos1 = vec3(noise(vec2(time, 0.0)) * 0.8 + 0.1,\n                     noise(vec2(0.0, time)) * 0.8 + 0.1,\n                     0.0);\n    \n    // Create a swarm of fireflies with varying colors and glow\n    vec3 color = hsl(0.5, 0.7, 0.4); // Base green color for fireflies\n    \n    // Add dynamic glow effect using turbulence\n    float glow = turbulent(vec2(uv * 10.0 + time)) * 0.5 + 0.5;\n    \n    // Create ambient light with noise texture\n    vec3 ambient = hsl(0.6, 0.4, 0.2) * 0.2; // Dark blue ambient\n    \n    // Add multiple fireflies with different parameters\n    for (int i = 0; i < 20; i++) {\n        float speed = noise(vec2(float(i), time)) * 0.5 + 0.5;\n        vec3 pos = vec3(uv.x + sin(time + float(i)) * 0.1,\n                        uv.y + cos(time + float(i)) * 0.1,\n                        0.0);\n        \n        // Calculate distance from firefly\n        float dist = length(pos.xy - uv);\n        \n        // Create glowing effect with color transitions\n        vec3 glowColor = mix(color, hsl(0.6, 0.8, 0.5), dist * 0.2);\n        glowColor *= smoothstep(1.0, 0.0, dist * 4.0);\n        \n        // Add dynamic movement and interaction with ambient light\n        float alpha = turbulent(vec2(pos.x * 10.0 + time, pos.y * 10.0 + time)) * 0.5 + 0.5;\n        glowColor *= alpha;\n        \n        // Combine firefly glow with ambient background\n        ambient += glowColor * 0.3;\n    }\n    \n    return vec4(ambient, glow);\n}"
  },
  "data_768.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates and scale them up\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Calculate distance from center\n    float d = length(st);\n    \n    // Add time-based pulsation\n    d += sin(iTime * 0.5 + d * 10.0) * 0.2;\n    \n    // Create base color using HSL conversion\n    vec3 color = hsl(\n        sin(iTime * 0.2 + d * 5.0) * 0.5 + 0.5,   // Hue\n        0.7,                                       // Saturation\n        sin(d * 4.0 - iTime * 0.5) * 0.5 + 0.5    // Lightness\n    );\n    \n    // Add noise texture for more detail\n    float n = noise(vec3(st * 10.0, iTime));\n    color = mix(color, hsl2rgb(vec3(\n        sin(iTime * 0.3 + d * 3.0) * 0.5 + 0.5,\n        0.8,\n        0.6\n    )), n * 0.4);\n    \n    // Add secondary layer for depth\n    float d2 = length(st * 0.5);\n    color += hsl(\n        sin(iTime * 0.1 + d2 * 8.0) * 0.5 + 0.5,\n        0.6,\n        sin(d2 * 4.0 - iTime * 0.3) * 0.5 + 0.5\n    ) * (1.0 - n) * 0.3;\n    \n    // Vary brightness based on distance and time\n    float brightness = sin(iTime * 0.2 + d * 4.0) * 0.5 + 0.5;\n    color *= brightness * (1.0 - d * 0.1);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_769.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create multiple sine waves with varying frequencies and phases\n    float d = 0.0;\n    \n    // Wave 1\n    d += sin(uv.x * 5.0 + iTime * 2.0 + 3.14159) * 0.5;\n    // Wave 2\n    d += sin(uv.y * 7.0 - iTime * 1.5 + 1.5708) * 0.4;\n    // Wave 3\n    d += sin((uv.x + uv.y) * 4.0 + iTime * 3.0 + 2.3562) * 0.3;\n    // Wave 4\n    d += sin((uv.x - uv.y) * 6.0 - iTime * 2.5 + 0.7854) * 0.2;\n    \n    // Scale and offset the interference pattern\n    d = (d * 0.5 + 0.5);\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(iTime * 0.1, 0.7, d * 0.6 + 0.4);\n    \n    // Add some noise to create texture\n    float noiseVal = turbulent(uv * 8.0 + iTime) * 0.2;\n    color += noiseVal;\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_77.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV coordinates to center\n    vec2 st = uv - 0.5;\n    \n    // Rotate coordinates based on time\n    float angle = iTime * 0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotated = rot * st;\n    \n    // Convert to polar coordinates\n    float r = length(rotated);\n    float theta = atan2(rotated.y, rotated.x) + iTime * 0.5;\n    \n    // Add noise and turbulence\n    float n = noise(vec2(uv.x * 4.0 + iTime, uv.y * 4.0));\n    float t = turbulent(vec2(theta, r * 0.1));\n    \n    // Create color from HSL values\n    vec3 hslColor = vec3(\n        theta * 0.15,\n        sin(r * 0.5 + iTime) * 0.5 + 0.5,\n        t * 0.5 + 0.5\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_770.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Waterfall base color and noise\n    float time = iTime * 0.5;\n    \n    // Upper part - waterfall\n    vec3 waterColor = hsl(\n        180.0 + sin(time * 0.5) * 30.0,\n        0.7 + turbulent(vec2(uv.x, time)) * 0.2,\n        0.4 + turbulent(vec2(uv.x*2.0, time*2.0)) * 0.1\n    );\n    \n    // Lower part - abyss and mist\n    vec3 mistColor = hsl(\n        240.0 + cos(time) * 60.0,\n        0.5 + turbulent(vec2(uv.x*0.5, time*0.5)) * 0.2,\n        0.1 + turbulent(vec2(uv.x*3.0, time*3.0)) * 0.1\n    );\n    \n    // Combine colors with smooth transition\n    float blend = smoothstep(0.4, 0.6, uv.y);\n    vec3 color = mix(waterColor, mistColor, blend);\n    \n    // Add droplet trails and shimmer effect\n    if (uv.y < 0.5) {\n        // Droplet trail emission\n        float dist = length(uv - vec2(0.5, 0.4));\n        float glow = exp(-dist * 8.0) * (1.0 + sin(time * 3.0 + dist * 10.0)) * 0.5;\n        \n        // Add turbulence-based shimmer\n        float shimm = turbulent(vec2(uv.x*10.0, time*2.0)) * 0.2;\n        color += vec3(0.2, 0.4, 0.8) * (glow + shimm);\n    }\n    \n    // Add mist particles\n    if (uv.y > 0.5) {\n        float mistDensity = turbulent(vec2(uv.x*5.0, uv.y*5.0)) * 0.3;\n        color += vec3(0.1, 0.2, 0.4) * mistDensity;\n    }\n    \n    // Add light interaction and depth\n    float light = sin(time * 0.7 + uv.x * pi) * 0.5 + 0.5;\n    color *= light;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_771.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a center point\n    vec2 center = vec2(0.5, 0.5);\n    \n    // Calculate distance from center with noise\n    float dist = length(uv - center);\n    dist += noise(uv * 10.0 + iTime) * 0.2;\n    \n    // Create color components based on position and time\n    vec3 color = hsl(\n        (dist * 4.0 + iTime * 2.0) * pi,   // Hue variation\n        0.7 + turbulent(vec3(uv, iTime)) * 0.3, // Saturation with noise\n        0.5 + sin(iTime) * 0.5             // Lightness variation\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_772.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create a noise field that changes over time\n    float noiseValue = noise(vec3(uv * 5.0 + vec2(0.0, iTime * 0.2), 0.0));\n    \n    // Use HSL color space for easier color manipulation\n    vec3 baseColor = hsl(angle * 0.1 + iTime, 0.7, 0.6);\n    \n    // Create geometric pattern using sine waves\n    float pattern = sin(angle * 5.0 + iTime) * radius;\n    pattern += sin(angle * 3.0 - iTime) * radius * 0.5;\n    \n    // Mix colors based on noise and pattern\n    vec3 finalColor = mix(baseColor, hsl(radius * 0.2 + iTime, 0.8, 0.5), abs(pattern * 0.5));\n    finalColor *= 1.0 + noiseValue * 0.5;\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(uv * 2.0, iTime * 0.1)) * 0.5 + 0.5;\n    finalColor = mix(finalColor, vec3(1.0), turb * 0.3);\n    \n    return vec4(finalColor * 1.2, 1.0);\n}"
  },
  "data_773.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-based frequency component\n    float timeFreq = iTime * 0.5;\n    \n    // Scale UV coordinates for more waves\n    vec2 pos = uv * 8.0;\n    \n    // Create wave pattern using sine functions with different frequencies\n    float waveX = sin(pos.x + timeFreq) * 0.5;\n    float waveY = sin(pos.y + timeFreq * 0.7) * 0.5;\n    \n    // Combine waves and add noise for complexity\n    float combinedWave = (waveX + waveY) * 0.5;\n    combinedWave += noise(vec2(uv * 4.0 + iTime)) * 0.3;\n    \n    // Convert to HSL color space with time-based hue shift\n    vec3 hslColor = vec3(\n        fract(combinedWave + iTime),  // Hue shifts over time\n        0.7,                          // Saturation\n        0.5                           // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_774.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale coordinates\n    vec2 st = (uv - 0.5) * 4.0;\n    \n    // Convert to polar coordinates\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create swirling pattern by adding time-dependent rotation\n    theta += iTime * 3.0;\n    \n    // Add concentric circles with varying radius\n    float circle = sin(theta + (1.0 / r) * 5.0) * 0.5 + 0.5;\n    \n    // Add turbulence for organic movement\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float turb = turbulent(noiseUV);\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        (theta / (2.0 * PI) + 0.5) * 0.6,  // Hue varies with angle\n        0.7 + turb * 0.3,                  // Saturation modulation\n        0.5 + sin(r * 4.0 - iTime) * 0.2   // Lightness variation\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_775.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    float time = iTime * 0.5;\n    \n    // Generate multiple layers of triangles with different scales and phases\n    for(float layer = 1.0; layer <= 4.0; layer++) {\n        float scale = pow(2.0, layer) * 10.0;\n        vec2 st = uv * scale + time * 5.0;\n        \n        // Create triangular pattern using sine waves\n        float tri = sin(st.x * 0.5 + time) + cos(st.y * 0.5 + time);\n        tri += turbulent(vec3(uv * scale, time)) * 0.5;\n        \n        // Add pulsating effect\n        float pulse = sin(time + layer * 2.0) * 0.5 + 0.5;\n        tri *= pulse;\n        \n        // Create glowing edges\n        float glow = smoothstep(0.0, 1.0, abs(tri));\n        glow = pow(glow, 2.0);\n        \n        // Add color transformation\n        vec3 color = hsl2rgb(vec3(180.0 + time * 50.0, 1.0, 0.5)) * glow;\n        color += hsl2rgb(vec3(0.0, 1.0, 0.3)) * (1.0 - glow);\n        \n        // Add dynamic shadows\n        vec2 lightPos = vec2(sin(time) * 0.5 + 0.5, cos(time * 0.7) * 0.5 + 0.5);\n        float shadow = smoothstep(0.8, 1.0, length(uv - lightPos));\n        color *= 1.0 - shadow * 0.5;\n        \n        finalColor += color * 0.3;\n    }\n    \n    // Add overall pulsation\n    float globalPulse = sin(time * 2.0) * 0.3 + 0.7;\n    finalColor *= globalPulse;\n    \n    return vec4(pow(finalColor, vec3(1.5)), 1.0);\n}"
  },
  "data_776.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base frequency for the sine wave pattern\n    float freq = 4.0;\n    \n    // Add time-based animation\n    float time = iTime * 0.5;\n    \n    // Combine x and y coordinates with time to create movement\n    vec2 st = uv * freq + vec2(time, -time);\n    \n    // Use sine function to create undulating pattern\n    float base = sin(st.x) * 0.5 + 0.5;\n    \n    // Add noise and turbulence for dynamic effect\n    float noiseVal = noise(vec3(uv * 0.5 + time, time)) * 0.2;\n    float turbulentVal = turbulent(vec2(uv * 0.5 + time)) * 0.3;\n    \n    // Combine base pattern with noise and turbulence\n    float v = (base + sin(st.y) * 0.5 + noiseVal + turbulentVal);\n    \n    // Normalize value to 0-1 range for color conversion\n    v = (v + 1.0) * 0.5;\n    \n    // Convert to HSL and shift hue over time\n    vec3 hslColor = vec3(v, 0.8, 0.7);\n    hslColor.r += time * 0.5; // Shift hue\n    \n    // Convert HSL to RGB\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_777.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates from [-1,1] to [0,1]\n    vec2 st = uv * 0.5 + 0.5;\n    \n    // Create rotational symmetry by repeating pattern around center\n    float theta = atan2(uv.y, uv.x);\n    float radius = length(uv) * 0.75; // Scale down the radius\n    \n    // Animate rotation and create kaleidoscopic effect\n    theta += iTime * 0.1;\n    theta *= 8.0; // Create 8-fold symmetry\n    \n    // Convert back to cartesian coordinates\n    vec2 rotated = vec2(\n        cos(theta) * radius,\n        sin(theta) * radius\n    );\n    \n    // Add turbulence and noise for organic texture\n    float noiseValue = turbulent(rotated + iTime);\n    noiseValue = abs(noiseValue); // Ensure positive values\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        noiseValue * 0.6 + 0.2, // Hue\n        0.7 + noiseValue * 0.3, // Saturation\n        0.5 + sin(iTime) * 0.4 // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_778.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 col = hsl(0., 0., .1); // Dark background\n    \n    // Add noise layers with time-based animation\n    float n1 = noise(uv * 5. + iTime * .5);\n    float n2 = noise(uv * 2. + iTime * 1.5) * .5;\n    \n    // Create turbulent motion\n    vec3 turb = vec3(turbulent(uv * 4. + iTime));\n    \n    // Add color variations with time\n    float hue = sin(iTime * .5) * .5 + .5;\n    col = hsl(hue, .8, .6);\n    \n    // Mix in geometric patterns\n    vec2 st = uv * 10.;\n    float pattern = abs(sin(st.x + iTime)) + abs(cos(st.y + iTime));\n    \n    // Combine all elements\n    col *= mix(n1, n2, .5) + turb.x;\n    col += pattern * .3;\n    \n    return vec4(col, 1.);\n}"
  },
  "data_779.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation effect\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv);\n    \n    // Add time-based rotation\n    angle += 0.1 * iTime;\n    \n    // Create color swirls using HSL colorspace\n    vec3 baseColor = hsl(\n        radius * 5.0 + iTime * 2.0,   // Hue variation with radius and time\n        0.7 + turbulent(vec3(uv*4.0, iTime)) * 0.3, // Saturation modulation\n        0.6 + sin(angle) * 0.3         // Lightness variation\n    );\n    \n    // Add shimmering effect using noise\n    float shimmer = turbulent(vec3(uv*8.0, iTime*2.0)) * radius;\n    vec3 finalColor = mix(baseColor, hsl(\n        baseColor.r * 180.0 + iTime,\n        0.9,\n        0.5\n    ), abs(shimmer) * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_78.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Polar coordinates\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Add turbulence to both radius and angle\n    float turb = turbulent(vec2(r, a)) * 0.5 + 0.5;\n    turb *= sin(iTime * 0.3 + r * 10.0);\n    \n    // Create color variations using HSL\n    vec3 color1 = hsl(a * 0.1 + iTime * 0.2, 0.8, 0.6);\n    vec3 color2 = hsl(a * 0.15 - iTime * 0.3, 0.7, 0.5);\n    \n    // Combine colors with noise\n    vec3 finalColor = mix(color1, color2, turb);\n    finalColor *= sin(r * 4.0 + iTime) * 0.5 + 0.5;\n    finalColor += noise(st * 0.5 + iTime) * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_780.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Generate multiple orb centers with noise offset\n    for(float i = 0.0; i < 16.0; i++) {\n        for(float j = 0.0; j < 16.0; j++) {\n            vec2 center = vec2(i/16.0, j/16.0) + noise(vec3(i*0.5 + j*0.7 + iTime*0.1)) * 0.1;\n            \n            // Calculate distance from current pixel to orb center\n            float dist = length(uv - center);\n            \n            // Create pulsing radius with time offset\n            float radius = sin(iTime * 0.5 + i*0.2 + j*0.3) * 0.1 + 0.1;\n            \n            // Add color if within orb radius\n            if(dist < radius) {\n                // Dynamic color based on position and time\n                vec3 hslColor = vec3((uv.x + uv.y)*5.0 + iTime*2.0, \n                                   sin(iTime + dist * 10.0) * 0.5 + 0.5,\n                                   cos(dist * 10.0 + iTime * 2.0) * 0.5 + 0.5);\n                \n                // Add turbulence effect for interaction\n                float turb = turbulent(vec3(uv, iTime*0.1)) * 0.5;\n                hslColor.z += turb;\n                \n                finalColor += hsl2rgb(hslColor) * (radius - dist) / radius;\n            }\n        }\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_781.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal grid pattern using sine and cosine functions\n    a *= 6.0; // Multiply angle by 6 for hexagonal symmetry\n    vec2 grid = vec2(sin(a), cos(a)) * 0.5 + 0.5;\n    \n    // Add turbulence to create flowing edges\n    float noiseVal = turbulent(vec3(st.x, st.y, iTime * 0.1));\n    r += noiseVal * 0.2;\n    // Create pulsating color effect using HSL\n    vec3 colorHSL = vec3(\n        mod(iTime * 0.5 + a * 0.1, 1.0), // Hue variation over time and angle\n        0.7,                              // Saturation\n        0.5 + noiseVal * 0.2             // Lightness modulation with noise\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 color = hsl2rgb(colorHSL);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_782.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave patterns\n    float time = iTime * 0.5;\n    \n    // Combine multiple sine waves with different frequencies and amplitudes\n    float wave1 = sin(uv.x * 8.0 + time) * 0.5;\n    float wave2 = cos(uv.y * 4.0 - time) * 0.3;\n    float wave3 = sin((uv.x + uv.y) * 6.0 + time * 2.0) * 0.2;\n    \n    // Combine waves and add noise\n    float combined = wave1 + wave2 + wave3;\n    combined += noise(uv * 4.0 + vec2(time)) * 0.1;\n    \n    // Create pulsating color effect using HSL\n    vec3 colorHSL = vec3(\n        mod(time * 0.5, 1.0),   // Hue that changes over time\n        0.7 + noise(uv * 8.0) * 0.2, // Saturation with some noise variation\n        0.5 + combined * 0.4    // Lightness affected by the wave pattern\n    );\n    \n    // Convert HSL to RGB and add turbulence effect\n    vec3 rgbColor = hsl2rgb(colorHSL);\n    float turb = turbulent(uv * 16.0 + vec2(time)) * 0.5;\n    rgbColor += turb * 0.4;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_783.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a dark gradient background\n    vec3 bg = hsl2rgb(vec3(0.5, 1.0, 0.1));\n    \n    // Add geometric patterns with sine wave movement\n    float time = iTime * 0.2;\n    vec2 st = uv * 4.0 + time;\n    \n    // Create hexagonal pattern\n    vec2 hexCoords = vec2(\n        sin(st.x * 0.5) * cos(st.y * 0.5),\n        cos(st.x * 0.5) * sin(st.y * 0.5)\n    );\n    \n    // Add triangular movement\n    float triangle = sin(st.x + time) * cos(st.y + time);\n    \n    // Combine geometric patterns with noise\n    vec2 noiseCoords = uv * 16.0 + vec2(time, time);\n    float noiseValue = noise(noiseCoords);\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl2rgb(vec3(0.1 + time * 0.1, 0.8, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.4 + time * 0.1, 0.7, 0.6));\n    \n    // Mix patterns and colors\n    float mixValue = abs(sin(time)) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixValue);\n    \n    // Add turbulence effect\n    vec2 turbulentCoords = uv * 8.0 + vec2(time, time);\n    float turbulentValue = turbulent(turbulentCoords) * 0.5 + 0.5;\n    \n    // Combine all elements\n    vec3 result = bg * (1.0 - turbulentValue) + finalColor * turbulentValue;\n    \n    return vec4(result, 1.0);\n}"
  },
  "data_784.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x) + iTime * 0.5;\n    float radius = length(st);\n    \n    // Create rotating geometric pattern using hexagonal symmetry\n    float segments = 6.0; // Hexagon shape\n    float pattern = sin(angle * segments + iTime) * 0.5 + 0.5;\n    pattern *= 1.0 - turbulent(vec2(radius, iTime * 0.1)) * 0.3;\n    \n    // Dynamic color cycling using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1) * 360.0,\n        0.7 + noise(vec2(radius, iTime)) * 0.3,\n        0.5 + pattern * 0.5\n    );\n    \n    // Add noise-textured gradients\n    vec2 noiseScale = vec2(4.0, 4.0);\n    float gradient = noise(st * noiseScale) * 0.5;\n    gradient += noise(st * noiseScale * 2.0 + iTime) * 0.3;\n    \n    // Combine pattern and gradients\n    vec3 finalColor = hsl2rgb(hslColor) * (gradient + pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_785.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Moving sine wave patterns with time-based animation\n    float speed = 0.5;\n    float phase = sin(iTime * speed + 1.0);\n    \n    // RGB color transitions using sine waves with varying amplitudes\n    float rWave = sin(uv.x * 4.0 + iTime * speed) * (0.5 + 0.5 * cos(iTime * 0.5));\n    float gWave = sin(uv.y * 4.0 + iTime * speed + phase) * (0.5 + 0.5 * sin(iTime * 0.7));\n    float bWave = sin((uv.x + uv.y) * 3.0 + iTime * speed - phase) * (0.5 + 0.5 * cos(iTime * 0.9));\n    \n    // Combine waves with noise for more dynamic patterns\n    vec2 noiseUV = uv * 10.0 + vec2(sin(iTime), cos(iTime)) * 4.0;\n    float noiseVal = turbulent(noiseUV);\n    \n    color.r += rWave * (0.5 + 0.5 * noiseVal);\n    color.g += gWave * (0.5 + 0.5 * noiseVal);\n    color.b += bWave * (0.5 + 0.5 * noiseVal);\n    \n    // Add turbulence to create more complex patterns\n    float turbulence = turbulent(uv * 4.0 + vec2(iTime));\n    color *= 1.0 + turbulence * 0.5;\n    \n    // Mix with original position for overlay effect\n    vec3 finalColor = mix(vec3(0.0), color, 0.7 + 0.3 * sin(iTime * 0.4));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_786.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Create rotating sine wave pattern\n    float wave1 = sin(r * 5.0 + theta + iTime * 0.5);\n    float wave2 = sin(4.0 * r + theta + iTime * 0.7);\n    float pattern = (wave1 + wave2) / 2.0;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl(pattern * 0.6 + 0.5, 0.5, 0.5);\n    \n    // Add turbulence for more dynamic effect\n    float noiseValue = turbulent(uv * 10.0 + iTime);\n    pattern += noiseValue * 0.2;\n    \n    // Mix color with noise pattern\n    vec3 finalColor = mix(color, hsl(pattern * 0.6 + 0.5, 0.7, 0.6), 0.4);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_787.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates for orbital movement\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Add time-based rotation and scaling\n    theta += iTime * 0.1;\n    r *= sin(iTime * 0.5 + r) * 0.8 + 0.2;\n    \n    // Create multiple orbiting points with noise\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 5; i++) {\n        float timeOffset = iTime + float(i) * 0.6;\n        \n        // Calculate point position with noise\n        vec2 pointUv = vec2(\n            sin(theta + timeOffset * 0.3 + noise(vec3(r, timeOffset, 0.0))) * 0.5,\n            cos(theta - timeOffset * 0.4 + noise(vec3(r, timeOffset, 1.0))) * 0.5\n        );\n        \n        // Add RGB trails with color cycling\n        float dist = length(uv - pointUv);\n        vec3 hue = vec3(0.0);\n        if (dist < 0.2) {\n            hue = hsv2rgb(vec3(\n                mod(float(i) * 0.4, 1.0),\n                1.0,\n                1.0 - dist * 5.0\n            ));\n        }\n        \n        // Accumulate color with trail effect\n        color += hue * (1.0 - exp(-dist * 20.0));\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_788.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a frequency variable for grid density\n    float freq = 10.0;\n    \n    // Create pulsating factor using time\n    float pulse = sin(iTime * 0.5 + 3.1415926) * 0.5 + 0.5;\n    \n    // Create base grid pattern using sine functions\n    vec2 grid = vec2(\n        abs(sin(uv.x * freq - iTime)),\n        abs(sin(uv.y * freq + iTime))\n    );\n    \n    // Combine grid lines with pulsating factor\n    float gridFactor = (grid.x + grid.y) * 0.5 * pulse;\n    \n    // Add noise for dynamic effect\n    vec2 noiseUV = uv * 100.0 + iTime;\n    float noiseValue = noise(noiseUV);\n    gridFactor += noiseValue * 0.3;\n    \n    // Create color using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        mod(iTime * 0.5, 1.0),  // Hue cycling over time\n        0.7,                    // Saturation\n        gridFactor               // Lightness controlled by grid factor\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_789.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float a = atan2(uv.y - 0.5, uv.x - 0.5);\n    float r = length(uv - 0.5);\n    \n    // Create rotating pattern using sine functions\n    float time = iTime * 0.5;\n    a += time; // Rotate pattern over time\n    \n    // Add noise and turbulence for texture\n    vec2 st = uv * 10.0 + time;\n    float noiseVal = noise(st);\n    \n    // Create hexagonal grid pattern\n    float angleStep = pi / 3.0;\n    float grid = 0.0;\n    for(float i = 0.0; i < 6.0; i++) {\n        float angle = a + i * angleStep;\n        grid += sin(angle) * 0.5 + 0.5;\n    }\n    \n    // Pulsating color transitions\n    vec3 color1 = hsl2rgb(vec3(0.2 + sin(time * 2.0), 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.6 + cos(time * 3.0), 1.0, 0.5));\n    \n    // Combine patterns and colors\n    float blend = smoothstep(0.0, 1.0, grid);\n    vec3 finalColor = mix(color1, color2, blend);\n    \n    // Add noise texture\n    finalColor *= noiseVal * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_79.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate based on time and position\n    float t = iTime * 0.5;\n    \n    // Create a base noise pattern with some movement\n    vec3 noise1 = vec3(noise(uv + vec2(t, t)), \n                       noise(uv + vec2(-t, t)),\n                       noise(uv + vec2(t, -t)));\n                       \n    // Add turbulence for more dynamic movement\n    float turb = turbulent(uv * 5.0 + vec2(sin(t), cos(t))) * 0.5 + 0.5;\n    \n    // Create a color transition effect using HSL\n    vec3 color1 = hsl2rgb(vec3(0.5 + sin(t) * 0.5, \n                               0.8,\n                               0.6));\n                               \n    // Add another layer of noise for detail\n    float detail = noise(uv * 10.0 + vec2(sin(t * 0.7), cos(t * 0.3))) * 0.5 + 0.5;\n    \n    // Combine elements with some blending\n    vec3 finalColor = mix(color1, \n                         hsl2rgb(vec3(0.3 + sin(uv.x * pi + t) * 0.5,\n                                      0.7,\n                                      0.5)),\n                         turb);\n                         \n    // Add some radial movement and contrast\n    float radius = length(uv - vec2(0.5, 0.5)) * 2.0;\n    float angle = atan2(uv.y - 0.5, uv.x - 0.5) + t;\n    \n    return vec4(finalColor * (sin(radius * 10.0 + t) * 0.5 + 0.5), 1.0);\n}"
  },
  "data_790.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    float angle = atan2(uv.y, uv.x);\n    angle += iTime * 10.0; // Rotate over time\n    \n    // Create square pattern using trigonometric functions\n    float r = length(uv) * 0.75;\n    float x = abs(cos(angle)) * r;\n    float y = abs(sin(angle)) * r;\n    float square = (x + y) / 2.0;\n    \n    // Generate smooth color transitions using HSL colors\n    vec3 color = hsl(mod(iTime * 0.5 + square * 2.0, 1.0), 0.7, 0.5);\n    \n    return vec4(color, 0.8);\n}"
  },
  "data_791.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create a grid pattern with dynamic movement\n    vec2 grid = mod(uv * 10.0 + sin(time) * 3.0, 1.0);\n    \n    // Add sine wave distortion to the grid\n    vec2 distortedUV = uv + sin(grid * pi) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(uv.x * 5.0 + time, 1.0),\n        0.7,\n        0.6\n    ));\n    \n    // Add noise and turbulence for extra detail\n    float noiseValue = noise(vec3(distortedUV, time)) * 0.2;\n    color += vec3(noiseValue);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_792.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing motion base on time and position\n    vec2 pos = uv * 2.0 - 1.0;\n    float time = iTime * 0.5;\n    \n    // Add noise-based movement\n    vec2 flowPos = pos + vec2(\n        noise(vec3(pos.x*0.5 + time, pos.y*0.5, 0.0)) * 0.2,\n        noise(vec3(pos.x*0.5 - time, pos.y*0.5, 1.0)) * 0.2\n    );\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(\n        fract(time * 0.2 + flowPos.x * 0.5) * 360.0,\n        0.7,\n        0.5\n    );\n    \n    vec3 color2 = hsl(\n        fract(time * 0.3 + flowPos.y * 0.5) * 360.0,\n        0.7,\n        0.6\n    );\n    \n    // Mix colors based on turbulent noise\n    float mixAmount = turbulent(vec3(flowPos*2.0, time)) * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    return vec4(hsl2rgb(finalColor), 1.0);\n}"
  },
  "data_793.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for rotation effect\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x) + iTime; // Add time for rotation\n    float radius = length(st);\n    \n    // Create grid pattern with noise overlay\n    vec3 gridColor;\n    {\n        // Generate cell coordinates\n        vec2 gridUV = floor(uv * 10.0); // Grid size 10x10\n        \n        // Calculate HSL color for each cell based on time\n        float hue = (gridUV.x + gridUV.y) * 0.1 + iTime * 0.5;\n        vec3 hslColor = hsl(hue, 0.7, 0.6);\n        \n        // Add noise pattern to grid cells\n        float cellNoise = noise(vec2(gridUV)) * 0.3;\n        gridColor = hsl2rgb(vec3(hue + cellNoise, 0.8, 0.5));\n    }\n    \n    // Overlay additional noise patterns\n    vec3 noisePattern1 = hsv2rgb(vec3(noise(uv * 4.0 + iTime), 1.0, 1.0)) * 0.4;\n    vec3 noisePattern2 = hsv2rgb(vec3(turbulent(uv * 8.0 + iTime*0.5), 1.0, 1.0)) * 0.3;\n    \n    // Combine grid and noise patterns\n    vec3 finalColor = gridColor + noisePattern1 + noisePattern2;\n    \n    // Add rotation effect to the final color\n    finalColor *= radius < 1.0 ? 1.0 : 0.0; // Keep within unit circle\n    \n    return vec4(fract(finalColor), 1.0);\n}"
  },
  "data_794.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of points\n    vec2 st = uv * 10.0;\n    vec2 ipos = floor(st);\n    \n    // Calculate rotation angle based on time and position\n    float timeRotation = iTime * 0.5;\n    float posRotation = length(ipos) * 0.2;\n    float totalRotation = timeRotation + posRotation;\n    \n    // Get sine and cosine of the rotation angle\n    vec2 rot = vec2(cos(totalRotation), sin(totalRotation));\n    \n    // Calculate distance from center with rotation applied\n    vec2 offset = st - ipos - 0.5;\n    vec2 rotatedOffset = vec2(offset.x * rot.x - offset.y * rot.y,\n                              offset.x * rot.y + offset.y * rot.x);\n    \n    // Create square pattern using distance field\n    float d = length(rotatedOffset) / max(abs(rotatedOffset.x), abs(rotatedOffset.y));\n    \n    // Generate dynamic color based on position and time\n    vec3 hslColor = vec3(0.5 + 0.5 * sin(iTime + ipos.x + ipos.y),\n                         0.7,\n                         0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise to create variations\n    float noiseValue = noise(vec3(ipos, iTime)) * 0.5;\n    rgbColor *= 1.0 + noiseValue;\n    \n    // Mix colors based on distance from center\n    vec3 finalColor = mix(vec3(0.0), rgbColor, smoothstep(0.0, 1.0, d));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_795.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base frequency components\n    float timeFreq = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Calculate color channels with phase shifts\n    vec3 color = vec3(\n        sin(uv.x * 8.0 + timeFreq * 2.0) * 0.5 + 0.5 +\n        turbulent(vec3(uv, iTime)) * 0.1,\n        \n        sin(uv.y * 6.0 + timeFreq * 3.0 + 2.0) * 0.5 + 0.5 +\n        turbulent(vec3(uv, iTime + 1.0)) * 0.1,\n        \n        sin((uv.x + uv.y) * 4.0 + timeFreq * 4.0 + 4.0) * 0.5 + 0.5 +\n        turbulent(vec3(uv, iTime + 2.0)) * 0.2\n    );\n    \n    // Add noise and scale for better effect\n    color += vec3(\n        noise(vec2(uv.x * 16.0, iTime)),\n        noise(vec2(uv.y * 16.0, iTime + 1.0)),\n        noise(vec2((uv.x + uv.y) * 16.0, iTime + 2.0))\n    ) * 0.3;\n    \n    // Modulate and combine colors\n    color = mod(color * 1.5, 1.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_796.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Create rotating hexagon pattern using polar coordinates\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    float r = length(st);\n    \n    // Hexagonal tiling pattern\n    float sawtooth = mod(theta * 6.0, PI * 2.0);\n    sawtooth = sin(sawtooth) / 4.0 + 1.0;\n    sawtooth = min(sawtooth, 1.0);\n    \n    // Distance from hexagon center\n    float dist = r - sawtooth;\n    float hex = step(0.3, dist);\n    \n    // Pulsating color based on time\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.5, 1.0),   // Hue\n        0.7,                     // Saturation\n        0.5 + sin(iTime) * 0.4   // Lightness pulsation\n    ));\n    \n    // Add noise overlay\n    vec2 noiseScale = st * 8.0;\n    float noiseVal = noise(noiseScale) * 0.3;\n    color += noiseVal;\n    \n    return vec4(hex * color, 1.0);\n}"
  },
  "data_797.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv.xy * 0.5 + 0.5;\n    \n    // Create rotating pattern using polar coordinates\n    float time = iTime * 0.5;\n    vec2 pos = st - 0.5;\n    float angle = atan(pos.y, pos.x) + time;\n    float dist = length(pos);\n    \n    // Create geometric shapes with rotation\n    float square = abs(st.x) + abs(st.y);\n    float circle = st.x*st.x + st.y*st.y;\n    float shape = mix(circle, square, sin(time * 0.5) * 0.5 + 0.5);\n    \n    // Add noise texture\n    vec2 noiseScale = st * 400.0;\n    float n1 = noise(noiseScale);\n    float n2 = noise(noiseScale * 0.5);\n    float noisePattern = (n1 + n2) * 0.5;\n    \n    // Create color gradient\n    vec3 color1 = hsl2rgb(vec3(0.5, 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.1, 1.0, 0.6));\n    vec3 finalColor = mix(color1, color2, sin(angle + time) * 0.5 + 0.5);\n    \n    // Combine shapes and noise\n    float alpha = shape * (1.0 - noisePattern * 0.5);\n    return vec4(finalColor, alpha);\n}"
  },
  "data_798.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    vec3 color = vec3(0.0);\n    \n    // Create rotating pattern\n    float angle = time * 0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    uv = rot * uv;\n    \n    // Generate multiple lines with noise offset\n    const int numLines = 8;\n    for (int i = 0; i < numLines; i++) {\n        float theta = float(i) * pi * 2.0 / float(numLines);\n        vec2 dir = vec2(cos(theta), sin(theta));\n        \n        // Add noise to line position\n        float noiseOffset = noise(vec3(uv + time, time)) * 0.5;\n        vec2 linePos = uv + dir * noiseOffset;\n        \n        // Calculate distance from point to line\n        float dist = length(linePos - uv);\n        dist = smoothstep(0.1, 0.0, abs(dist));\n        \n        // Add pulsing color variation\n        vec3 hslColor = vec3((time + theta) * 2.0, 0.8, 0.5);\n        vec3 rgbColor = hsl2rgb(hslColor);\n        \n        // Combine distance and color\n        color += dist * rgbColor;\n    }\n    \n    // Add noise-based glow effect\n    float glow = turbulent(uv * 4.0 + time) * 0.5 + 0.5;\n    color *= glow;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_799.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv);\n    \n    // Create orbiting motion using time\n    angle += iTime * 0.5;\n    \n    // Add noise for light trail effect\n    vec2 pos = uv + noise(vec3(angle, radius, iTime)) * 0.1;\n    float trail = turbulent(vec2(pos.x * 10.0, pos.y * 10.0));\n    \n    // Create vibrant color transitions\n    vec3 baseColor = hsl(iTime * 0.5 + angle * 0.2, 0.7, 0.6);\n    vec3 trailColor = mix(baseColor, hsl(angle * 0.8 + iTime * 0.3, 0.9, 0.7), 0.3);\n    \n    // Combine colors and trails\n    vec3 finalColor = baseColor * (1.0 - trail) + trailColor * trail;\n    \n    // Add distance-based fading\n    float distFade = smoothstep(0.8, 1.2, radius);\n    finalColor *= distFade;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_8.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Create a warping effect using time-based transformations\n    float timeFactor = iTime * 0.5;\n    st.x += sin(timeFactor + st.y) * 0.3;\n    st.y += cos(timeFactor - st.x) * 0.3;\n    \n    // Add turbulence for dynamic distortion\n    float t = turbulent(st * 10.0);\n    \n    // Get noise value from texture\n    vec2 noiseUV = (st * 5.0 + iTime) * 0.1;\n    float n = noise(noiseUV);\n    \n    // Create color variations using HSL\n    vec3 color = hsl2rgb(vec3(\n        sin(timeFactor) * 0.5 + 0.5,\n        cos(n * PI) * 0.5 + 0.5,\n        0.8\n    ));\n    \n    // Combine effects with original position\n    return vec4(color, 1.0) * (vec4(1.0) + t * 0.2);\n}"
  },
  "data_80.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Offset coordinates based on time for rotation effect\n    vec2 offset = vec2(sin(iTime * 0.5), cos(iTime * 0.5));\n    vec2 st = uv + offset;\n    \n    // Create a color wheel pattern using polar coordinates\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Convert to HSL and add some noise variation\n    vec3 hslColor = vec3(angle * 0.15 + sin(iTime * 0.3), \n                         0.7 + turbulent(vec3(st * 20.0, iTime)) * 0.3,\n                         0.5 + cos(radius * 8.0 + iTime) * 0.5);\n    \n    // Convert HSL to RGB and add turbulence effect\n    vec3 color = hsl2rgb(hslColor);\n    color *= 0.7 + turbulent(st * 10.0) * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_800.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using noise and time\n    vec3 baseColor = hsl(\n        noise(uv * 0.5 + iTime) * 0.5 + 0.5,\n        noise(uv * 0.7 - iTime * 0.1) * 0.5 + 0.5,\n        0.6\n    );\n    \n    // Add turbulence to create movement in the background\n    baseColor *= turbulent(uv * 2.0 + iTime);\n    \n    // Create rotating sine wave patterns\n    float angle = atan2(uv.y - 0.5, uv.x - 0.5) + iTime;\n    float distance = length(uv - 0.5);\n    \n    // Multiple frequency waves for interference effect\n    float wave1 = sin(angle * 4.0 + iTime * 2.0) * cos(distance * 8.0);\n    float wave2 = sin(angle * 6.0 + iTime * 3.0) * cos(distance * 12.0);\n    \n    // Combine waves and create overlay effect\n    float interference = (wave1 + wave2) * 0.5;\n    vec3 waveColor = hsl(\n        0.5,\n        1.0,\n        0.5 + abs(interference) * 0.5\n    );\n    \n    // Overlay waves on base color with varying strength\n    float waveStrength = (turbulent(uv * 4.0 + iTime * 2.0) + 1.0) * 0.5;\n    vec3 finalColor = mix(baseColor, waveColor, waveStrength);\n    \n    return vec4(hsl2rgb(finalColor), 1.0);\n}"
  },
  "data_801.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create orbiting pattern with time-based rotation\n    theta += iTime * 0.5;\n    \n    // Add noise to create dynamic movement\n    vec3 noisePos = vec3(r * cos(theta), r * sin(theta), iTime * 0.2);\n    float turbulence = turbulent(noisePos * 0.5);\n    \n    // Create spectral color effect\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + theta / (6.0 * pi)) * 360.0, \n        0.7 + 0.3 * sin(iTime * 0.5 + r), \n        0.5 + 0.5 * cos(r * 2.0 + iTime)\n    );\n    \n    // Convert to RGB and add light decay\n    vec3 rgbColor = hsl2rgb(hslColor);\n    float lightDecay = 1.0 / (r + 1.0);\n    \n    // Combine effects\n    vec3 finalColor = rgbColor * (sin(r * 4.0 - iTime) * 0.5 + 0.5) * lightDecay;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_802.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    if (r > 1.0) return vec4(0.0); // Outside the sphere\n    \n    // Calculate angle for swirling effect\n    float theta = atan2(st.y, st.x);\n    \n    // Add time-based movement to the surface\n    float time = iTime * 0.5;\n    float displacement = sin(time + r * 10.0) * cos(theta * 3.0 + time) * 0.1;\n    displacement += turbulent(vec2(r, theta) * 4.0 + time) * 0.05;\n    \n    // Create a pulsing effect\n    float pulse = sin(time * 2.0) * 0.2;\n    r = length(st) + displacement + pulse;\n    \n    // Calculate base color using HSL\n    vec3 hslColor = vec3(theta * 0.15 + time * 0.1, 0.7, 0.6);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add glow effect towards the center\n    float glow = pow(1.0 - r, 4.0) * 1.5;\n    rgbColor += glow * vec3(1.0, 0.8, 0.6);\n    \n    // Apply fog based on distance from center\n    float fog = smoothstep(0.9, 1.0, r);\n    rgbColor *= mix(vec3(1.0), vec3(0.2, 0.3, 0.4), fog);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_803.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV for grid pattern\n    vec2 st = uv * 4.0;\n    \n    // Initialize color\n    vec3 color = vec3(0.0);\n    \n    // Create rotating squares with RGB shifts\n    for(float i = -2.0; i <= 2.0; i++) {\n        for(float j = -2.0; j <= 2.0; j++) {\n            // Offset and rotate coordinates\n            vec2 offset = vec2(i, j);\n            vec2 pos = st + offset;\n            \n            // Add rotation based on time\n            float angle = sin(iTime) * 0.5 + cos(iTime) * 0.5;\n            mat2 rot = mat2(cos(angle), -sin(angle), \n                            sin(angle), cos(angle));\n            vec2 rotatedPos = (pos - 1.0) * rot + 1.0;\n            \n            // Create square pattern\n            vec2 square = fract(rotatedPos);\n            float dist = length(square - 0.5);\n            \n            // Color shift based on position and time\n            vec3 baseColor = vec3(\n                mod(i + j, 3.0) == 0.0 ? 1.0 : 0.0,\n                mod(i + j, 3.0) == 1.0 ? 1.0 : 0.0,\n                mod(i + j, 3.0) == 2.0 ? 1.0 : 0.0\n            );\n            \n            // Add noise texture for depth\n            float noiseValue = noise(vec2(pos.x * 0.5, pos.y * 0.5));\n            baseColor *= 0.8 + noiseValue * 0.2;\n            \n            // Combine colors based on distance from center\n            color += mix(baseColor, vec3(0.0), smoothstep(0.4, 0.6, dist));\n        }\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_804.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center point\n    vec2 center = vec2(0.5, 0.5);\n    \n    // Calculate distance from center\n    float radius = length(uv - center);\n    \n    // Add rotation based on time\n    float angle = iTime * 0.1;\n    vec2 rotatedUV = uv * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    // Create color cycling effect\n    vec3 color = vec3(\n        sin(iTime + radius * 5.0) * 0.5 + 0.5,\n        sin(iTime + 2.0 + radius * 5.0) * 0.5 + 0.5,\n        sin(iTime + 4.0 + radius * 5.0) * 0.5 + 0.5\n    );\n    \n    // Add noise to create variations in circles\n    float noiseValue = turbulent(vec2(radius, iTime)) * 0.1;\n    radius += noiseValue;\n    \n    // Create concentric circles pattern\n    color *= sin(radius * 20.0) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_805.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates and create a grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Find nearby grid points\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Calculate distance to nearby grid points\n    float d1 = length(fpos - vec2(0.5));\n    float d2 = length(fpos - vec2(0.5) + vec2(1.0, 0.0));\n    float d3 = length(fpos - vec2(0.5) + vec2(-1.0, 0.0));\n    \n    // Add turbulence to create dynamic movement\n    float t = iTime * 0.5;\n    float turb = turbulent(vec3(ipos, t)) * 0.5 + 0.5;\n    \n    // Create pulsing light effect using sine functions\n    float pulse = sin(iTime * 2.0) * 0.5 + 0.5;\n    float light = sin(d1 * 8.0 - t) * pulse;\n    \n    // Combine multiple layers for complex pattern\n    vec3 color = hsl(turb * 360.0, 0.7, 0.5);\n    color = mix(vec3(1.0), color, light * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_806.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using HSL to RGB conversion with time-based hue shift\n    vec3 baseColor = hsl2rgb(vec3(sin(iTime * 0.5 + uv.x * 10.0) * 0.5 + 0.5, 0.7, 0.6));\n    \n    // Add noise and turbulence for dynamic movement\n    float noiseValue = noise(uv * 10.0 + vec2(sin(iTime), cos(iTime)));\n    float turbulentValue = turbulent(uv * 20.0 + vec2(cos(iTime * 0.7), sin(iTime * 0.5)));\n    \n    // Create a sine wave pattern that moves over time\n    float wave = sin(uv.x * 10.0 + iTime) * sin(iTime * 0.5);\n    \n    // Combine elements with different weights for the final color\n    vec3 finalColor = mix(baseColor, hsl2rgb(vec3(0.5, 0.8, 0.7)), noiseValue * 0.5 + 0.5);\n    finalColor += wave * 0.4;\n    finalColor *= turbulentValue * 0.6 + 0.4;\n    \n    // Add a subtle gradient effect\n    finalColor *= vec3(1.0, 1.0, 1.0) + uv.y * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_807.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates with time\n    vec2 st = uv * 4.0 + iTime;\n    \n    // Create smooth sine wave patterns\n    float a = sin(st.x) * cos(st.y + iTime);\n    float b = sin(st.y) * cos(st.x - iTime);\n    \n    // Mix frequencies for more complex pattern\n    vec2 mix1 = vec2(sin(2.0*st.x + 3.0*iTime), sin(2.0*st.y + 3.0*iTime));\n    vec2 mix2 = vec2(cos(2.0*st.x - 2.0*iTime), cos(2.0*st.y + 1.0*iTime));\n    \n    // Combine patterns with turbulence\n    float pattern = mix(a, b, turbulent(vec3(mix1, iTime)));\n    \n    // Create RGB color shifts\n    vec3 rgb = vec3(\n        sin(pattern + st.x) * 0.5 + 0.5,\n        sin(pattern + st.y) * 0.5 + 0.5,\n        sin(pattern + mix1.x + mix2.y) * 0.5 + 0.5\n    );\n    \n    // Add time-based color shifts\n    rgb.r += 0.3*sin(iTime*0.5);\n    rgb.g += 0.2*cos(iTime*0.6);\n    rgb.b += 0.4*sin(iTime*0.7);\n    \n    return vec4(clamp(rgb, 0.0, 1.0), 1.0);\n}"
  },
  "data_808.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and scale\n    vec2 st = (uv - 0.5) * 3.0;\n    \n    // Add time-based movement\n    st += sin(float(iTime) + st.yx * 10.0) * 0.2;\n    \n    // Polar coordinates\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    \n    // Create base pattern with turbulence\n    float noise1 = turbulent(st * 4.0 + vec2(float(iTime)*0.5));\n    float noise2 = turbulent(st * 8.0 + vec2(float(iTime)*0.3));\n    \n    // Color calculations\n    vec3 color;\n    color.r = sin(r * 4.0 - float(iTime)) * 0.5 + 0.5;\n    color.g = sin(r * 6.0 - float(iTime)*0.7) * 0.5 + 0.5;\n    color.b = sin(r * 8.0 - float(iTime)*1.2) * 0.5 + 0.5;\n    \n    // Add noise and turbulence\n    color *= hsl2rgb(vec3(\n        (a / PI + 1.0) * 0.5,   // Hue from angle\n        0.7 + noise1 * 0.3,     // Saturation with noise\n        0.8 + noise2 * 0.2      // Lightness with noise\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_809.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime / 4.0; // Slow down animation\n    \n    // Create base sine wave pattern with multiple frequencies\n    vec2 st = uv * 8.0;\n    float s1 = sin(st.x + time) * 0.5;\n    float s2 = sin(st.y + time * 0.7) * 0.3;\n    \n    // Add distance-based ripples\n    float d = length(uv - 0.5);\n    float r = sin(d * 8.0 + time) * 0.2;\n    \n    // Combine patterns and create color transitions\n    float final = s1 + s2 + r;\n    \n    // Create dynamic color shifts using HSL\n    vec3 color = hsl(\n        (final + time) * 0.5 + 0.5, // Hue variation\n        d * 0.7 + 0.3,             // Saturation based on distance\n        sin(time * 0.2) * 0.5 + 0.5 // Lightness oscillation\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_81.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 center = vec2(0.5);\n    float radius = length(uv - center);\n    float angle = atan2(uv.y - center.y, uv.x - center.x);\n    \n    // Add wobble effect using sine and time\n    float wobbleRadius = sin(iTime * 2.0 + radius * 4.0) * 0.3;\n    float wobbleAngle = sin(iTime + angle * 2.0) * 0.5;\n    \n    // Combine original and wobble components\n    float finalRadius = radius + wobbleRadius;\n    float finalAngle = angle + wobbleAngle;\n    \n    // Add noise for extra randomness\n    vec3 noiseParams = vec3(finalRadius, finalAngle, iTime);\n    float noiseValue = noise(noiseParams) * 0.2;\n    finalRadius += noiseValue;\n    \n    // Convert back to cartesian coordinates\n    vec2 newUV = center + vec2(cos(finalAngle), sin(finalAngle)) * finalRadius;\n    \n    // Create color based on position and time\n    vec3 color = hsl(\n        (newUV.x + iTime) * 0.5,\n        0.7,\n        0.5 + turbulent(vec2(newUV)) * 0.2\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_810.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for better noise coverage\n    vec2 st = uv * 10.0;\n    \n    // Create flowing liquid effect using turbulence\n    float flow = turbulent(st + iTime);\n    \n    // Add depth and complexity to the flow\n    flow += turbulent((st * 0.5) + iTime * 0.3) * 0.5;\n    \n    // Create color shifts based on position and time\n    vec3 color1 = hsl2rgb(vec3(0.6, 0.8, 0.7));\n    vec3 color2 = hsl2rgb(vec3(0.4, 0.8, 0.5));\n    vec3 finalColor = mix(color1, color2, flow * 0.5 + 0.5);\n    \n    // Add metallic sheen and highlights\n    float highlight = sin(iTime) * 0.5 + 0.5;\n    finalColor *= (flow * 0.5 + 0.5) * (highlight * 2.0);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_812.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + sin(iTime * 0.5) * 3.0;\n    \n    // Create a flowing pattern using turbulence\n    float flow = turbulent(st * 0.5 + iTime);\n    flow += turbulent(st * 0.7 - iTime * 2.0);\n    \n    // Convert to HSL color space with shifting hue\n    vec3 hslColor = vec3(\n        sin(iTime * 0.1) * 0.5 + 0.5,   // Hue\n        0.8,                             // Saturation\n        abs(flow * 0.5 + 0.5)           // Lightness\n    );\n    \n    // Add light ripples effect\n    float ripple = sin(iTime * 2.0 + length(st)) * 0.1;\n    vec3 color = hsl2rgb(hslColor);\n    color += color * (ripple + 0.1);\n    \n    // Combine with noise for more detail\n    float noiseDetail = noise(vec3(uv * 5.0, iTime));\n    color = mix(color, color * 1.5, noiseDetail * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_813.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate the grid\n    float scale = 10.0 + sin(iTime * 0.5) * 3.0;\n    vec2 st = fract(uv * scale - iTime * 0.2);\n    \n    // Create pulsating effect with turbulence\n    vec2 pos = (st - 0.5) * 2.0;\n    float t = turbulent(pos + vec2(iTime, 0.0)) * 0.5 + 0.5;\n    \n    // Generate two colors per cell for optical illusion\n    vec3 color1 = hsl(st.x * 360.0 + iTime * 100.0, 0.7, 0.5);\n    vec3 color2 = hsl(st.y * 360.0 - iTime * 100.0, 0.7, 0.5);\n    \n    // Blend colors based on position and turbulence\n    float blend = abs(pos.x) + abs(pos.y);\n    vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, blend * t));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_814.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float t = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create hexagonal grid pattern\n    mat2 hexMatrix = mat2(0.5, -sqrt(3.0)/2.0, sqrt(3.0)/2.0, 0.5);\n    vec2 hexCoords = rotatedUv * 10.0;\n    hexCoords = hexMatrix * hexCoords;\n    \n    // Add noise and turbulence\n    float noiseVal = turbulent(hexCoords) * 0.5 + 0.5;\n    float dist = length(hexCoords);\n    \n    // Create pulsating color effect\n    vec3 color = hsl(\n        sin(iTime * 0.2 + hexCoords.x * 0.1) * 0.5 + 0.5,\n        noiseVal * 0.7 + 0.3,\n        0.6 + sin(dist * 4.0 - iTime) * 0.2\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_815.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create layered sine wave patterns with RGB transitions\n    float time = iTime * 0.5;\n    \n    // Layer 1: Red component with low frequency sine waves\n    float layer1 = sin(uv.x * 4.0 + time) + sin(uv.y * 4.0 + time * 2.0);\n    layer1 = (layer1 + 1.0) * 0.5; // Scale to 0-1 range\n    \n    // Layer 2: Green component with medium frequency sine waves\n    float layer2 = sin(uv.x * 5.0 + time * 3.0) + sin(uv.y * 5.0 + time);\n    layer2 = (layer2 + 1.0) * 0.5;\n    \n    // Layer 3: Blue component with high frequency sine waves\n    float layer3 = sin(uv.x * 6.0 + time * 2.0) + sin(uv.y * 6.0 + time * 4.0);\n    layer3 = (layer3 + 1.0) * 0.5;\n    \n    // Combine layers with noise modulation\n    float noiseMod = turbulent(vec2(uv.x * 2.0, uv.y * 2.0) + time) * 0.5 + 0.5;\n    \n    vec3 color = vec3(\n        layer1 * 0.3 + noiseMod * 0.7,\n        layer2 * 0.3 + noiseMod * 0.7,\n        layer3 * 0.3 + noiseMod * 0.7\n    );\n    \n    // Add RGB transitions over time\n    color += vec3(\n        sin(time) * 0.5,\n        sin(time * 1.2) * 0.5,\n        sin(time * 1.4) * 0.5\n    );\n    \n    // Ensure values stay within 0-1 range\n    color = clamp(color, 0.0, 1.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_816.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create two sets of sine waves with different frequencies and phases\n    float wave1 = sin(uv.x * 5.0 + iTime * 2.0) + sin(uv.y * 5.0 + iTime * 3.0);\n    float wave2 = sin((uv.x - uv.y) * 4.0 + iTime * 1.5) + cos((uv.x + uv.y) * 4.0 + iTime * 2.0);\n    // Create a rotating pattern using mouse movement\n    vec2 rotatedUV = uv * 2.0 - 1.0;\n    float angle = atan2(rotatedUV.y, rotatedUV.x);\n    float dist = length(rotatedUV);\n    \n    // Combine the waves with rotation and distance\n    float pattern = sin(angle * 4.0 + iTime) * 0.5 + 0.5;\n    pattern += sin(dist * 10.0 + iTime * 2.0) * 0.3;\n    // Create a color palette using HSL to RGB conversion\n    vec3 color = hsl(pattern * 0.7 + 0.3, 0.8, 0.6);\n    \n    // Mix the two wave patterns for the final effect\n    float mixAmount = sin(iTime) * 0.5 + 0.5;\n    float finalPattern = mix(wave1, wave2, mixAmount);\n    // Add some noise and turbulence to enhance the moire effect\n    vec3 finalColor = hsl(finalPattern * 0.5 + 0.5, 0.8, 0.6);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_817.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create hexagonal grid pattern\n    vec2 grid = floor(vec2(6.0) * (uv + 0.5));\n    vec2 offset = vec2(grid.x * 0.866, grid.y * 1.5);\n    \n    // Calculate distance from center of hexagon\n    vec2 pos = uv * 4.0 - offset;\n    float dist = length(pos) / 3.0;\n    \n    // Add noise and turbulence for dynamic effect\n    vec2 noiseUV = uv + iTime * 0.1;\n    float n = noise(noiseUV);\n    float t = turbulent(noiseUV * 4.0);\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(angle / (pi * 2.0) + iTime * 0.1),\n        0.7,\n        0.5 + 0.5 * sin(iTime)\n    ));\n    \n    // Combine effects and output\n    float mask = smoothstep(0.9, 1.0, dist);\n    return vec4(color * (mask + t * 0.2), 1.0);\n}"
  },
  "data_818.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create flowing pattern with noise and sine waves\n    vec2 st = uv * 10.0 + vec2(time, 0.0);\n    float noiseVal = turbulent(st) * 0.5 + 0.5;\n    \n    // Add sine wave modulation\n    float waveX = sin(uv.x * 8.0 + time * 2.0) * 0.5 + 0.5;\n    float waveY = sin(uv.y * 8.0 + time * 3.0) * 0.5 + 0.5;\n    \n    // Combine noise and waves\n    vec3 colorMix = vec3(\n        noiseVal * waveX,\n        noiseVal * waveY,\n        turbulent(vec2(time, uv.x * 5.0)) * 0.5 + 0.5\n    );\n    \n    // Create dynamic color shifts using HSL\n    float hue = time * 0.1 + length(uv) * 0.3;\n    vec3 hslColor = hsl2rgb(vec3(hue, 0.8, 0.8));\n    \n    // Mix colors and add lighting effect\n    vec3 finalColor = mix(colorMix, hslColor, 0.7);\n    float lightFactor = turbulent(vec2(time * 2.0, uv.y * 5.0)) * 0.5 + 0.5;\n    finalColor *= lightFactor;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_819.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing movement effect\n    vec2 st = uv * 5.0 + vec2(iTime * 0.1, 0.0);\n    \n    // Add undulating pattern\n    float flow = sin(st.x * 0.5 + iTime) * 0.5;\n    st.y += flow;\n    \n    // Generate noise-based ripples\n    float ripple1 = noise(vec2(st.x * 0.5, st.y)) * 0.3;\n    float ripple2 = noise(vec2(st.x * 0.7 + iTime, st.y * 0.6)) * 0.4;\n    \n    // Combine ripples and add turbulence\n    float totalRipple = (ripple1 + ripple2) * turbulent(vec2(st.x * 0.3, st.y * 0.5));\n    \n    // Create color shifts using HSL\n    vec3 baseColor = hsl(0.6 + iTime * 0.1, 0.7, 0.5);\n    vec3 rippleColor = hsl(0.8 + iTime * 0.2, 0.6, 0.4);\n    \n    // Mix colors based on ripples\n    vec3 finalColor = mix(baseColor, rippleColor, totalRipple * 0.5 + 0.5);\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(finalColor), 1.0);\n}"
  },
  "data_82.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Create a pulsing effect with time\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Add some noise and turbulence\n    float noiseVal = turbulent(vec3(uv * 10.0, iTime)) * 0.2;\n    float petal = sin(theta * 6.0 - iTime * 2.0) * (r + noiseVal);\n    \n    // Create color transitions\n    vec3 color = hsl(\n        mod(iTime * 0.1 + theta * 4.0, 1.0),\n        0.7,\n        0.5 + sin(r * 8.0 - iTime) * 0.2\n    );\n    \n    // Combine effects for final output\n    float alpha = smoothstep(0.9, 1.0, r + pulse);\n    return vec4(color, alpha);\n}"
  },
  "data_820.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-based offset for animation\n    float time = iTime * 0.5;\n    \n    // Create a base pattern using sine waves and time\n    vec2 st = uv + vec2(0.0, time);\n    \n    // Add turbulence to create dynamic movement\n    float turb = turbulent(st * 10.0 + vec2(time));\n    \n    // Calculate hue based on position and time\n    float hue = mod((st.y * 5.0) + time, 1.0);\n    \n    // Create a vibrant color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(hue, 0.7, 0.6));\n    \n    // Combine the color with turbulence for dynamic effect\n    color *= 0.5 + turb * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_821.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-based animation component\n    float t = iTime * 0.5;\n    \n    // Generate undulating sine wave patterns with different frequencies and amplitudes\n    float wave1 = sin(uv.x * 8.0 + t) * 0.5;\n    float wave2 = sin(uv.y * 4.0 - t) * 0.3;\n    float wave3 = sin((uv.x + uv.y) * 6.0 + t * 2.0) * 0.2;\n    \n    // Combine waves and add turbulence for more dynamic movement\n    float displacement = wave1 + wave2 + wave3 + turbulent(uv * 4.0 + vec2(t, t)) * 0.1;\n    \n    // Create color transition from warm reds to cool blues using HSL colors\n    vec3 color = hsl(\n        sin(displacement * 2.0 + t) * 0.5 + 0.5,  // Hue: oscillates between red and blue\n        0.7,                                      // Saturation\n        0.5 + displacement * 0.2                  // Lightness modulation\n    );\n    \n    // Convert HSL to RGB for final output\n    vec3 rgbColor = hsl2rgb(color);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_822.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    vec2 pos = uv - 0.5;\n    float dist = length(pos);\n    \n    // Add time-based expansion\n    float radius = 1.0 + sin(iTime * 0.5) * 0.5;\n    dist *= radius;\n    \n    // Create multiple rings using mod and frequency\n    float freq1 = mod(dist * 2.0, 1.0);\n    float freq2 = mod(dist * 4.0, 1.0);\n    float freq3 = mod(dist * 8.0, 1.0);\n    \n    // Add turbulence for organic feel\n    vec2 noisePos = uv * 5.0 + iTime;\n    float turb = turbulent(noisePos) * 0.1;\n    dist += turb;\n    \n    // Create gradient using HSL colors\n    vec3 color = hsl(\n        mod(dist * 10.0 + iTime, 1.0),  // Hue variation over time and distance\n        0.7,                              // Saturation\n        0.5                               // Lightness\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_823.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing patterns with time-based movement\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Add noise and turbulence for natural-looking textures\n    float t1 = turbulent(st);\n    float t2 = turbulent(vec3(uv * 2.0, iTime));\n    \n    // Create color variations using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3(0.5 + t1*0.4, 0.7, 0.6));\n    vec3 color2 = hsl2rgb(vec3(0.3 + t2*0.5, 0.8, 0.5));\n    \n    // Combine colors with noise patterns\n    vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, sin(iTime * 0.5)));\n    \n    // Add dynamic warping effect\n    vec2 warp = vec2(sin(uv.y * 2.0 + iTime), cos(uv.x * 2.0 - iTime)) * 0.3;\n    st += warp;\n    \n    // Finalize with additional noise layers\n    finalColor *= hsl2rgb(vec3(0.1, 0.5, 0.4 + noise(st * 0.5)));\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.0, 1.0, t1));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_824.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying waves with different frequencies\n    float wave1 = sin(uv.x * 8.0 + iTime * 2.0);\n    float wave2 = sin(uv.y * 8.0 + iTime * 3.0 + pi/2.0);\n    \n    // Combine waves and add noise for texture\n    vec2 st = uv;\n    float noiseVal = noise(st * 10.0 + iTime);\n    float pattern = wave1 * 0.5 + wave2 * 0.5 + noiseVal * 0.3;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        mod(iTime * 0.2, 1.0),   // Hue cycling over time\n        0.7,                     // Saturation\n        0.5 + noiseVal * 0.2     // Value with noise modulation\n    );\n    \n    // Convert HSL to RGB and mix with pattern\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(pattern),\n        0.5\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_825.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create three overlapping sine waves with different frequencies and amplitudes\n    float wave1 = sin(uv.x * 8.0 - iTime * 2.0) * 0.5;\n    float wave2 = sin(uv.x * 4.0 + iTime * 3.0) * 0.7;\n    float wave3 = sin(uv.x * 2.0 - iTime * 1.5) * 1.0;\n    \n    // Combine waves and add some turbulence\n    float combined = (wave1 + wave2 + wave3) * 0.5;\n    combined += turbulent(vec2(uv.x, iTime * 0.1)) * 0.2;\n    \n    // Create color transition from cyan to magenta using HSL\n    vec3 colorHSL = vec3(180.0 + sin(iTime) * 60.0, 1.0, 0.5);\n    vec3 finalColor = hsl2rgb(colorHSL) * (combined * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_826.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate UV coordinates over time\n    vec2 st = (uv - 0.5) * 3.0 + iTime;\n    \n    // Create multiple layers of sine waves with different frequencies and phases\n    float wave1 = sin(st.x * 2.0 + iTime) * 0.5;\n    float wave2 = sin(st.y * 3.0 - iTime) * 0.4;\n    float wave3 = sin((st.x + st.y) * 4.0 + iTime * 2.0) * 0.3;\n    \n    // Combine waves and add turbulence\n    float pattern = wave1 + wave2 + wave3;\n    pattern += turbulent(vec3(st, iTime)) * 0.2;\n    \n    // Create shifting hues using HSL color space\n    vec3 color = hsl(\n        fract(iTime * 0.5 + st.x),\n        0.7,\n        0.6 + sin(pattern) * 0.2\n    );\n    \n    // Add noise to create ethereal glow effect\n    float glow = noise(vec3(st, iTime)) * 0.4;\n    color += glow;\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_827.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create a swirling pattern using polar coordinates\n    vec2 polarUV = vec2(r, theta);\n    \n    // Use noise and turbulence to create organic patterns\n    float noise1 = turbulent(polarUV * 5.0 + iTime);\n    float noise2 = noise(vec3(st.x * 5.0, st.y * 5.0, iTime));\n    \n    // Create a pulsating effect using sine wave\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Generate color based on angle and radius\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.15 + iTime * 0.1,   // Hue varies with angle and time\n        0.7 + noise1 * 0.3,           // Saturation with noise variation\n        0.5 + pulse * 0.5            // Value/pulsation effect\n    ));\n    \n    // Add radial light trails using sine pattern\n    float trail = sin(r * 20.0 - iTime) * 0.5 + 0.5;\n    color *= mix(1.0, 3.0, trail);\n    \n    // Combine noise layers for more complexity\n    color += hsv2rgb(vec3(\n        theta * 0.1 + iTime * 0.2,\n        0.6,\n        noise2 * 0.5\n    )) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_828.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating sine wave pattern\n    vec2 st = uv * 10.0 + vec2(sin(time), cos(time)) * 3.0;\n    float wave = sin(st.x * 0.5 + time) * cos(st.y * 0.5 - time);\n    \n    // Add turbulence for dynamic effect\n    vec2 noiseUV = uv * 4.0 + vec2(sin(time*2.0), cos(time*3.0));\n    float turb = turbulent(noiseUV * 0.5 + vec2(1.0)) * 0.5 + 0.5;\n    \n    // Combine wave and turbulence\n    vec3 color = vec3(wave * turb);\n    \n    // Add RGB shifts\n    color.r += sin(time * 2.0) * 0.5;\n    color.g += cos(time * 3.0) * 0.5;\n    color.b += sin(time * 4.0 + PI) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_829.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to range [-1, 1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create dynamic sine wave patterns with time offset\n    float wave1 = sin(st.x * 5.0 + iTime) * 0.5 + 0.5;\n    float wave2 = sin(st.y * 5.0 + iTime + 0.5) * 0.5 + 0.5;\n    \n    // Add noise to create organic variations\n    float noise1 = noise(vec2(st.x, st.y)) * 0.3;\n    float noise2 = noise(vec2(st.y, st.x)) * 0.3;\n    \n    // Combine sine waves and noise with time variation\n    float pattern = (wave1 + wave2) * 0.5 + noise1 + noise2;\n    pattern = sin(pattern * pi + iTime) * 0.5 + 0.5;\n    \n    // Create dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        (st.x + st.y + iTime) * 0.5 + 0.5,  // Hue\n        0.7,                                  // Saturation\n        pattern                               // Lightness\n    );\n    \n    // Convert to RGB and add turbulence effect\n    vec3 color = hsl2rgb(hslColor);\n    color *= sin(turbulent(vec3(st.x * 2.0, st.y * 2.0, iTime)) * pi + iTime) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_83.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating pattern by transforming UV coordinates\n    vec2 st = uv * 3.0 + iTime;\n    st += sin(st.yx * 1.5 + iTime) * 0.5;\n    \n    // Apply multiple folds to create mirrored patterns\n    st = abs(fract(st) - 0.5) * 2.0;\n    st = abs(fract(st * 2.0) - 0.5) * 2.0;\n    \n    // Add turbulence for dynamic noise effect\n    float t = turbulent(vec3(st, iTime * 0.1));\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        mod(length(st) + iTime * 0.5, 1.0),\n        0.7,\n        0.6 + t * 0.2\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine effects with smooth transitions\n    float blend = smoothstep(0.0, 1.0, length(uv) * 2.0 - 1.5);\n    return vec4(mix(vec3(0.0), rgbColor, blend), 1.0);\n}"
  },
  "data_830.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Time-based rotation\n    float time = iTime * 0.5;\n    \n    // Cube position and size\n    const float cubeSize = 0.8;\n    vec3 lightDir = normalize(vec3(1.0, -1.0, 1.0));\n    vec3 viewDir = normalize(vec3(uv.x*2.0-1.0, uv.y*2.0-1.0, 1.0));\n    \n    // Cube faces\n    float d = 0.5;\n    vec3 faceDistances = vec3(\n        abs(uv.x - d) < cubeSize ? abs(uv.y - d) : 999.0,\n        abs(uv.x - d) < cubeSize ? abs(uv.y + d) : 999.0,\n        abs(uv.y - d) < cubeSize ? abs(uv.x - d) : 999.0\n    );\n    \n    // Find closest face\n    float minDist = min(min(faceDistances.x, faceDistances.y), faceDistances.z);\n    vec3 color = vec3(0.0);\n    \n    if (minDist == faceDistances.x) {\n        // Front face\n        vec2 pos = uv - vec2(d, d);\n        float angle = time;\n        vec2 rotatedPos = vec2(\n            pos.x * cos(angle) - pos.y * sin(angle),\n            pos.x * sin(angle) + pos.y * cos(angle)\n        );\n        \n        // Calculate normals and specular highlights\n        vec3 normal = normalize(vec3(0.0, 0.0, 1.0));\n        vec3 reflectedLight = reflect(lightDir, normal);\n        float spec = pow(max(dot(reflectedLight, viewDir), 0.0), 32.0);\n        \n        // Color with time-based hue shift\n        vec3 hslColor = hsl((time + uv.x * 0.5) * 10.0, 0.7, 0.6);\n        color = hsl2rgb(hslColor) * (0.8 + spec * 0.4);\n    } else if (minDist == faceDistances.y) {\n        // Back face\n        vec2 pos = uv - vec2(d, -d);\n        float angle = time;\n        vec2 rotatedPos = vec2(\n            pos.x * cos(angle) - pos.y * sin(angle),\n            pos.x * sin(angle) + pos.y * cos(angle)\n        );\n        \n        // Calculate normals and specular highlights\n        vec3 normal = normalize(vec3(0.0, 0.0, -1.0));\n        vec3 reflectedLight = reflect(lightDir, normal);\n        float spec = pow(max(dot(reflectedLight, viewDir), 0.0), 32.0);\n        \n        // Color with time-based hue shift\n        vec3 hslColor = hsl((time + uv.x * 0.5) * 10.0, 0.7, 0.6);\n        color = hsl2rgb(hslColor) * (0.8 + spec * 0.4);\n    } else {\n        // Side faces\n        vec2 pos = uv - vec2(d, d);\n        float angle = time;\n        vec2 rotatedPos = vec2(\n            pos.x * cos(angle) - pos.y * sin(angle),\n            pos.x * sin(angle) + pos.y * cos(angle)\n        );\n        \n        // Calculate normals and specular highlights\n        vec3 normal = normalize(vec3(1.0, 0.0, 0.0));\n        vec3 reflectedLight = reflect(lightDir, normal);\n        float spec = pow(max(dot(reflectedLight, viewDir), 0.0), 32.0);\n        \n        // Color with time-based hue shift\n        vec3 hslColor = hsl((time + uv.y * 0.5) * 10.0, 0.7, 0.6);\n        color = hsl2rgb(hslColor) * (0.8 + spec * 0.4);\n    }\n    \n    // Add noise for extra detail\n    float noiseValue = noise(vec3(uv, time)) * 0.1;\n    color += noiseValue;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_831.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based animation\n    float t = iTime * 0.5;\n    \n    // Generate base pattern using sine waves\n    vec2 st = uv * 10.0;\n    st.x += sin(t + st.y * 2.0) * 0.5;\n    st.y += cos(t + st.x * 2.0) * 0.5;\n    \n    // Add turbulence for dynamic movement\n    float turb = turbulent(st);\n    \n    // Create color palette using HSL\n    vec3 hslColor = vec3(\n        mod(uv.x * 10.0 + t, 1.0),   // Hue variation\n        0.7 + turb * 0.3,            // Saturation with turbulence\n        0.5                        // Lightness\n    );\n    \n    // Convert HSL to RGB and mix with noise\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= 1.0 + turbulent(uv * 4.0) * 0.5;\n    \n    // Create geometric pattern using mod function\n    float pattern = mod(sin(st.x) + cos(st.y), 1.0);\n    pattern = smoothstep(0.3, 0.7, pattern); // Add smooth transitions\n    \n    // Combine pattern with color and output\n    return vec4(pattern * rgbColor, 1.0);\n}"
  },
  "data_832.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Calculate grid cell position\n    vec2 pos = mod(st, 1.0);\n    \n    // Time-based rotation angle\n    float time = iTime * 0.5;\n    float angle = sin(time) * 0.5 + 1.5708; // Offset by PI/2\n    \n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    \n    // Apply rotation to position\n    vec2 rotatedPos = rot * (pos - 0.5) + 0.5;\n    \n    // Add noise for texture\n    float noiseVal = noise(vec3(rotatedPos, time)) * 0.1;\n    \n    // Calculate color with rainbow effect\n    vec3 hslColor = vec3(\n        mod(time + rotatedPos.x * 2.0 + rotatedPos.y * 3.0, 1.0), // Hue variation\n        0.7 + noiseVal * 0.3, // Saturation\n        0.5 + noiseVal * 0.5  // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_833.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal tiling\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan(st.y, st.x);\n    // Create hexagonal grid pattern using sin and cos functions\n    float grid = sin(a * 6.0) * 0.5 + 0.5;\n    grid *= noise(vec2(r * 10.0, a * 3.0)) * 0.5 + 0.5;\n    // Add animation using time-based movement\n    float timeFactor = sin(iTime * 0.5) * 0.5 + 0.5;\n    grid *= r * (timeFactor * 0.5 + 0.5);\n    // Create smooth color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(a * 0.1 + timeFactor, 0.7, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Combine grid pattern with color and noise for final effect\n    float noiseValue = noise(vec3(r * 5.0, a * 2.0, iTime)) * 0.5 + 0.5;\n    vec3 finalColor = mix(grid * rgbColor, noiseValue * rgbColor, 0.5);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_834.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a coordinate system centered at (0,0)\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add time-based rotation\n    float t = iTime * 0.5;\n    st = mat2(cos(t), sin(t), -sin(t), cos(t)) * st;\n    \n    // Create hexagonal grid pattern\n    vec2 polar = vec2(length(st), atan2(st.y, st.x));\n    float theta = polar.y * 6.0; // Hexagonal symmetry\n    \n    // Create tessellation pattern with shifting colors\n    float gridX = sin(polar.x * 10.0 + theta + t) * 0.5 + 0.5;\n    float gridY = cos(polar.x * 10.0 - theta + t) * 0.5 + 0.5;\n    \n    // Combine patterns and add noise\n    float pattern = sin(gridX * pi) * cos(gridY * pi);\n    pattern += noise(vec2(st.x * 4.0, st.y * 4.0)) * 0.3;\n    \n    // Create color transitions\n    vec3 color1 = hsl(0.6 + t*0.1, 0.8, 0.5);\n    vec3 color2 = hsl(0.2 + t*0.1, 0.8, 0.7);\n    \n    // Mix colors based on pattern\n    vec3 finalColor = mix(color1, color2, abs(pattern * 0.5 + 0.5));\n    \n    // Add radial motion effect\n    float dist = length(st) * 0.5;\n    finalColor *= sin(dist * pi - t) * 0.5 + 0.5;\n    \n    // Output the result with some glow\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_835.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and tile the UV coordinates\n    vec2 st = uv * 10.0;\n    \n    // Create a grid pattern using sine waves\n    float x = sin(st.x + iTime) * 0.5 + 0.5;\n    float y = sin(st.y + iTime) * 0.5 + 0.5;\n    \n    // Combine the sine waves for a pulsating effect\n    float pattern = (x + y) * 0.5;\n    \n    // Add some noise to create variation\n    vec2 noiseUV = uv * 100.0;\n    float n = noise(noiseUV);\n    pattern += n * 0.3;\n    \n    // Create a shifting hue effect\n    float hue = iTime * 0.5 + (uv.x + uv.y) * 2.0;\n    vec3 color = hsl(hue, 1.0, 0.5);\n    \n    // Convert HSL to RGB and apply the pattern\n    vec3 finalColor = hsl2rgb(color) * pattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_836.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base color from time-based sine waves\n    vec3 c = vec3(\n        sin(iTime * 0.5 + uv.x * 10.0) * 0.5 + 0.5,\n        noise(uv * 200.0 + iTime) * 0.5 + 0.5,\n        noise(uv * 100.0 + iTime * 3.0) * 0.5 + 0.5\n    );\n    \n    // Add turbulence for more complex patterns\n    c += vec3(\n        turbulent(uv * 50.0 + iTime),\n        turbulent(uv * 75.0 - iTime),\n        turbulent(uv * 100.0 + iTime * 2.0)\n    ) * 0.3;\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(c), 0.9);\n}"
  },
  "data_837.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create geometric pattern using sine waves\n    float pattern = abs(sin(theta * 6.0)); // Hexagon pattern\n    pattern += abs(sin(theta * 3.0 + iTime)); // Add dynamic layer\n    \n    // Add noise layers for texture\n    vec2 noiseUV = uv * 100.0; // Scale up for fine noise\n    float noise1 = noise(noiseUV);\n    float noise2 = turbulent(vec3(uv * 50.0, iTime));\n    \n    // Combine pattern and noise with color transitions\n    vec3 color = hsl2rgb(vec3(\n        mod(theta * 0.1 + iTime, 1.0), // Hue variation over time\n        0.7, // Saturation\n        0.5 + 0.5 * (pattern + noise1 * 0.5 + noise2 * 0.3) // Brightness modulation\n    ));\n    \n    // Add radial falloff\n    color *= pow(r, 2.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_838.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for spiral pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create spiral pattern using radius and angle\n    float spiral = turbulent(vec3(r * 8.0, a * 4.0, iTime * 0.1));\n    \n    // Color based on angle and radius for vibrant gradients\n    vec3 color = hsl2rgb(vec3(\n        mod(a * 5.0 + iTime, 2.0 * PI) / (2.0 * PI), // Hue variation\n        0.7 + 0.3 * sin(r * 10.0 + iTime * 2.0),      // Saturation modulation\n        0.5 + 0.5 * spiral                           // Value from turbulence\n    ));\n    \n    // Add glow effect around center\n    float glow = smoothstep(0.8, 0.9, r);\n    color *= 1.0 + glow * 2.0;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_839.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan(st.y, st.x) + iTime * 0.5;\n    float r = length(st);\n    \n    // Add noise and turbulence\n    float n = noise(vec2(uv * 4.0 + iTime));\n    float t = turbulent(vec3(uv * 8.0, iTime * 0.1));\n    \n    // Create color variations using HSL\n    vec3 c1 = hsl(theta * 0.5 + 0.5, r * 0.5 + 0.5, 0.7);\n    vec3 c2 = hsl(theta * 0.3 + 0.3, r * 0.3 + 0.6, 0.8);\n    \n    // Mix colors with noise patterns\n    vec3 finalColor = mix(c1, c2, smoothstep(0.0, 1.0, n * 0.5 + 0.5));\n    finalColor *= smoothstep(0.0, 1.0, t * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_84.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for fractal pattern\n    vec2 st = uv * 10.0;\n    \n    // Add time-based rotation\n    float t = iTime * 0.5;\n    st = mat2(cos(t), sin(t), -sin(t), cos(t)) * st;\n    \n    // Create complex noise patterns using turbulence\n    float noise1 = turbulent(st);\n    float noise2 = turbulent(st * 0.5 + vec2(10, 20));\n    \n    // Combine noise values with UV coordinates\n    vec3 color = hsl(\n        (noise1 + sin(length(st)) * 0.5) * 0.5 + 0.5,\n        abs(noise2 * 0.5 + 0.5),\n        0.5\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_840.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan(st.y, st.x);\n    float r = length(st);\n    // Create rotating sine wave pattern with time offset\n    float wave = sin(theta + iTime * 0.5) * 4.0;\n    wave += sin(r * 2.0 - iTime) * 3.0;\n    // Add noise and turbulence for more dynamic patterns\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseVal = noise(noiseUV);\n    float turb = turbulent(vec2(uv.x * 5.0, uv.y * 5.0 - iTime));\n    // Create color from HSL values with shifting hues\n    vec3 hslColor = vec3(\n        mod(theta + iTime * 0.1, PI) / PI,   // Hue\n        0.7 + noiseVal * 0.3,                // Saturation\n        0.5 + turb * 0.5                    // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_841.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form with rotation\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x) + iTime * 0.5;\n    \n    // Create a rotating pattern using multiple frequencies\n    float freq1 = turbulent(vec3(r * 4.0 - theta * 2.0, 0.0, 0.0)) * 0.5 + 0.5;\n    float freq2 = turbulent(vec3(r * 8.0 + theta * 4.0, 0.0, 0.0)) * 0.5 + 0.5;\n    \n    // Combine frequencies and add color variation\n    vec3 color = hsl(\n        (theta / (2.0 * PI) + iTime * 0.1) * 360.0,\n        0.7,\n        freq1 * freq2 * 0.8 + 0.2\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_842.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of rotating squares\n    vec2 st = uv * 10.0; // Scale UV coordinates to create a grid\n    \n    // Get integer grid cell indices\n    vec2 ij = floor(st);\n    \n    // Calculate rotation angle based on time and position\n    float time = iTime * 0.5;\n    float angle = sin(time + ij.x * 0.1) * cos(time + ij.y * 0.1);\n    \n    // Create rotating pattern using sine and cosine\n    vec2 rotated = vec2(\n        cos(angle) * (st.x - ij.x) - sin(angle) * (st.y - ij.y),\n        sin(angle) * (st.x - ij.x) + cos(angle) * (st.y - ij.y)\n    );\n    \n    // Add noise to create variations\n    float noiseVal = noise(vec2(ij)) * 0.5;\n    angle += noiseVal;\n    \n    // Create color transitions using HSL colors\n    vec3 color = hsl(\n        time + ij.x * 0.1 + noiseVal,\n        0.7,\n        0.5\n    );\n    \n    // Convert to RGB and return as fragment color\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_843.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    float angle = atan2(uv.y, uv.x);\n    float radius = length(uv * 1.5);\n    \n    // Create rotating hexagonal pattern\n    vec2 st = uv;\n    st *= 6.0; // Hexagon count\n    st += iTime * 3.0; // Rotation speed\n    \n    // Expand rings with time\n    float ring = sin(radius * 8.0 + iTime) * 0.5 + 0.5;\n    \n    // Combine patterns and add turbulence\n    float pattern = (sin(angle * 6.0 - iTime) * 0.5 + 0.5) * \n                   (sin(radius * 2.0 + iTime) * 0.5 + 0.5);\n    \n    // Color transitions using HSL\n    vec3 color = hsl(\n        sin(iTime * 0.1 + radius * 2.0) * 0.5 + 0.5, // Hue variation\n        0.7 + turbulent(vec2(radius, iTime)) * 0.3,   // Saturation\n        0.5 + ring * 0.5                          // Lightness\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_844.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv * 1.5); // Scale radius for better pattern spacing\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create rotating sine wave patterns\n    float pattern = sin(r * 8.0 + theta * 4.0) * 0.5 + 0.5;\n    pattern *= sin(theta * 2.0 + iTime); // Add color cycling\n    \n    // Generate RGB colors with phase shifts for cycling effect\n    vec3 color;\n    color.r = sin(pattern * 8.0 + iTime * 2.0) * 0.5 + 0.5;\n    color.g = sin(pattern * 8.0 + iTime * 1.5) * 0.5 + 0.5;\n    color.b = sin(pattern * 8.0 + iTime) * 0.5 + 0.5;\n    \n    // Add noise for dynamic variations\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float noiseValue = noise(noiseUV);\n    color *= noiseValue * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_845.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 st = uv - 0.5;\n    \n    // Polar coordinates\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Base color based on distance from center and time\n    vec3 baseColor = hsl(r * 0.6 + 0.3, 0.7, 0.5 + sin(iTime * 0.5) * 0.2);\n    \n    // Add pulsating rings\n    float ring = sin(r * 10.0 - iTime * 2.0) * 0.5;\n    baseColor *= 1.0 + ring;\n    \n    // Create light rays emanating from center\n    float ray = sin(theta * 8.0 + iTime) * 0.3;\n    ray += turbulent(vec2(r, theta)) * 0.2;\n    \n    // Combine effects\n    vec3 finalColor = mix(baseColor, hsl(0.1, 0.9, 0.7), ray);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_846.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 centered = uv - 0.5;\n    \n    // Create circular pattern using distance from center\n    float dist = length(centered);\n    \n    // Add rotation over time\n    float angle = atan2(centered.y, centered.x) + iTime * 0.1;\n    \n    // Use sine waves to create color transitions\n    vec3 colors = vec3(\n        sin(dist * 5.0 + iTime) * 0.5 + 0.5,\n        sin(dist * 5.0 + iTime + 2.094) * 0.5 + 0.5, // 120 degrees offset\n        sin(dist * 5.0 + iTime + 4.188) * 0.5 + 0.5  // 240 degrees offset\n    );\n    \n    // Create multiple color wheels using different frequencies\n    vec3 color1 = hsl2rgb(vec3(\n        dist * 360.0 + iTime * 60.0,\n        1.0,\n        0.5\n    ));\n    \n    vec3 color2 = hsl2rgb(vec3(\n        (dist * 2.0) * 360.0 + iTime * 40.0,\n        1.0,\n        0.5\n    ));\n    \n    vec3 color3 = hsl2rgb(vec3(\n        (dist * 4.0) * 360.0 + iTime * 20.0,\n        1.0,\n        0.5\n    ));\n    \n    // Combine colors and add noise for texture\n    vec3 finalColor = color1 + color2 + color3;\n    finalColor *= sin(angle * 4.0) * 0.5 + 0.5;\n    finalColor += noise(uv * 8.0) * 0.2;\n    \n    return vec4(clamp(finalColor, 0.0, 1.0), 1.0);\n}"
  },
  "data_847.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal rotation pattern\n    a += sin(iTime * 0.5 + r * 4.0) * 0.5;\n    \n    // Add pulsing effect using noise and turbulence\n    float pulse = turbulent(vec3(r, a, iTime)) * 0.5 + 0.5;\n    float dist = length(st) * (1.0 + sin(iTime + r * 4.0) * 0.2);\n    \n    // Create hexagonal pattern with pulsing\n    float hex = abs(sin(a * 3.0 - iTime)) * 0.5 + 0.5;\n    hex *= smoothstep(0.8, 1.0, pulse);\n    // Generate RGB color gradient\n    vec3 color = hsl2rgb(vec3(\n        sin(iTime + r * 4.0) * 0.5 + 0.5,\n        0.7,\n        hex * 0.8 + 0.2\n    ));\n    return vec4(color, 1.0);\n}"
  },
  "data_848.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern with time-based movement\n    vec2 st = uv * 5.0 + vec2(sin(iTime), cos(iTime)) * 3.0;\n    \n    // Add turbulence to create dynamic noise patterns\n    float turb = turbulent(st * 0.5);\n    \n    // Calculate color using HSL to RGB conversion with time-based hue\n    vec3 color = hsl2rgb(vec3(\n        sin(length(st) + iTime) * 0.5 + 0.5, \n        1.0,\n        0.6 + turb * 0.4\n    ));\n    \n    // Add lighting effect using another layer of turbulence\n    float light = turbulent(st * 0.2 + vec2(iTime)) * 0.5 + 0.5;\n    \n    // Combine color and lighting for final output\n    return vec4(color * light, 1.0);\n}"
  },
  "data_849.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern with time-based rotation\n    vec2 st = uv;\n    float time = iTime * 0.5;  // Scale time for slower animation\n    \n    // Rotate coordinates around center\n    vec2 center = vec2(0.5, 0.5);\n    st -= center;\n    float angle = sin(time) * 4.0;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    st = rot * st + center;\n    \n    // Add scaling for expanding/contracting effect\n    vec2 p = (st - 0.5) * 3.0;  // Scale coordinates\n    p *= 1.0 + 0.5 * sin(time);  // Time-based scaling\n    \n    // Create turbulence pattern with multiple frequencies\n    float t1 = turbulent(p);\n    float t2 = turbulent(p * 2.0 + time);\n    float t3 = turbulent(p * 4.0 - time);\n    \n    // Combine turbulence layers\n    float noiseValue = (t1 + t2 * 0.5 + t3 * 0.25) * 0.5 + 0.5;\n    \n    // Create flowing color pattern\n    vec3 color = hsl2rgb(vec3(\n        noiseValue * 360.0,  // Hue variation based on noise\n        0.7 + 0.3 * sin(time),  // Saturation modulation\n        0.5 + 0.5 * noiseValue  // Brightness variation\n    ));\n    \n    // Add radial motion from center\n    vec2 dir = st - center;\n    float dist = length(dir);\n    color *= 1.0 + 0.3 * sin(time + dist * 4.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_85.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a complex pattern using multiple noise layers\n    vec3 color = vec3(0.0);\n    \n    // Scale UV coordinates for fractal effect\n    vec2 st = uv * 8.0;\n    \n    // Add time-based animation\n    float t = iTime * 0.5;\n    \n    // Create a base pattern using noise and turbulence\n    float n1 = turbulent(st + t);\n    float n2 = noise(vec3(st, t));\n    \n    // Combine patterns with trigonometric functions\n    vec2 pos = vec2(sin(st.x) * cos(t), cos(st.y) * sin(t));\n    \n    // Add fractal-like details using multiple octaves\n    color += hsl2rgb(vec3(\n        mod(n1 * 5.0 + t, 1.0),\n        0.7,\n        0.5\n    )) * n2;\n    \n    // Create a dynamic background pattern\n    vec3 bg = hsl2rgb(vec3(t * 0.5, 0.8, 0.9));\n    \n    // Combine foreground and background with noise modulation\n    color = mix(bg, color, abs(n1) * 0.7 + 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_850.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    // Create hexagonal grid pattern\n    vec2 grid = vec2(\n        sin(theta + 0.5 * pi) * r,\n        cos(theta - 0.5 * pi) * r\n    );\n    // Calculate hexagon position and rotation\n    float hexRotation = iTime * 0.1;\n    theta += hexRotation;\n    // Check if current point is inside a hexagon\n    bool isHexagon = false;\n    if (abs(grid.x) < 0.5 && abs(grid.y) < 0.5) {\n        isHexagon = true;\n    }\n    // Calculate color based on time and position\n    vec3 baseColor = hsl2rgb(vec3(\n        mod(0.5 + sin(iTime * 0.5 + r * 10.0), 1.0),\n        1.0,\n        0.7\n    ));\n    // Add pulsing effect\n    float pulse = sin(iTime * 2.0 + r * 10.0) * 0.3 + 0.7;\n    baseColor *= pulse;\n    // Apply turbulence to create dynamic movement\n    vec2 noiseUV = uv * 5.0 + iTime;\n    float turbulence = turbulent(noiseUV);\n    theta += turbulence * 0.2;\n    // Combine all elements\n    if (isHexagon) {\n        // Create glowing effect based on distance from center\n        float glow = 1.0 - r * 0.5;\n        baseColor *= glow;\n        \n        return vec4(baseColor, 1.0);\n    } else {\n        return vec4(vec3(0.0), 1.0); // Black background\n    }\n}"
  },
  "data_851.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create rotating circular pattern\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = sin(time * 2.0) * 10.0;\n    \n    // Add rotation and geometric effect\n    st = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * st;\n    float pattern = smoothstep(0.7, 1.0, r);\n    \n    // Generate noise texture\n    vec2 noisePos = uv * 5.0 + time;\n    float noiseVal = noise(noisePos) * 0.5 + 0.5;\n    \n    // Dynamic color transitions\n    vec3 colorBase = hsl2rgb(vec3(sin(time * 0.5) * 0.5 + 0.5, \n                                 sin(time * 0.7) * 0.5 + 0.5,\n                                 1.0));\n    \n    // Combine elements with light movement\n    vec3 finalColor = mix(colorBase, vec3(noiseVal), pattern);\n    finalColor *= smoothstep(0.0, 1.0, sin(time + r * 2.0) * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_852.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a transformation matrix for hexagonal tiling\n    mat2 m = mat2(0.5, -sqrt(3.0)/2.0, sqrt(3.0)/2.0, 0.5);\n    vec2 st = uv * 4.0; // Scale up the UV coordinates\n    \n    // Transform to hexagonal grid\n    vec2 q = m * (st + iTime); // Add time for animation\n    \n    // Calculate distance from center in hexagonal space\n    float r = length(q);\n    \n    // Create hexagon shape using polar coordinates\n    float theta = atan2(q.y, q.x) / 6.0;\n    vec2 tc = vec2(r * cos(theta), r * sin(theta));\n    \n    // Generate color gradient with time-based rotation\n    vec3 baseColor = hsl2rgb(vec3(0.5 + 0.5*sin(iTime*0.5 + theta), 1.0, 0.7));\n    vec3 mixColor = hsl2rgb(vec3(0.5 + 0.5*cos(iTime*0.5 + theta), 0.8, 0.6));\n    \n    // Use noise to add variation between hexagons\n    float noiseVal = noise(q * 0.1) * 0.2;\n    vec3 finalColor = mix(baseColor, mixColor, noiseVal);\n    \n    // Add pulsing effect\n    float pulse = sin(iTime*0.5 + r*4.0) * 0.2 + 0.8;\n    finalColor *= pulse;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_853.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = float(iTime) * 0.5;\n    \n    // Layered sine waves with varying frequencies and amplitudes\n    vec2 st = uv * 10.0;\n    float total = 0.0;\n    \n    for(int i = 0; i < 4; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(0.3, float(i));\n        \n        // Sine wave pattern\n        vec2 sine = sin(vec2(st.x * freq + time, st.y * freq + time + PI/2.)) * 0.5 + 0.5;\n        total += length(sine) * amp;\n    }\n    \n    // Add noise and turbulence\n    float noiseVal = turbulent(uv * 10.0 + time);\n    total = (total * 0.5 + 0.5) * mix(1.0, noiseVal, 0.3);\n    \n    // Color transformation with RGB shifts\n    vec3 color = hsl2rgb(vec3(\n        sin(time * 0.5) * 0.5 + 0.5,\n        0.7,\n        0.6\n    )) * total;\n    \n    // Add time-based RGB shifts\n    color.r += sin(time * 0.5);\n    color.g += sin(time * 0.7 + PI/2.);\n    color.b += sin(time * 1.0 + PI);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_854.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    float dist = length(uv + 0.5);\n    \n    // Create pulsating rings effect using sine wave and noise\n    float ringEffect = sin(dist * 10.0 + iTime * 2.0) * 0.5;\n    ringEffect += noise(vec3(iTime, uv.x * 4.0, uv.y * 4.0)) * 0.5;\n    \n    // Create rotating color wheels using polar coordinates\n    vec2 polar = vec2(length(uv), atan2(uv.y, uv.x));\n    float angle = polar.y + iTime;\n    \n    // Generate multiple rings with different colors\n    vec3 color1 = hsv2rgb(vec3(angle * 0.5, 1.0, ringEffect));\n    vec3 color2 = hsv2rgb(vec3(angle * 0.7 + 1.0, 1.0, ringEffect + 0.5));\n    \n    // Combine effects\n    vec3 finalColor = mix(color1, color2, sin(iTime) * 0.5 + 0.5);\n    finalColor += noise(vec3(uv * 4.0, iTime)) * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_855.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 pos = uv * 2.0 - 1.0;\n    float r = length(pos);\n    float theta = atan2(pos.y, pos.x) + iTime * 0.5; // Rotate over time\n    \n    // Create pulsating circles with different frequencies\n    float pulse1 = sin(iTime * 0.7) * 0.4 + 0.6;\n    float pulse2 = sin(iTime * 0.9 + pi) * 0.3 + 0.7;\n    \n    // Calculate distance from center for each pulsating layer\n    float d1 = abs(r - pulse1);\n    float d2 = abs(r - pulse2);\n    \n    // Create color wheel with rotating hues\n    vec3 colorWheel = hsl(theta * 0.5, 1.0, 0.5);\n    \n    // Combine pulsating circles and color wheel\n    vec3 finalColor = colorWheel * (1.0 - smoothstep(0.2, 0.0, d1)) +\n                     vec3(1.0) * (1.0 - smoothstep(0.2, 0.0, d2));\n    \n    // Add noise for extra texture\n    finalColor += noise(vec3(uv * 4.0 + iTime, 0.0)) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_856.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of points with noise-based movement\n    vec2 grid = floor(uv * 10.0);\n    vec2 pos = (grid + noise(vec3(grid, iTime))) / 10.0;\n    \n    // Calculate distance from current fragment to grid point\n    float dist = length(uv - pos);\n    float glow = inversesqrt(dist * 5.0 + 0.1) * \n                (0.5 + 0.5 * sin(iTime + pos.x * 10.0));\n    \n    // Add turbulence for pulsing effect\n    float pulse = turbulent(vec3(pos, iTime * 0.2)) * 0.5 + 0.5;\n    glow *= pulse;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        pos.x * 360.0 + iTime * 100.0,\n        0.7,\n        0.5 + 0.5 * sin(iTime + pos.y * 10.0)\n    );\n    vec3 color = hsl2rgb(hslColor);\n    \n    // Add connecting lines between nearby points\n    float lineStrength = 0.0;\n    for (int dx = -1; dx <= 1; dx++) {\n        for (int dy = -1; dy <= 1; dy++) {\n            if (dx == 0 && dy == 0) continue;\n            vec2 neighborPos = pos + vec2(dx, dy) * 0.1;\n            float lineDist = length(uv - mix(pos, neighborPos, 0.5));\n            lineStrength += inversesqrt(lineDist * 5.0 + 0.1);\n        }\n    }\n    \n    // Combine effects\n    vec3 finalColor = color * glow + \n                     vec3(1.0) * (lineStrength * 0.2);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_857.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal tiling\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create hexagonal grid pattern using polar coordinates\n    float scale = 5.0;\n    vec2 polar = vec2(r * scale, a);\n    vec2 tile = floor(polar);\n    \n    // Calculate color based on position and time\n    vec3 hslColor = vec3(\n        mod(a * 0.1 + iTime, 1.0), // Hue variation over time\n        0.7,                       // Saturation\n        0.5                        // Lightness\n    );\n    \n    // Apply sine wave distortion to UV coordinates\n    float distortion = sin(r * 8.0 + iTime) * 0.2;\n    vec2 distortedUV = uv + vec2(sin(a * 3.0 + iTime), cos(a * 5.0 + iTime)) * distortion;\n    \n    // Convert HSL to RGB and apply noise-based modulation\n    vec3 rgbColor = hsl2rgb(hslColor);\n    float noiseValue = noise(vec3(distortedUV, iTime));\n    rgbColor *= 1.0 + sin(noiseValue * 8.0 + iTime) * 0.5;\n    \n    // Create hexagonal pattern with color shifts\n    float cell = mod(r * scale, 1.0);\n    vec3 finalColor = mix(vec3(0.0), rgbColor, smoothstep(0.4, 0.6, cell));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_858.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based animation\n    float t = iTime * 0.5;\n    \n    // Create two sets of sine waves with different frequencies and phases\n    vec2 st1 = uv * 8.0 + vec2(t, 0.0);\n    vec2 st2 = uv * 8.0 + vec2(0.0, t * 0.7);\n    \n    // Generate wave patterns using sin function\n    float wave1 = sin(st1.x) * cos(st1.y + t) * 0.5 + 0.5;\n    float wave2 = sin(st2.y) * cos(st2.x - t * 0.3) * 0.5 + 0.5;\n    \n    // Combine waves and add noise for turbulence\n    float combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(uv * 4.0 + vec2(t)) * 0.3;\n    \n    // Create vibrant colors using HSL to RGB conversion\n    vec3 color1 = hsl2rgb(vec3((wave1 * 360.0 + t * 90.0) / 360.0, 0.8, 0.5));\n    vec3 color2 = hsl2rgb(vec3((wave2 * 360.0 - t * 90.0) / 360.0, 0.8, 0.5));\n    \n    // Mix colors based on wave intensity\n    vec3 finalColor = mix(color1, color2, combined);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_859.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv * 0.5 + 0.5); // Scale UV to 0-1 range\n    \n    // Add noise and time-based variation\n    float noiseValue = noise(uv * 5.0 + iTime) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL\n    vec3 baseColor = hsl2rgb(vec3(theta * 180.0 / PI + iTime * 60.0, 0.7, 0.7));\n    vec3 noiseColor = hsl2rgb(vec3((r + noiseValue) * 90.0 + iTime * 45.0, 0.6, 0.8));\n    \n    // Combine colors with turbulence\n    float turb = turbulent(vec2(theta, r)) * 0.5 + 0.5;\n    vec3 finalColor = mix(baseColor, noiseColor, turb);\n    \n    // Add depth using multiple layers\n    finalColor *= (1.0 - abs(r - 0.5) * 2.0) * 0.8 + 0.2;\n    finalColor += turbulent(uv * 3.0 + iTime) * 0.4;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_860.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create layered sine wave patterns with noise\n    float d = sin(uv.x * 8.0 + iTime) * 0.5;\n    d += sin((uv.y + uv.x) * 4.0 + iTime * 0.5) * 0.3;\n    d += turbulent(uv * 8.0) * 0.2;\n    \n    // Create RGB shifts using HSL color space\n    vec3 baseColor = hsl(0.5 + sin(iTime * 0.5) / 4.0, 1.0, 0.5);\n    vec3 rgb = hsl2rgb(baseColor);\n    \n    // Add dynamic RGB variations\n    rgb.r += sin(uv.x * 8.0 + iTime * 2.0) * 0.2;\n    rgb.g += sin(uv.y * 8.0 + iTime * 1.5) * 0.2;\n    rgb.b += sin((uv.x + uv.y) * 4.0 + iTime) * 0.2;\n    \n    return vec4(rgb, 1.0);\n}"
  },
  "data_861.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate UV coordinates over time\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create turbulence effect\n    float turb = turbulent(st);\n    vec3 noise1 = vec3(turbulent(st + vec2(0.0, 1.0)), \n                       turbulent(st + vec2(1.0, 0.0)),\n                       turbulent(st + vec2(1.0, 1.0)));\n    \n    // Generate color gradients using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(length(noise1) * 5.0 + iTime, 1.0),\n        0.7,\n        0.5\n    ));\n    \n    // Add lighting effect\n    float light = max(0.0, 1.0 - length(uv));\n    color *= light;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_862.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates to create a grid of 20x20 tiles\n    vec2 st = uv * 20.0;\n    \n    // Get tile position and offset within each tile\n    vec2 tile = floor(st);\n    vec2 pos = fract(st);\n    \n    // Create animated color shifts using time\n    float timeFactor = sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    // Calculate base color for each tile using noise and position\n    float colorValue = sin(tile.x * 0.1 + tile.y * 0.2 + iTime * 0.3);\n    colorValue = (colorValue + 1.0) * 0.5; // Scale to 0-1 range\n    \n    // Create smooth transitions between colors using turbulence\n    float turb = turbulent(vec2(pos.x, pos.y));\n    \n    // Combine color and turbulence for final color\n    vec3 hslColor = vec3(colorValue + turb * 0.2, 0.7, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_863.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add rotation over time\n    \n    // Create hexagonal pattern using polar coordinates\n    a += sin(r * 6.0 + iTime) * 0.1; // Add some distortion\n    float hex = abs(sin(a * 3.0)) * 0.5 + 0.5;\n    \n    // Generate noise for color shifting\n    vec2 noiseUV = uv * 50.0 + iTime;\n    float n = noise(noiseUV);\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 baseColor = hsl2rgb(vec3(0.6, 1.0, 0.5));\n    vec3 color = mix(baseColor, hsl2rgb(vec3(n * 0.7 + 0.3, 1.0, 0.5)), hex);\n    \n    // Add turbulence effect\n    float turb = turbulent(vec2(a, r)) * 0.5 + 0.5;\n    color *= turb;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_864.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate based on time and position\n    float time = iTime * 0.5;\n    \n    // Create rotating patterns\n    vec2 st = uv * 8.0 + time;\n    st += vec2(sin(time + st.x), cos(time + st.y)) * 0.5;\n    \n    // Add turbulence for complex patterns\n    float t1 = turbulent(st * 0.5);\n    float t2 = turbulent(vec3(st, time) * 0.7);\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl2rgb(vec3(time + st.x*0.5, 0.6, 0.5));\n    vec3 color2 = hsl2rgb(vec3(time + st.y*0.5, 0.7, 0.6));\n    \n    // Combine patterns and colors\n    float mixAmount = (t1 + t2) * 0.5;\n    vec3 finalColor = mix(color1, color2, mixAmount);\n    \n    // Add brightness variation\n    finalColor *= 0.8 + sin(time + st.x*0.7) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_865.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center and angle\n    float dist = length(uv);\n    float angle = atan2(uv.y, uv.x);\n    // Create expanding rings using time-based animation\n    float ringRadius = dist + sin(iTime * 0.5 + dist * 2.0) * 0.5;\n    float ringIndex = mod(ringRadius * 10.0, 3.0); // 3 rings\n    \n    // Smooth color transition using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(ringIndex + iTime, 3.0) / 3.0, // Hue\n        0.7, // Saturation\n        0.5 // Lightness\n    ));\n    \n    // Add noise and turbulence for dynamic effect\n    vec2 noiseUV = uv * 10.0;\n    float noiseValue = noise(noiseUV);\n    color *= 1.0 + noiseValue * 0.3;\n    \n    // Create pulsing animation\n    float pulse = sin(iTime + dist * 5.0) * 0.2 + 0.8;\n    color *= pulse;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_866.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Distort UV coordinates with sine waves\n    vec2 distortedUV = uv + 0.3 * sin(5.0 * uv + iTime);\n    \n    // Create radial pattern from center\n    vec2 toCenter = distortedUV - 0.5;\n    float dist = length(toCenter) * 10.0;\n    float angle = atan2(toCenter.y, toCenter.x);\n    \n    // Add turbulence for organic feel\n    float turb = turbulent(distortedUV * 3.0 + iTime);\n    \n    // Create pulsing light effect\n    float pulse = sin(iTime * 2.0 + dist) * 0.5 + 0.5;\n    \n    // Color shifting based on position and time\n    vec3 color = hsl2rgb(vec3(\n        (dist + iTime) * 0.1,   // Hue\n        0.7 + turb * 0.3,      // Saturation\n        pulse                   // Value\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_867.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base noise patterns\n    float noise1 = turbulent(vec3(uv * 20.0 + iTime, iTime));\n    float noise2 = turbulent(vec3(uv * 15.0 + iTime * 0.5, iTime));\n    // Generate color from HSL with time-based shifts\n    vec3 color = hsl(\n        sin(iTime * 0.2 + uv.x * 4.0) * 0.5 + 0.5,\n        1.0,\n        0.6\n    );\n    // Add dynamic light source that moves over time\n    vec2 lightPos = vec2(sin(iTime * 0.3) * 0.5 + 0.5, cos(iTime * 0.3) * 0.5 + 0.5);\n    float lightDist = length(uv - lightPos);\n    float lightIntensity = sin(lightDist * 10.0 + iTime * 2.0) * 0.5 + 0.5;\n    // Combine noise patterns with color and lighting\n    vec3 finalColor = mix(\n        color,\n        hsl(\n            sin(iTime * 0.4 + uv.y * 4.0) * 0.5 + 0.5,\n            1.0,\n            0.8\n        ),\n        noise2 * 0.5 + 0.5\n    ) * (1.0 - lightIntensity);\n    // Add glow effect\n    finalColor += vec3(\n        noise1 * 0.4,\n        noise2 * 0.6,\n        (noise1 + noise2) * 0.2\n    );\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_868.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 st = uv - 0.5;\n    \n    // Add rotation based on time\n    float angle = iTime * 0.5;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    st = rot * st * 1.5; // Scale and rotate\n    \n    // Create triangular pattern using barycentric coordinates\n    vec3 coords = vec3(st.x, st.y, 0.0);\n    coords.xy = abs(coords.xy);\n    \n    // Calculate triangle edges\n    float edge1 = coords.x + coords.y - 0.5;\n    float edge2 = coords.x - coords.y - 0.5;\n    float edge3 = -coords.x - coords.y - 0.5;\n    \n    // Check if inside triangle\n    bool inside = (edge1 < 0.0) && (edge2 < 0.0) && (edge3 < 0.0);\n    \n    // Create color variations using HSL\n    vec3 color1 = hsl(0.5 + sin(iTime * 0.3 + st.x * 2.0), 0.8, 0.6);\n    vec3 color2 = hsl(0.5 + cos(iTime * 0.4 + st.y * 2.0), 0.7, 0.5);\n    \n    // Mix colors based on position\n    vec3 finalColor = mix(color1, color2, abs(st.x) + abs(st.y));\n    \n    // Add noise and turbulence for dynamic effect\n    float noiseVal = noise(vec3(st * 4.0, iTime)) * 0.5;\n    finalColor += noiseVal;\n    \n    // Apply turbulence to create swirling pattern\n    float turb = turbulent(vec2(st.x * 2.0, st.y * 2.0)) * 0.3;\n    finalColor *= 1.0 + turb;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_869.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates by 45 degrees for diagonal pattern\n    vec2 rotated = vec2(\n        uv.x * cos(pi/4.) - uv.y * sin(pi/4.),\n        uv.x * sin(pi/4.) + uv.y * cos(pi/4.)\n    );\n    \n    // Create moving checkerboard pattern with time-based frequency\n    float freq = 100.0;\n    float pattern = sin(rotated.x * freq + iTime) +\n                   sin(rotated.y * freq + iTime * 0.5);\n    \n    // Use threshold to create alternating colors\n    vec3 warmColor = hsl2rgb(vec3(0.1, 0.8, 0.6)); // Warm color (orange)\n    vec3 coolColor = hsl2rgb(vec3(0.7, 0.8, 0.6)); // Cool color (blue)\n    \n    // Create smooth transition between colors\n    float mixAmount = sin(iTime * 0.5 + pattern * 10.0) * 0.5 + 0.5;\n    vec3 finalColor = mix(warmColor, coolColor, mixAmount);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_87.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotated = uv * mat2(cos(t), sin(t), -sin(t), cos(t));\n    \n    // Scale and create noise patterns\n    vec2 scaled = rotated * 5.0;\n    float n1 = noise(scaled);\n    float n2 = turbulent(vec3(scaled, t));\n    \n    // Create color variations using HSL\n    vec3 hslColor = vec3(\n        mod(t + n1 * 2.0, 1.0),\n        0.7,\n        0.5 + n2 * 0.4\n    );\n    \n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_870.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based sine waves in both x and y directions\n    float sinX = sin(uv.x * 10.0 + iTime);\n    float cosY = cos(uv.y * 10.0 - iTime);\n    \n    // Combine the waves with noise\n    vec2 noiseCoords = vec2(sinX, cosY) * 0.5 + 0.5;\n    float noiseVal = noise(noiseCoords);\n    \n    // Add turbulence for more complex patterns\n    float turb = turbulent(vec3(uv * 10.0, iTime));\n    \n    // Create a rotating color pattern using HSL\n    vec3 hslColor = vec3(\n        mod(iTime + uv.x * 2.0 + uv.y * 3.0, 1.0),  // Hue\n        0.7 + noiseVal * 0.3,                         // Saturation\n        0.5 + turb * 0.5                             // Lightness\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_871.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates and add motion\n    vec2 st = uv - 0.5;\n    float radius = length(st);\n    \n    // Create rotating pattern using time\n    float angle = atan2(st.y, st.x) + sin(iTime * 0.5) * 4.0;\n    float r = radius * cos(angle);\n    \n    // Add noise and turbulence for organic feel\n    vec3 noiseParams = vec3(r, iTime * 0.1, 0.0);\n    float noiseValue = noise(noiseParams);\n    \n    // Generate color using HSL with time-based hue shift\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + r * 0.5),  // Hue varies with radius and time\n        0.7,                            // Saturation\n        0.5 + noiseValue * 0.2          // Lightness with noise variation\n    );\n    \n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Combine elements for final color\n    return vec4(rgbColor * (1.0 - abs(r) * 0.5), 1.0);\n}"
  },
  "data_872.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern with animated sine waves\n    float time = iTime * 0.5;\n    \n    // Base grid calculation\n    vec2 st = uv * 10.0;\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Animate the grid with sine waves\n    float wave = sin(ipos.x * 0.5 + time) * 0.5 + 0.5;\n    wave += sin(ipos.y * 0.5 + time + PI*0.5) * 0.5;\n    \n    // Add noise and turbulence\n    vec2 noisePos = ipos + vec2(time, time);\n    float n1 = noise(noisePos);\n    float n2 = turbulent(vec3(st, time));\n    \n    // Create color variations\n    vec3 color1 = hsl(wave * 0.7 + 0.3, 0.8, 0.6);\n    vec3 color2 = hsl((wave + n1) * 0.5 + 0.2, 0.7, 0.5);\n    \n    // Combine patterns\n    float blend = smoothstep(0.0, 1.0, fpos.x + fpos.y - 0.5);\n    vec3 finalColor = mix(color1, color2, blend);\n    \n    // Add distortion\n    finalColor *= sin(time) * 0.5 + 0.7;\n    finalColor += n2 * 0.3;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_873.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    vec2 rotated = uv * mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    \n    // Create sine wave patterns with time offset\n    float waveU = sin(rotated.x * 10.0 + iTime) * 0.5 + 0.5;\n    float waveV = sin(rotated.y * 10.0 + iTime * 0.5) * 0.5 + 0.5;\n    \n    // Combine waves and add turbulence\n    vec2 distortedUV = rotated + vec2(waveU, waveV) * 0.3;\n    float turb = turbulent(distortedUV * 10.0);\n    \n    // Generate color shifts using noise\n    vec3 colorNoise = vec3(noise(uv + vec2(iTime, 0.0)),\n                          noise(uv + vec2(0.0, iTime*0.5)),\n                          noise(uv + vec2(iTime*0.7, 0.0)));\n    \n    // Create dynamic HSL color\n    vec3 hslColor = vec3(\n        mod(turb * 0.5 + iTime * 0.1, 1.0),  // Hue\n        0.8 + turb * 0.2,                     // Saturation\n        0.5 + sin(iTime) * 0.4                // Lightness\n    );\n    \n    // Convert to RGB and mix with noise\n    vec3 finalColor = hsl2rgb(hslColor) * (1.0 + colorNoise * 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_874.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 pos = uv - 0.5;\n    float d = length(pos);\n    float angle = atan2(pos.y, pos.x);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create radial gradient with rotating bands\n    float band1 = mod(d * 4.0 + iTime, 1.0);\n    float band2 = mod(d * 8.0 + iTime * 0.7, 1.0);\n    float band3 = mod(d * 16.0 + iTime * 0.3, 1.0);\n    \n    // Create color wheel using HSL colors\n    vec3 color1 = hsl2rgb(vec3(0.5 + sin(iTime) * 0.5, 1.0, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.75 + cos(iTime) * 0.5, 1.0, 0.5));\n    vec3 color3 = hsl2rgb(vec3(0.25 + sin(iTime * 0.5), 1.0, 0.5));\n    \n    // Mix colors based on bands\n    vec3 finalColor = mix(color1, color2, band1) * 0.5;\n    finalColor += mix(color2, color3, band2) * 0.5;\n    finalColor += mix(color3, color1, band3) * 0.5;\n    \n    // Add some turbulence for extra movement\n    float turb = turbulent(vec2(uv.x * 4.0 + iTime, uv.y * 4.0 + iTime)) * 0.2;\n    finalColor *= 1.0 + turb;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_875.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 polar = vec2(length(uv), atan2(uv.y, uv.x));\n    \n    // Multiply angle by 6 for hexagonal symmetry and add rotation over time\n    polar.y *= 6.0;\n    polar.y += sin(iTime) * 0.5;\n    \n    // Create a pulsating pattern based on radius and time\n    float pattern = sin(polar.x + iTime);\n    pattern = abs(pattern) * 0.5 + 0.5;\n    pattern = 1.0 - abs(fract(pattern * 2.0 - 0.5) - 0.5);\n    \n    // Generate HSL color based on UV coordinates and time\n    vec3 hslColor = vec3(length(uv) * 0.5 + 0.5, 1.0, 0.8);\n    hslColor.x += iTime;\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise for texture\n    float noiseValue = noise(uv * 100.0) * 0.1;\n    \n    // Combine pattern and color, add noise\n    vec3 finalColor = rgbColor * (pattern + noiseValue);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_876.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base pattern using UV coordinates and time\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Add warping effect using noise and turbulence\n    st += noise(st + iTime * 0.5) * 0.3;\n    st += turbulent(vec3(st, iTime)) * 0.1;\n    \n    // Create color variations using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(length(uv) * 10.0 + iTime * 2.0, 1.0),\n        0.7,\n        0.5\n    ));\n    \n    // Add glow effect based on distance from center\n    float glow = exp(-length(uv - vec2(0.5)) * 4.0);\n    color *= glow;\n    \n    // Combine multiple layers for more complex pattern\n    vec2 st2 = uv * 3.0 + iTime * 0.5;\n    st2 += noise(st2) * 0.2;\n    st2 += turbulent(vec3(st2, iTime)) * 0.1;\n    \n    // Add second color layer\n    vec3 color2 = hsl2rgb(vec3(\n        mod(length(uv - vec2(0.5)) * 8.0 + iTime * 3.0, 1.0),\n        0.6,\n        0.4\n    ));\n    \n    // Combine both layers with some blending\n    color = mix(color, color2, 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_877.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for a denser pattern\n    vec2 st = uv * 10.0;\n    \n    // Create a grid of points\n    vec2 grid = floor(st);\n    \n    // Calculate distance to nearest node\n    vec2 distToNode = fract(st);\n    float minDist = min(distToNode.x, distToNode.y);\n    minDist = min(minDist, 1.0 - distToNode.x);\n    minDist = min(minDist, 1.0 - distToNode.y);\n    \n    // Create pulsing effect using time and noise\n    float pulse = sin(iTime * 2.0 + noise(vec3(grid, iTime))) * 0.5 + 0.5;\n    \n    // Calculate glow intensity\n    float glow = exp(-minDist * 10.0);\n    \n    // Create web lines by checking proximity to connecting points\n    vec2 neighborDist = min(abs(fract(st) - 0.5), 1.0 - abs(fract(st) - 0.5));\n    float lineIntensity = exp(-length(neighborDist) * 10.0);\n    \n    // Combine node glow and web lines\n    float intensity = glow + lineIntensity;\n    \n    // Create pulsing color\n    vec3 color = hsl2rgb(vec3(\n        pulse * 0.6,   // Hue\n        0.7,          // Saturation\n        0.5 + pulse*0.5 // Lightness\n    ));\n    \n    // Apply intensity to color\n    color *= intensity;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_878.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate UV coordinates over time\n    float t = iTime * 0.5;\n    vec2 rotatedUV = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create hexagonal pattern using polar coordinates\n    vec2 polar = rotatedUV * 4.0; // Scale for better visibility\n    float r = length(polar);\n    float theta = atan2(polar.y, polar.x);\n    \n    // Calculate sector in hexagonal grid\n    float sector = mod(theta * 6.0 / PI, 2.0) - 1.0;\n    \n    // Dynamic color based on time and position\n    vec3 color = hsl2rgb(vec3(\n        (sector + sin(r + t)) * 0.5 + 0.5,\n        0.7 + 0.3*sin(t*2.0),\n        0.8 + 0.2*cos(t*1.5)\n    ));\n    \n    // Add noise and turbulence\n    float noiseValue = noise(rotatedUV * 4.0);\n    float turbulentValue = turbulent(rotatedUV * 2.0 + t);\n    \n    // Combine elements for final color\n    color *= mix(0.8, 1.0, noiseValue);\n    color += vec3(turbulentValue * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_879.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate the grid pattern over time\n    float time = iTime * 0.5;\n    \n    // Create a tiling pattern with diagonal movement\n    vec2 st = uv * 10.0 + time;\n    st.x += sin(st.y * 0.5 + time) * 2.0;\n    st.y += cos(st.x * 0.5 - time) * 2.0;\n    \n    // Create diagonal grid lines with movement\n    float dx = abs(sin(st.x + st.y)) * 0.5;\n    float dy = abs(cos(st.x - st.y)) * 0.5;\n    \n    // Add turbulence for shimmer effect\n    vec3 noise1 = vec3(turbulent(vec2(st.x, time)), turbulent(vec2(time, st.y)), 0.0);\n    vec3 noise2 = vec3(turbulent(vec2(st.y, time)), turbulent(vec2(time, st.x)), 0.0);\n    \n    // Combine patterns and add color\n    float pattern = (dx + dy) * 0.5;\n    pattern += (noise1.x + noise2.x) * 0.3;\n    \n    // Create shifting hues using HSL\n    vec3 color = hsl(pattern * 0.6 + 0.3, 0.8, 0.6);\n    color *= sin(time * 0.5 + pattern * pi) * 0.5 + 0.5;\n    \n    // Output the final color with some contrast\n    return vec4(color * (1.0 - abs(pattern - 0.5)) * 2.0, 1.0);\n}"
  },
  "data_88.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float scale = 50.0;\n    vec3 col = vec3(0.0);\n    \n    // Base noise pattern\n    float n = noise(uv * scale + iTime);\n    \n    // Add turbulence at different scales\n    float t1 = turbulent(uv * scale + iTime);\n    float t2 = turbulent(uv * (scale * 0.5) + iTime * 0.5);\n    float t3 = turbulent(uv * (scale * 0.25) + iTime * 0.25);\n    \n    // Combine noise and turbulence\n    col += hsl2rgb(vec3(\n        n * 0.5 + 0.5,\n        (t1 + t2 + t3) * 0.333,\n        0.7\n    ));\n    \n    // Add geometric pattern\n    float angle = atan2(uv.y, uv.x);\n    float dist = length(uv);\n    float geo = sin(dist * 5.0 + iTime) * sin(angle * 4.0);\n    col += vec3(geo * 0.5 + 0.5);\n    \n    // Final color with mix of noise and geometry\n    col = (col + vec3(n, t1, t2)) * 0.5;\n    \n    return vec4(col, 1.0);\n}"
  },
  "data_880.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a flowing plasma effect with noise and RGB shifts\n    \n    // Animate based on time\n    float t = iTime * 0.5;\n    \n    // Generate base color using noise patterns\n    vec3 color = vec3(\n        noise(uv + vec2(t, t*0.7)),\n        noise(uv + vec2(t*0.6, t*1.2) + vec2(1.0)),\n        noise(uv + vec2(t*0.8, t*0.9) + vec2(0.5))\n    );\n    \n    // Add turbulence for more detail\n    color += vec3(\n        turbulent(uv * 4.0 + t),\n        turbulent(uv * 6.0 - t),\n        turbulent(uv * 8.0 + t*0.5)\n    ) * 0.5;\n    \n    // Convert to HSL for better color control\n    vec3 hslColor = hsl(\n        mod(length(color) * 2.0 + t, 1.0), \n        0.7,\n        0.6\n    );\n    \n    // Shift RGB channels differently\n    vec3 rgbShifted = hsv2rgb(vec3(\n        hslColor.x + sin(t*0.5),\n        hslColor.y * 0.8,\n        hslColor.z * 1.2\n    ));\n    \n    // Add flowing animation\n    float flow = sin(uv.x * 4.0 + t) * cos(uv.y * 3.0 + t);\n    rgbShifted += vec3(flow * 0.5, flow * 0.3, flow * 0.2);\n    \n    return vec4(rgbShifted, 1.0);\n}"
  },
  "data_881.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates and add rotation\n    vec2 st = uv - 0.5;\n    float time = iTime * 0.5;\n    \n    // Apply rotation matrix\n    mat2 rot = mat2(cos(time), sin(time), \n                    -sin(time), cos(time));\n    vec2 rotated = rot * st;\n    \n    // Calculate distance from center and add noise\n    float dist = length(rotated);\n    float n = noise(vec2(uv.x*5.0, uv.y*5.0) + time);\n    \n    // Create geometric pattern using polar coordinates\n    float angle = atan(rotated.y, rotated.x);\n    float radius = length(st);\n    \n    // Dynamic color transitions using HSL\n    vec3 hslColor = vec3(angle * 180.0 / PI + time * 50.0, \n                         abs(sin(time)) * 0.7 + 0.3,\n                         abs(cos(time)) * 0.6 + 0.4);\n    \n    // Convert HSL to RGB and mix with noise\n    vec3 color = hsl2rgb(hslColor) * (1.0 - n * 0.5);\n    \n    // Add geometric pattern overlay\n    float pattern = sin(radius * 8.0 + time) * 0.5 + 0.5;\n    color *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), pattern);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_882.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a pulsing scale factor\n    float pulse = sin(iTime * 0.5 + 1.0) * 0.3 + 0.7;\n    \n    // Scale and offset coordinates for the network pattern\n    vec2 st = uv * 8.0 * pulse;\n    \n    // Create a grid of points with noise variation\n    vec2 grid = fract(st - 0.5);\n    vec2 center = vec2(0.5, 0.5);\n    \n    // Calculate distance to neighboring points in four directions\n    float d1 = length(grid - center + vec2(-1.0, 0.0));\n    float d2 = length(grid - center + vec2(1.0, 0.0));\n    float d3 = length(grid - center + vec2(0.0, -1.0));\n    float d4 = length(grid - center + vec2(0.0, 1.0));\n    \n    // Combine distances and add noise for variation\n    float lines = min(d1, d2) + min(d3, d4);\n    lines += turbulent(st * 0.5 + iTime) * 0.2;\n    \n    // Create a color that shifts with time\n    vec3 color = hsl2rgb(vec3(0.6 + iTime * 0.1, 1.0, 0.8));\n    \n    // Generate the final effect by combining lines and color\n    float glow = max(0.0, 1.0 - length(grid - center) * 4.0);\n    vec3 finalColor = mix(vec3(0.0), color, glow);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_883.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 centered = uv - 0.5;\n    float r = length(centered);\n    float theta = atan2(centered.y, centered.x);\n    \n    // Add time-based rotation\n    theta += 0.5 * iTime;\n    \n    // Create rotating sine wave patterns with dynamic RGB shifts\n    vec3 color = vec3(\n        sin(theta + r * 8.0 + iTime) * 0.5 + 0.5,\n        sin(theta + r * 8.0 - iTime) * 0.5 + 0.5,\n        sin(theta + r * 8.0 + 2.0*iTime) * 0.5 + 0.5\n    );\n    \n    // Add some complexity to the pattern\n    color += vec3(\n        pow(sin(4.0*theta + iTime), 2.0) * 0.2,\n        pow(sin(4.0*theta - iTime), 2.0) * 0.2,\n        pow(sin(4.0*theta + 2.0*iTime), 2.0) * 0.2\n    );\n    \n    // Add some noise for dynamic shifts\n    float noiseVal = turbulent(uv * 8.0 + iTime);\n    color += noiseVal * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_884.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-based rotation\n    float angle = iTime * 0.5;\n    vec2 rotatedUV = uv - 0.5;\n    rotatedUV = vec2(\n        cos(angle) * rotatedUV.x - sin(angle) * rotatedUV.y,\n        sin(angle) * rotatedUV.x + cos(angle) * rotatedUV.y\n    );\n    rotatedUV += 0.5;\n    // Create pattern using cosine waves at different frequencies\n    float pattern = 0.0;\n    pattern += cos(iTime + length(rotatedUV * 4.0)) * 0.3;\n    pattern += cos(iTime + length(rotatedUV * 8.0 - vec2(1,1))) * 0.3;\n    pattern += cos(iTime + length(rotatedUV * 16.0 - vec2(2,2))) * 0.3;\n    // Convert to RGB with smooth color transitions\n    vec3 color = hsl(\n        fract((pattern + iTime * 0.1) / 2.0),\n        0.7,\n        0.5 + pattern * 0.2\n    );\n    // Add noise for texture\n    float noiseValue = noise(rotatedUV * 4.0);\n    color *= 1.0 + noiseValue * 0.3;\n    return vec4(color, 1.0);\n}"
  },
  "data_885.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating patterns using polar coordinates\n    vec2 centered = uv - 0.5;\n    float radius = length(centered);\n    float angle = atan2(centered.y, centered.x) + iTime * 0.5;\n    \n    // Add noise and turbulence for dynamic effects\n    float n = noise(vec3(uv * 10.0, iTime));\n    float t = turbulent(vec2(radius * 10.0, angle * 10.0 + iTime));\n    \n    // Create geometric patterns with color shifts\n    vec3 baseColor = hsl(180.0, 1.0, 0.5); // Cyan base color\n    \n    // Combine shapes and colors\n    float pattern = sin(radius * 20.0 + iTime) * cos(angle * 4.0);\n    pattern += n * t;\n    \n    // Add geometric transformations\n    vec2 rotatedUV = vec2(\n        uv.x * cos(iTime) - uv.y * sin(iTime),\n        uv.x * sin(iTime) + uv.y * cos(iTime)\n    );\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 finalColor = hsl2rgb(vec3(\n        180.0 + sin(iTime * 0.5) * 90.0,\n        1.0 - abs(sin(iTime)),\n        0.5 + t * 0.2\n    ));\n    \n    // Mix patterns and colors\n    float shape = smoothstep(0.4, 0.6, radius);\n    shape += pattern * 0.3;\n    \n    finalColor *= mix(vec3(1.0), vec3(0.5), shape);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_886.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Distance from center\n    float d = length(st);\n    \n    // Polar coordinates\n    vec2 polar = vec2(length(st), atan2(st.y, st.x));\n    \n    // Add time-based rotation\n    polar.y += iTime * 0.5;\n    \n    // Create base pattern with noise\n    float n1 = turbulent(polar * 4.0 + vec2(iTime)) * 0.5 + 0.5;\n    float n2 = noise(vec3(polar * 8.0, iTime * 0.2));\n    float n3 = turbulent(polar * 16.0) * 0.5 + 0.5;\n    \n    // Combine noise layers\n    float pattern = (n1 + n2 * 0.7 + n3 * 0.4);\n    \n    // Create color transitions\n    vec3 color1 = hsl2rgb(vec3(0.5 + pattern * 0.4, 0.8, 0.6));\n    vec3 color2 = hsl2rgb(vec3(0.2 + pattern * 0.6, 0.7, 0.7));\n    \n    // Mix colors based on noise\n    vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, n2 * 0.5 + 0.5));\n    \n    // Add pulsing effect\n    float pulse = sin(iTime) * 0.2 + 0.8;\n    finalColor *= (1.0 - d * 0.7) * pulse;\n    \n    // Add specular highlights\n    vec3 lightDir = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n    float spec = pow(max(dot(normalize(vec3(st, 0.5)), lightDir), 0.0), 20.0);\n    finalColor += vec3(1.0) * spec * 0.4;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_887.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate UV coordinates over time\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create layered noise patterns\n    float n1 = noise(st);\n    float n2 = turbulent(st * 0.5 + 100.0);\n    float n3 = turbulent(st * 0.25 + 200.0);\n    \n    // Combine noise layers with different frequencies\n    float pattern = (n1 + n2 * 0.5 + n3 * 0.25) * 0.5 + 0.5;\n    \n    // Create flowing color shifts using HSL\n    vec3 color = hsl(\n        sin(st.x * 0.5 + iTime) * 0.5 + 0.5,  // Hue variation\n        cos(st.y * 0.5 - iTime) * 0.5 + 0.75,  // Saturation\n        pattern                                   // Lightness from noise\n    );\n    \n    // Add depth with polar coordinates\n    vec2 polar = vec2(\n        length(uv),\n        atan2(uv.y, uv.x)\n    );\n    \n    // Final color transformation\n    color *= hsl2rgb(vec3(\n        sin(iTime * 0.5) + 0.5,\n        1.0,\n        pattern\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_888.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    // Create rotating hexagonal pattern\n    theta *= 6.0; // Hexagon has six sides\n    theta += iTime * 2.0; // Rotate over time\n    \n    // Calculate distance from center of hexagons\n    float d = abs(sin(theta)) * 0.5 + 0.5;\n    d = (1.0 - d) / r;\n    // Color transitions using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        mod(r * 100.0 + iTime, 1.0), // Hue variation based on position and time\n        0.7, // Saturation\n        0.5 + 0.5 * sin(iTime) // Pulsating lightness\n    ));\n    // Apply noise for additional texture\n    float noiseVal = turbulent(vec3(uv * 100.0, iTime));\n    color *= 1.0 + noiseVal * 0.2;\n    return vec4(color * d, 1.0);\n}"
  },
  "data_889.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base liquid metal color with dark blue/purple hues\n    vec3 baseColor = hsl(240.0, 0.8, 0.1);\n    \n    // Add dynamic ripples using sine waves and noise\n    float timeFactor = iTime * 0.5;\n    float wave1 = sin(uv.x * 6.0 + timeFactor) * 0.5;\n    float wave2 = sin(uv.y * 6.0 - timeFactor) * 0.5;\n    float noiseValue = noise(vec3(uv * 4.0, iTime)) * 0.3;\n    \n    // Create turbulence effect for flowing movement\n    vec2 turbulentUV = uv + vec2(turbulent(uv * 10.0 + timeFactor), turbulent(uv * 10.0 - timeFactor)) * 0.05;\n    float flow = sin(length(turbulentUV) * 8.0 - iTime * 4.0) * 0.3;\n    \n    // Combine wave effects\n    float ripple = (wave1 + wave2 + noiseValue + flow) * 0.5 + 0.5;\n    \n    // Add highlight/reflection effect\n    vec2 reflectUV = uv - vec2(0.5, 0.5);\n    float reflection = sin(length(reflectUV) * 8.0 - iTime * 4.0) * 0.3 + 0.7;\n    vec3 highlightColor = hsl(60.0, 0.8, 0.5); // Bright yellow-orange\n    \n    // Combine all effects\n    vec3 finalColor = mix(baseColor, highlightColor, reflection);\n    finalColor *= ripple * 1.5; // Add intensity variation\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_89.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 p = uv * 0.1 + vec2(sin(iTime * 0.5), cos(iTime * 0.3));\n    vec2 q = uv * 0.1 + vec2(cos(iTime * 0.7), sin(iTime * 0.4));\n    \n    float noiseX = noise(p);\n    float noiseY = noise(q);\n    \n    vec3 color = hsv2rgb(vec3(\n        mod(noiseX * 5.0 + iTime * 0.1, 1.0),\n        0.7 + noiseY * 0.3,\n        0.8\n    ));\n    \n    float t = turbulent(vec2(noiseX * 10.0, noiseY * 10.0));\n    color *= vec3(0.5 + t * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_890.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and rotate UV coordinates over time\n    vec2 st = uv - 0.5;\n    float angle = iTime * 0.1;\n    st = vec2(\n        st.x * cos(angle) - st.y * sin(angle),\n        st.x * sin(angle) + st.y * cos(angle)\n    ) + 0.5;\n    // Create a dynamic noise pattern with time\n    vec3 pos = vec3(st, iTime * 0.1);\n    float noiseVal = turbulent(pos * 4.0);\n    // Calculate color components using HSL\n    vec3 colorHSL;\n    colorHSL.x = fract(noiseVal * 0.5 + iTime * 0.2); // Hue variation over time\n    colorHSL.y = 0.7; // Saturation\n    colorHSL.z = 0.5 + noiseVal * 0.3; // Lightness modulation\n    // Add lighting effect using another noise layer\n    float light = noise(st * 2.0 + iTime) * 0.4;\n    colorHSL.z += light;\n    // Convert HSL to RGB and return\n    vec3 finalColor = hsl2rgb(colorHSL);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_891.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base star field using noise\n    float stars = noise(uv * 10.0);\n    \n    // Add pulsing animation with time\n    float pulse = sin(iTime + stars * 5.0) * 0.5 + 0.5;\n    \n    // Combine noise and pulse for brightness variation\n    float brightness = (stars + pulse) * 0.5;\n    \n    // Add turbulence for more dynamic movement\n    brightness += turbulent(uv * 100.0) * 0.3;\n    brightness += turbulent(uv * 200.0) * 0.2;\n    \n    // Create color variation using HSV to RGB conversion\n    vec3 color = hsv2rgb(vec3(\n        iTime * 0.5 + stars * 2.0,\n        0.7 + brightness * 0.3,\n        brightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_892.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates\n    vec2 polar = uv - 0.5;\n    float radius = length(polar);\n    float angle = atan(polar.y, polar.x);\n    \n    // Create pulsing effect with time\n    float pulse = sin(iTime * 0.5 + radius * 10.0) * 0.2 + 0.8;\n    radius *= pulse;\n    \n    // Animate rotation speed\n    angle += iTime * 3.0;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(angle / (2.0 * PI) + iTime * 0.1),  // Hue\n        0.7 + sin(radius * 5.0 + iTime * 2.0) * 0.2,  // Saturation\n        0.5 + cos(radius * 3.0 + iTime) * 0.4  // Lightness\n    );\n    \n    // Convert to RGB and add noise for texture\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor += noise(vec3(uv * 10.0, iTime)) * 0.1;\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_893.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Calculate distance from center\n    float dist = length(uv);\n    \n    // Create pulsating effect using time\n    float pulse = sin(iTime * 2.0) * 0.5;\n    \n    // Combine distance and pulse for ring pattern\n    float ring = mod(dist + pulse, 0.1) * 10.0;\n    \n    // Calculate color based on distance and time\n    vec3 color = hsl(\n        sin(iTime) + dist * 2.0,\n        0.7,\n        0.5\n    );\n    \n    // Add pulsing effect to color\n    color *= 1.0 + sin(ring * pi + iTime) * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_894.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of triangles by scaling and tiling the UV coordinates\n    vec2 st = fract(uv * 10.0);\n    \n    // Calculate triangle rotation using sine and cosine functions\n    vec2 center = vec2(0.5, 0.5);\n    vec2 offset = st - center;\n    float angle = atan(offset.y, offset.x) + sin(iTime) * 0.5;\n    \n    // Generate color based on rotating angle and noise\n    vec3 color = hsl(angle / (pi * 2.0), 1.0, 0.5);\n    color *= mix(0.8, 1.0, noise(vec3(st, iTime)));\n    \n    // Add turbulence effect to create dynamic patterns\n    float turb = turbulent(vec2(st.x + iTime*0.1, st.y));\n    color += vec3(turb * 0.5);\n    \n    // Brightness and contrast adjustments\n    color = mix(vec3(0.0), color, 1.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_895.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 2.0 + iTime;\n    \n    // Create two perpendicular sine waves with different frequencies\n    float wave1 = sin(st.x * 3.0 - iTime * 2.0);\n    float wave2 = cos((st.y + iTime) * 3.0);\n    \n    // Combine waves and add turbulence\n    float combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(st * 4.0 + vec2(iTime)) * 0.3;\n    \n    // Create rotating color gradient using HSL\n    vec3 color = hsl(\n        mod((st.x + st.y + iTime * 0.5), 1.0),\n        0.7,\n        0.6\n    );\n    \n    // Mix colors based on wave pattern\n    vec3 finalColor = mix(vec3(0.1, 0.2, 0.3), color, abs(combined) * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_896.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing liquid metal effect using noise and turbulence\n    \n    // Add time-based offset to create movement\n    vec2 st = uv * 5.0 + vec2(iTime * 0.5, iTime * 0.3);\n    \n    // Use turbulent noise for organic patterns\n    float noise1 = turbulent(st);\n    float noise2 = turbulent(st * 2.0 + vec2(1.0));\n    \n    // Create color shifts using HSL\n    vec3 colorBase = hsl2rgb(vec3(0.5 + noise1 * 0.4, 0.8, 0.6));\n    vec3 colorShift = hsl2rgb(vec3(0.5 + noise2 * 0.4, 0.8, 0.6));\n    \n    // Combine colors with some metallic sheen\n    vec3 finalColor = mix(colorBase, colorShift, sin(uv.x * 10.0 + iTime) * 0.5 + 0.5);\n    \n    // Add lighting effect\n    vec3 lightDir = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n    float light = dot(normalize(vec3(noise(st), noise(st*2.0), 1.0)), lightDir) * 0.5 + 0.5;\n    \n    // Add edge detection for liquid effect\n    float edge = length(uv);\n    finalColor *= (1.0 - smoothstep(0.8, 1.0, edge)) * 0.7 + 0.3;\n    \n    return vec4(finalColor * light, 1.0);\n}"
  },
  "data_897.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base sine wave pattern with varying frequency and phase\n    float speed = 0.5;\n    float freq1 = 3.0;\n    float freq2 = 6.0;\n    \n    vec2 st = uv * 8.0; // Scale UV coordinates\n    \n    // Moving sine waves with different frequencies and phases\n    float wave1 = sin(st.x * freq1 + iTime * speed) * 0.5 + 0.5;\n    float wave2 = sin(st.y * freq2 + iTime * speed + PI/2.0) * 0.5 + 0.5;\n    \n    // Combine waves and add noise for complexity\n    float value = (wave1 + wave2) * 0.5;\n    value += turbulent(vec3(uv, iTime)) * 0.3; // Add depth with turbulence\n    \n    // Create color shifts based on depth\n    vec3 color = hsl(value * 360.0, 0.7, 0.5);\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_898.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create rotating sine waves with increasing frequency\n    float wave1 = sin(r * 4.0 + a * 3.0) * 0.5;\n    float wave2 = sin(r * 8.0 - a * 2.0) * 0.3;\n    \n    // Add noise and turbulence for more organic feel\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseVal = noise(noiseUV);\n    float turbulentVal = turbulent(vec2(r, a));\n    \n    // Combine waves with noise and turbulence\n    float pattern = wave1 + wave2 + noiseVal * 0.3 + turbulentVal * 0.2;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 colorBase = hsl(a * 0.5 + iTime, 0.7, 0.6);\n    vec3 colorVar = hsl(r * 0.5 + iTime * 0.3, 0.8, 0.7);\n    \n    // Combine colors based on pattern\n    vec3 finalColor = mix(colorBase, colorVar, abs(pattern) * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_899.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create pulsing effect with time\n    float pulse = sin(iTime * 2.0 + r * 4.0) * 0.5 + 0.5;\n    float turbulence = turbulent(vec3(r, iTime, 0)) * 0.1;\n    // Combine pulsing and turbulence for dynamic radius\n    float finalRadius = r * (pulse + turbulence);\n    // Create color shifts using HSL to RGB conversion\n    vec3 baseColor = hsl2rgb(vec3(0.5 + sin(iTime * 0.1), 1.0, 0.5));\n    vec3 accentColor = hsl2rgb(vec3(0.5 + sin(r * 2.0), 1.0, 0.5));\n    // Mix colors based on radius and add noise texture\n    vec3 color = mix(baseColor, accentColor, smoothstep(0.0, 1.0, finalRadius));\n    color *= noise(vec2(st.x * 4.0, st.y * 4.0)) * 0.5 + 0.5;\n    return vec4(color, 1.0);\n}"
  },
  "data_9.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 5.0 + iTime;\n    \n    // Create multi-layered noise patterns\n    float n1 = noise(st);\n    float n2 = noise(st * 2.0 + iTime);\n    float n3 = noise(st * 4.0 + iTime * 0.5);\n    \n    // Add turbulence for more dynamic movement\n    float turb = turbulent(st + iTime) * 0.5;\n    \n    // Combine patterns with time-based variation\n    float pattern = (n1 + n2 + n3 + turb) * 0.25;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(pattern + iTime * 0.1),   // Hue\n        0.8,                            // Saturation\n        0.5 + n3 * 0.4                  // Lightness\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_90.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate position over time\n    vec2 pos = uv * 5.0 + iTime;\n    \n    // Create flowing pattern using turbulence\n    float t1 = turbulent(pos);\n    float t2 = turbulent(pos + vec2(1.0, 1.0));\n    \n    // Combine turbulence values for color variation\n    float colorMix = (t1 + t2 * 0.5) * 0.5;\n    \n    // Create base color using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.1 + pos.x * 0.5),\n        0.7,\n        0.5 + 0.5 * sin(iTime * 2.0 + pos.y)\n    );\n    \n    // Convert to RGB and mix with turbulence\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= 0.5 + 0.5 * colorMix;\n    \n    // Add flowing movement using noise\n    float flow = noise(vec3(pos, iTime));\n    flow = 0.5 + 0.5 * sin(flow * pi + iTime);\n    \n    // Combine all elements for final color\n    vec3 finalColor = rgbColor * flow;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_900.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = (uv - 0.5) * 3.0 + iTime;\n    \n    // Create two perpendicular sine wave patterns with time offset\n    float wave1 = sin(st.x * 5.0 + iTime * 2.0) * 0.5 + 0.5;\n    float wave2 = sin(st.y * 5.0 + iTime * -2.0) * 0.5 + 0.5;\n    \n    // Add noise texture\n    vec2 noiseScale = st * 4.0;\n    float noise1 = turbulent(noiseScale);\n    float noise2 = turbulent(noiseScale + 100.0);\n    \n    // Combine waves and noise\n    float effect = (wave1 + wave2 + noise1 + noise2) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        mod(iTime * 0.1 + st.x, 1.0),   // Hue variation over time and space\n        0.7 + noise2 * 0.3,             // Saturation modulation\n        0.5 + effect * 0.5              // Lightness based on wave pattern\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_901.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid of cells\n    vec2 st = fract(uv * 10.0);\n    vec2 center = floor(st * 10.0 + 0.5) / 10.0;\n    \n    // Calculate distance from center with rotation\n    float time = iTime * 0.5;\n    vec2 pos = st - center;\n    float angle = sin(time + center.x * pi) + cos(center.y * pi);\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedPos = rot * pos;\n    \n    // Create circular pattern with turbulence\n    float dist = length(rotatedPos);\n    float t = turbulent(st * 5.0 + time) * 0.5 + 0.5;\n    float circle = step(dist, 0.4 + t * 0.2);\n    \n    // Dynamic color shifts using HSL\n    vec3 color1 = hsl2rgb(vec3(0.6 + sin(time + center.x * pi) * 0.3, 0.8, 0.5));\n    vec3 color2 = hsl2rgb(vec3(0.2 + cos(time + center.y * pi) * 0.3, 0.7, 0.6));\n    vec3 finalColor = mix(color1, color2, t);\n    \n    // Add noise texture overlay\n    vec2 noiseUV = st * 5.0 + time;\n    float n = noise(noiseUV) * 0.3;\n    finalColor *= 1.0 + n;\n    \n    return vec4(finalColor * circle, 1.0);\n}"
  },
  "data_902.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation effect\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Create rotating sine wave pattern with time-based frequency\n    float wave = sin(angle + iTime) * 4.0;\n    wave += sin(radius * 8.0 - iTime * 3.0);\n    \n    // Add noise and turbulence for more dynamic effect\n    vec2 noiseUV = uv + vec2(iTime, 0.0);\n    float n = noise(noiseUV * 10.0) * 0.5;\n    wave += turbulent(vec3(uv * 4.0, iTime)) * 0.3;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(wave * 0.2 + 0.5, 0.7, 0.6);\n    color = hsl2rgb(color);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_903.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create rotating hexagonal pattern\n    float time = iTime * 0.5;\n    float angle = a + time;\n    \n    // Multiple layers of rotation\n    float layer1 = sin(6.0 * (angle - time)) * 0.5 + 0.5;\n    float layer2 = sin(12.0 * (angle - time * 2.0)) * 0.3 + 0.7;\n    \n    // Combine layers with noise\n    vec2 noiseUV = uv * 10.0 + time;\n    float noiseVal = noise(noiseUV);\n    \n    // Color transitions using HSL\n    vec3 color1 = hsl2rgb(vec3(0.5 + 0.5*sin(time), 1.0, 0.8));\n    vec3 color2 = hsl2rgb(vec3(0.5 + 0.5*cos(time), 1.0, 0.6));\n    \n    // Mix colors and noise\n    vec3 finalColor = mix(color1, color2, layer1);\n    finalColor *= layer2;\n    finalColor += noiseVal * 0.2;\n    \n    // Smooth edges\n    float edge = smoothstep(0.8, 1.0, r);\n    finalColor = mix(vec3(0.0), finalColor, edge);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_904.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color with HSL values\n    vec3 color = hsl(0.5, 0.5, 0.5);\n    \n    // Calculate distance from center\n    vec2 pos = uv - 0.5;\n    float dist = length(pos);\n    \n    // Create pulsating circles using sine wave and time\n    float pulse = sin(iTime * 2.0 + dist * 10.0) * 0.5 + 0.5;\n    float scale = 1.0 + pulse * 0.5;\n    \n    // Add noise to create dynamic variations\n    vec3 noiseVal = vec3(noise(uv * 10.0 + iTime), \n                        noise(uv * 10.0 + iTime + 123.456),\n                        noise(uv * 10.0 + iTime + 678.901));\n    \n    // Create color transitions using HSL\n    vec3 hslColor = hsl(\n        sin(iTime * 0.5 + dist * 5.0) * 0.5 + 0.5,   // Hue variation\n        0.7 + noiseVal.x * 0.2,                       // Saturation\n        0.6 + noiseVal.y * 0.2                        // Lightness\n    );\n    \n    // Combine colors and apply turbulence\n    color = mix(color, hslColor, turbulent(uv * scale + iTime));\n    \n    // Add pulsating effect to the final color\n    color *= (1.0 - abs(sin(iTime))) * 0.5 + 0.7;\n    \n    return vec4(pow(color, vec3(0.5)), 1.0);\n}"
  },
  "data_905.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 uv_centered = uv - 0.5;\n    float radius = length(uv_centered);\n    float angle = atan2(uv_centered.y, uv_centered.x);\n    // Add time-based rotation\n    angle += sin(iTime * 0.5) + iTime;\n    // Create interlocking gear-like pattern\n    float segments = 16.0;\n    float gear = abs(sin(angle * segments + iTime)) * 0.5 + 0.5;\n    gear *= radius < 0.8 ? 1.0 : 0.0; // Keep within bounds\n    // Add turbulence and noise\n    vec3 noise_input = vec3(uv_centered.x, uv_centered.y, iTime);\n    float turbulence = turbulent(noise_input * 2.0) * 0.5 + 0.5;\n    \n    // Combine patterns\n    float pattern = gear * (1.0 - turbulence);\n    // Color based on angle and time\n    vec3 color = hsl2rgb(vec3(\n        fract(angle / (2.0 * PI) + iTime * 0.2) * 360.0,\n        0.7,\n        0.5\n    ));\n    // Mix with background\n    vec3 final_color = mix(vec3(0.1), color, pattern);\n    return vec4(final_color, 1.0);\n}"
  },
  "data_906.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Create rotating hexagonal pattern using polar coordinates\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create hexagonal grid effect\n    float hexPattern = sin(angle * 6.0); // 6 points for hexagon\n    float distanceFromCenter = abs(radius - 0.5 * (1.0 + sin(iTime))); // Pulsating radius\n    \n    // Combine pattern and distance to create final color\n    vec3 color = hsl2rgb(vec3(\n        0.5 + 0.5 * sin(angle + iTime), // Hue that changes over time\n        0.8, // Saturation\n        0.5 + 0.5 * (hexPattern * distanceFromCenter) // Lightness based on pattern and distance\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_907.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating hexagonal pattern with pulsing colors\n    vec2 st = uv * 5.0 + iTime; // Scale and animate pattern\n    \n    // Convert to polar coordinates for hexagonal mapping\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Calculate hexagon ring index\n    float hexSize = 0.3;\n    float ring = floor(radius / hexSize);\n    vec2 hexUV = fract(vec2(angle / (pi * 2.0), radius / hexSize));\n    \n    // Create hexagonal pattern with time-based rotation\n    float pattern = sin(hexUV.x * pi * 2.0 + iTime) * cos(hexUV.y * pi * 2.0);\n    \n    // Add noise and turbulence for more dynamic effect\n    vec3 colorBase = hsl(ring * 0.1, 0.7, 0.5);\n    float noiseVal = noise(vec3(uv * 10.0 + iTime, 0.0)) * 0.5;\n    \n    // Combine pattern and noise for final color\n    vec3 finalColor = mix(colorBase, hsl(ring * 0.2 + noiseVal, 0.8, 0.6), pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_908.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base frequency for the pattern\n    float freq = 5.0;\n    \n    // Add some turbulence to create an organic feel\n    vec3 p1 = vec3(uv * freq, iTime);\n    vec3 p2 = vec3(uv * (freq + 1.0), iTime + 1.0);\n    \n    float t1 = turbulent(p1) * 0.5 + 0.5;\n    float t2 = turbulent(p2) * 0.5 + 0.5;\n    \n    // Combine turbulence values\n    float intensity = (t1 + t2) * 0.5;\n    \n    // Create a color that shifts over time and space\n    vec3 colorHSL = vec3(\n        fract(iTime * 0.1 + uv.x * 2.0 + uv.y * 3.0),\n        0.7,\n        intensity * 0.6 + 0.4\n    );\n    \n    // Convert to RGB and add some glow\n    vec3 color = hsl2rgb(colorHSL);\n    \n    // Create a pattern using sine waves with varying frequencies\n    float pattern = sin(uv.x * freq * pi) + cos(uv.y * (freq + 1.0) * pi);\n    pattern += sin(iTime * 0.5) * 0.5;\n    \n    // Normalize pattern to 0-1 range and combine with intensity\n    pattern = (pattern * 0.5 + 0.5) * intensity;\n    \n    // Final color with glow effect\n    vec3 finalColor = color * pattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_909.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv);\n    \n    // Add time-based rotation\n    theta += 3.0 * iTime; // Rotate at 3 radians per second\n    \n    // Create interference pattern using sine functions\n    float pattern1 = sin(theta) * sin(r * 5.0 + iTime * 2.0);\n    float pattern2 = sin(theta * 2.0 + pi) * sin(r * 10.0 - iTime * 3.0);\n    \n    // Combine patterns with time modulation\n    float intensity = (pattern1 + pattern2) * 0.5;\n    intensity *= sin(iTime * 0.5 + r * 2.0); // Add pulsing effect\n    \n    // Create color from HSL values\n    vec3 color = hsl(\n        mod(theta / pi, 2.0), // Hue based on angle\n        1.0 - abs(intensity) * 0.5, // Saturation modulation\n        0.5 + intensity * 0.5 // Lightness modulation\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_91.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a position based on UV coordinates and time\n    vec3 pos = vec3(uv * 10.0 + sin(iTime), iTime * 5.0);\n    \n    // Add some movement to the position\n    pos.xy += vec2(sin(pos.z * 0.5) * 2.0, cos(pos.z * 0.5) * 2.0);\n    \n    // Convert to polar coordinates for interesting patterns\n    vec2 polar = vec2(length(pos.xy), atan2(pos.y, pos.x));\n    \n    // Create a base color using HSL\n    vec3 color = hsl(polar.y / (pi * 2.0) + iTime * 0.1,\n                     0.6 + turbulent(polar) * 0.4,\n                     0.5 + sin(iTime) * 0.5);\n    \n    // Add some noise and turbulence\n    float t = turbulent(pos * 0.5);\n    color *= hsv2rgb(vec3(sin(iTime) + polar.y / (pi * 2.0), 1.0, 1.0)) * (0.5 + t * 0.5);\n    \n    // Add some depth\n    color += vec3(turbulent(pos.xz * 0.5) * 0.5,\n                 turbulent(pos.yz * 0.5) * 0.5,\n                turbulent(pos.xy * 0.5) * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_910.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    // Create undulating ripples using sine waves with time-based modulation\n    float distance = length(uv - 0.5);\n    float wave1 = sin(distance * 8.0 + iTime * 4.0) * 0.5;\n    float wave2 = sin(distance * 16.0 + iTime * 3.0) * 0.3;\n    float wave3 = sin(distance * 32.0 + iTime * 2.0) * 0.2;\n    \n    // Combine waves for more complex pattern\n    float ripples = (wave1 + wave2 + wave3) * 0.5 + 0.5;\n    \n    // Create color inversion effect based on proximity to mouse cursor\n    vec2 mousePos = vec2(0.5); // Simulated mouse position for demonstration\n    float proximity = length(uv - mousePos);\n    vec3 invertedColor = 1.0 - color;\n    \n    // Mix colors based on proximity and ripples\n    color = mix(color, invertedColor, smoothstep(0.0, 0.5, proximity));\n    color *= ripples;\n    \n    // Add some turbulence to enhance the effect\n    vec3 turbulence = vec3(turbulent(vec3(uv * 10.0, iTime)));\n    color += turbulence * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_911.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale UV coordinates\n    vec2 st = (uv - 0.5) * 12.0;\n    \n    // Add rotation based on time\n    float angle = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create rotating sine wave pattern\n    float r = length(st);\n    float d = sin(r * 4.0 + angle * 3.0) * cos(angle * 4.0);\n    \n    // Add color shifts using HSL\n    vec3 color = hsl(\n        mod(angle * 2.0 + iTime, 1.0),  // Hue\n        0.7,                             // Saturation\n        0.5 + d * 0.4                   // Lightness with dynamic shift\n    );\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_912.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create concentric circles pattern with pulsing effect\n    float circles = sin(r * 15.0 + iTime * 2.0) * 0.5 + 0.5;\n    \n    // Add turbulence for dynamic patterns\n    vec3 noiseInput = vec3(st.x, st.y, iTime);\n    float turb = turbulent(noiseInput * 0.5);\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        a * 0.1 + iTime * 0.2, // Hue variation over time and angle\n        0.7 + turb * 0.3,      // Saturation with turbulence\n        0.5 + sin(iTime) * 0.5 // Lightness pulsing effect\n    );\n    \n    // Convert HSL to RGB and mix with circles pattern\n    vec3 color = hsl2rgb(hslColor);\n    color *= circles;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_913.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert to polar coordinates for radial pattern\n    float radius = length(uv);\n    float angle = atan2(uv.y, uv.x);\n    \n    // Create multiple layers of sine waves with varying frequencies\n    float layer1 = sin(radius * 16.0 + iTime * 3.0) * 0.5;\n    float layer2 = sin(radius * 8.0 + iTime * 2.0) * 0.3;\n    float layer3 = sin(radius * 4.0 + iTime) * 0.2;\n    \n    // Add noise to create more organic patterns\n    vec2 noiseScale = vec2(100.0, 100.0);\n    float noiseValue = noise(uv * noiseScale + iTime);\n    \n    // Combine layers and add pulsation effect\n    float combined = (layer1 + layer2 + layer3) * 0.5 + noiseValue * 0.3;\n    combined *= sin(iTime * 0.5) * 0.5 + 0.5; // Pulsation\n    \n    // Create color gradient using HSL\n    vec3 hslColor = vec3(\n        (radius * 0.5 + iTime * 0.1) * pi, // Hue variation\n        0.7 + combined * 0.3,             // Saturation\n        0.5 + sin(angle + iTime) * 0.2    // Lightness variation\n    );\n    \n    // Convert to RGB and add glow effect\n    vec3 color = hsl2rgb(hslColor);\n    color += smoothstep(1.0, 0.0, radius) * 0.5;\n    \n    // Add background glow\n    vec3 backgroundColor = hsl2rgb(vec3(iTime * 0.2, 0.2, 0.1));\n    color = mix(backgroundColor, color, smoothstep(1.0, 0.0, radius) * 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_914.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    // Add time-based rotation and hexagonal tiling\n    theta += iTime * 0.5 + 30.0 * pi / 180.0; // Rotate by 30 degrees for hexagon alignment\n    \n    // Create hexagonal grid pattern\n    vec2 tile = vec2(r, theta);\n    float pattern = sin(theta * 6.0) * 0.5 + 0.5;\n    \n    // Add pulsating effect using noise and time\n    float pulse = sin(iTime * 3.0 + r * 10.0) * 0.5 + 0.5;\n    pattern *= mix(0.2, 0.8, pulse);\n    \n    // Use turbulence to add dynamic variations\n    vec3 noisePos = vec3(tile.x, tile.y, iTime * 0.1);\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    pattern += turb * 0.3;\n    // Convert to HSL and then RGB for color transformation\n    vec3 hslColor = vec3(theta / (2.0 * pi), 0.7, mix(0.3, 0.8, pattern));\n    vec3 rgbColor = hsl2rgb(hslColor);\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_915.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates from UV\n    float theta = atan2(uv.y, uv.x);\n    float r = length(uv * 1.5); // Scale radius\n    \n    // Create rotating color wheel effect\n    vec3 colorWheel = hsl2rgb(vec3(theta + iTime, 0.7, 0.5));\n    \n    // Create pulsating rings using sine wave and time\n    float ringEffect = sin(r * 10.0 - iTime * 2.0) * 0.5 + 0.5;\n    \n    // Combine effects with noise for texture\n    vec3 finalColor = mix(colorWheel, \n                         hsl2rgb(vec3(theta + iTime*0.5, 0.8, ringEffect)),\n                         turbulent(uv * 5.0) * 0.4 + 0.6);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_916.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv * 5.0; // Scale coordinates for more variation\n    float turb = turbulent(st + iTime * 0.5); // Add time-based movement\n    \n    // Create particle motion using sine and cosine functions\n    vec2 motion = vec2(sin(iTime * 0.5 + turb), cos(iTime * 0.3 + turb)) * 0.1;\n    \n    // Use noise to generate color variations\n    vec3 color = hsl2rgb(vec3(\n        fract(turb + iTime) * 360.0, // Hue variation over time\n        0.7, // Saturation\n        0.5 // Lightness\n    ));\n    \n    // Add distance attenuation for a more natural look\n    float dist = length(uv - vec2(0.5)) * 2.0;\n    color *= smoothstep(1.0, 0.0, dist);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_917.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color with time-based hue variation\n    vec3 baseColor = hsl(uv.x * 5.0 + sin(iTime) * 2.0, 1.0, 0.5);\n    \n    // Add noise and turbulence for dynamic variations\n    float noiseValue = noise(vec3(uv * 4.0, iTime * 0.5));\n    baseColor += vec3(turbulent(vec3(uv * 8.0, iTime)) * 0.2);\n    \n    // Create sine wave patterns with time animation\n    float sinX = sin(uv.x * pi + iTime) * 0.5 + 0.5;\n    float sinY = sin(uv.y * pi + iTime * 0.7) * 0.5 + 0.5;\n    \n    // Combine noise and sine waves for final color\n    vec3 finalColor = hsl2rgb(baseColor + vec3(sinX, sinY, 0.0));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_918.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create base river shape with smooth edges\n    vec2 pos = uv * 2.0 - 1.0;\n    float riverWidth = 0.8;\n    float riverHeight = 0.3;\n    \n    // Add flowing animation over time\n    float flowSpeed = 0.5;\n    float flowOffset = sin(iTime * flowSpeed) * 0.5;\n    \n    // Create turbulent water effect using noise functions\n    vec2 noisePos = pos + vec2(flowOffset, 0.0);\n    float turbulenceX = turbulent(noisePos * 10.0 + vec2(0.0, iTime)) * 0.3;\n    float turbulenceY = turbulent(noisePos * 10.0 + vec2(iTime, 0.0)) * 0.3;\n    \n    // Create color gradient for the river\n    vec3 riverColor = hsl(\n        (pos.y * 0.5 + 0.5) * 360.0,   // Hue varies vertically\n        0.7 + turbulenceX * 0.2,       // Saturation with noise variation\n        0.4 + turbulenceY * 0.1        // Lightness with noise variation\n    );\n    \n    // Add depth to the river by darkening edges\n    float distanceFromCenter = length(pos.x) / riverWidth;\n    riverColor *= sin(distanceFromCenter * pi + iTime) * 0.5 + 0.5;\n    \n    // Create river boundaries and flow effect\n    vec2 riverBounds = smoothstep(\n        vec2(-riverWidth, -riverHeight), \n        vec2(riverWidth, riverHeight),\n        abs(pos)\n    );\n    \n    // Combine all elements for final output\n    return vec4(hsl2rgb(riverColor) * riverBounds.x * riverBounds.y, 1.0);\n}"
  },
  "data_919.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying wave pattern\n    vec2 st = uv * 5.0 + vec2(1.0, 1.0); // Scale and offset UV coordinates\n    \n    // Add multiple wave layers with different frequencies\n    float wave1 = sin(st.x * 2.0 + iTime) * cos(st.y + iTime);\n    float wave2 = sin(st.x * 3.0 - iTime) * cos(st.y * 2.0 + iTime);\n    \n    // Combine waves and add noise for complexity\n    float combined = (wave1 + wave2) * 0.5;\n    combined += turbulent(vec2(uv * 4.0 + iTime)) * 0.3; // Add turbulence\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        fract(combined * 0.5 + iTime * 0.1), // Hue variation over time\n        0.7, // Saturation\n        0.6 + combined * 0.2 // Vary lightness based on wave pattern\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_92.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Add some noise and turbulence\n    vec3 noiseInput = vec3(r * 10.0, theta * 10.0, iTime * 0.5);\n    float t = turbulent(noiseInput);\n    \n    // Create color variations\n    vec3 color1 = hsl(theta * 0.2 + 0.5, 0.7, 0.6);\n    vec3 color2 = hsl(theta * 0.2 + 0.3, 0.8, 0.4);\n    \n    // Combine colors with turbulence\n    vec3 finalColor = mix(color1, color2, t * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_920.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating coordinate system\n    vec2 st = uv - 0.5;\n    float angle = iTime * 0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotated = rot * st;\n    // Polar coordinates for geometric patterns\n    float r = length(rotated);\n    float theta = atan2(rotated.y, rotated.x);\n    // Create multiple shapes using sine waves with different frequencies\n    float shape1 = sin(theta * 5.0 + iTime) * 0.5;\n    float shape2 = sin(theta * 3.0 - iTime) * 0.7;\n    float shape3 = sin(r * 10.0 + iTime) * 0.3;\n    // Combine shapes and add turbulence\n    float pattern = (shape1 + shape2 + shape3);\n    pattern += turbulent(rotated * 5.0 + vec2(iTime)) * 0.2;\n    \n    // Dynamic color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + theta / (2.0 * PI)),\n        0.7,\n        0.5 + pattern * 0.4\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Add noise for extra detail\n    float noiseValue = noise(rotated * 10.0 + vec2(iTime)) * 0.1;\n    \n    return vec4(rgbColor + noiseValue, 1.0);\n}"
  },
  "data_921.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates and scale them up\n    vec2 st = (uv - 0.5) * 4.0;\n    \n    // Add rotation based on time\n    float angle = sin(iTime * 0.5);\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    mat2 rotMatrix = mat2(cosA, -sinA, sinA, cosA);\n    vec2 rotatedSt = st * rotMatrix;\n    \n    // Create square and circle shapes\n    vec2 square = abs(rotatedSt);\n    float squareDist = min(square.x, square.y);\n    float circleDist = length(rotatedSt);\n    \n    // Combine shapes with some parameters\n    float shape = 0.5 * squareDist + 0.5 * circleDist;\n    shape = smoothstep(0.0, 1.0, 1.0 - shape);\n    \n    // Create animated color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(sin(iTime) * 0.5 + 0.5) * 360.0,\n        0.7,\n        0.8\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise and turbulence for dynamic effect\n    float noiseValue = noise(vec3(uv * 10.0, iTime));\n    float turbulentValue = turbulent(vec3(uv * 5.0, iTime));\n    \n    // Combine all elements for final color\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(0.0),\n        shape + noiseValue * 0.2 + turbulentValue * 0.1\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_922.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for hexagonal pattern\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create hexagonal grid using polar coordinates\n    float angleStep = pi / 3.0;\n    float angleOffset = sin(iTime) * angleStep;\n    \n    // Calculate distance to nearest hexagon edge\n    float dist = abs(sin(a + angleOffset) * r);\n    float threshold = 0.5 + 0.2 * sin(iTime * 2.0 + r * 10.0);\n    // Create pulsating effect with color gradients\n    vec3 color;\n    if (dist < threshold) {\n        // Use HSL to RGB conversion for smooth color transitions\n        float hue = (a / (2.0 * pi)) + iTime * 0.5;\n        float saturation = 1.0 - abs(r - 0.7);\n        float lightness = 0.5 + 0.3 * sin(iTime + r * 10.0);\n        \n        color = hsl2rgb(vec3(hue, saturation, lightness));\n    } else {\n        // Create shifting background pattern\n        vec2 noiseUV = uv * 4.0 + iTime;\n        float noiseValue = turbulent(noiseUV) * 0.5 + 0.5;\n        \n        color = hsl2rgb(vec3(\n            noiseValue * 0.7,\n            1.0 - noiseValue,\n            0.3 + noiseValue * 0.4\n        ));\n    }\n    // Add pulsating glow effect\n    float glow = max(0.0, 1.0 - r) * (0.5 + 0.5 * sin(iTime));\n    color += glow;\n    return vec4(color, 1.0);\n}"
  },
  "data_923.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime; // Add time for rotation\n    \n    // Create rotating sine wave pattern with noise\n    float wave = sin(theta * 4.0 + turbulent(vec3(theta * 2.0, r * 10.0, iTime)) * 0.5);\n    wave += sin(r * 8.0 + iTime * 2.0) * 0.5;\n    \n    // Create color transitions\n    vec3 color = hsl2rgb(vec3(\n        mod(theta * 0.1 + iTime, 1.0), // Hue variation over time and space\n        0.7 + turbulent(vec2(r * 4.0, iTime)) * 0.3, // Saturation with noise\n        0.5 + wave * 0.5 // Brightness modulation by wave pattern\n    ));\n    \n    // Add some contrast and brightness\n    color = pow(color, vec3(1.2));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_924.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    // Create expanding circles using time and radius\n    float circle = sin(r * 10.0 + iTime * 5.0);\n    \n    // Add noise variation to the circles\n    vec3 noisePos = vec3(uv * 5.0, iTime * 0.5);\n    float turbulence = turbulent(noisePos) * 0.5;\n    \n    // Combine circle pattern with noise\n    float pattern = (circle + turbulence) * 0.5 + 0.5;\n    \n    // Create color cycling effect using HSL colors\n    vec3 hslColor = vec3(\n        theta / (2.0 * PI) + iTime * 0.1,  // Hue\n        0.7,                                // Saturation\n        0.5                                 // Lightness\n    );\n    \n    // Convert HSL to RGB and mix with pattern\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = rgbColor * pattern;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_925.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    // Create base color using HSL\n    vec3 color = hsl(\n        mod(a + iTime * 0.5, 2.0 * PI) / (2.0 * PI),  // Hue based on angle and time\n        0.7,  // Saturation\n        0.5   // Lightness\n    );\n    // Add turbulence for dynamic effect\n    vec3 noisePos = vec3(st.x + iTime, st.y + iTime, iTime * 0.1);\n    float turb = turbulent(noisePos * 2.0) * 0.5 + 0.5;\n    \n    // Create motion blur effect using angle and time\n    float motionBlur = sin(a + iTime) * 0.5 + 0.5;\n    \n    // Combine elements with radial gradient\n    vec3 finalColor = mix(\n        color,\n        hsl2rgb(vec3(mod(iTime * 0.1, 1.0), 0.8, 0.6)),\n        r * 0.5\n    ) * (1.0 - turb) + turb;\n    // Add motion blur effect\n    finalColor *= mix(1.0, 0.3, motionBlur);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_926.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create vertical stripe pattern using sine waves\n    float stripes = sin(uv.x * 8.0 + iTime) * 0.5 + 0.5;\n    stripes += sin(uv.x * 16.0 + iTime * 2.0) * 0.3;\n    \n    // Add noise to create organic variations\n    vec2 noiseUV = uv * 4.0 + vec2(iTime);\n    float noiseVal = noise(noiseUV);\n    stripes += noiseVal * 0.15;\n    \n    // Create pulsing effect\n    float pulse = sin(iTime * 0.5) * 0.3 + 0.7;\n    \n    // Generate color based on time and position\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.1) * 360.0,   // Hue variation over time\n        0.8,                          // Saturation\n        stripes * pulse               // Brightness modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_927.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x);\n    \n    // Create tessellation pattern using sine waves\n    float scale = 5.0 + sin(r * 3.0 + iTime) * 2.0;\n    vec2 grid = floor((st * scale) + 0.5);\n    \n    // Calculate triangle divisions\n    vec2 pos = fract((st * scale) + 0.5);\n    float tri = sin(a + r * 10.0 + iTime * 2.0) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(r * 0.2 + a * 0.5 + iTime * 0.1),\n        0.7 + sin(r * 4.0 + iTime) * 0.3,\n        0.3 + cos(r * 4.0 + iTime) * 0.7\n    );\n    \n    // Convert to RGB and add noise\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= 1.0 + noise(vec3(uv * 10.0, iTime)) * 0.5;\n    \n    // Final color with alpha\n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_928.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a time-varying base pattern\n    float t = iTime * 0.5;\n    \n    // Create a circular pattern with noise\n    vec2 st = uv * 2.0 - 1.0;\n    float d = length(st);\n    float circle = smoothstep(0.8, 1.0, d);\n    \n    // Add turbulence to create dynamic texture\n    vec3 noisePos = vec3(uv * 5.0 + t, t);\n    float turb = turbulent(noisePos) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(t * 2.0, 1.0, 0.8);\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add geometric elements with rotating patterns\n    float angle = atan2(st.y, st.x) + t;\n    float sine = sin(angle * 4.0 + t * 2.0);\n    float line = smoothstep(0.95, 1.0, abs(sine));\n    \n    // Combine all elements\n    vec3 finalColor = mix(rgbColor * turb, vec3(circle), line);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_929.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating sine wave patterns\n    float time = iTime * 0.5;\n    \n    // Rotate coordinates over time\n    vec2 st = uv - 0.5;\n    float theta = atan2(st.y, st.x) + time;\n    float dist = length(st);\n    \n    // Create RGB sine waves with different phases and frequencies\n    vec3 color = vec3(\n        sin(theta + time * 2.0 + dist * 2.0) * 0.5 + 0.5,\n        sin(theta - time * 1.0 + dist * 1.0) * 0.5 + 0.5,\n        sin(theta + time * 3.0 - dist * 2.0) * 0.5 + 0.5\n    );\n    \n    // Add turbulence for more dynamic effect\n    vec3 noise = vec3(\n        turbulent(vec3(uv.x, time, 0.0)),\n        turbulent(vec3(uv.y, time, 1.0)),\n        turbulent(vec3(uv.x + uv.y, time, 2.0))\n    );\n    \n    // Combine color and noise\n    color = mix(color, noise, 0.5);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_93.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to [-1,1] range\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add some movement over time\n    float time = iTime * 0.5;\n    \n    // Create a rotating pattern using polar coordinates\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + time;\n    \n    // Add noise to create turbulence effect\n    vec2 noisePos = st * 5.0 + vec2(time);\n    float turb = turbulent(noisePos);\n    \n    // Create color variations using HSL\n    vec3 hslColor;\n    hslColor.x = fract(angle * 0.1 + time) * 360.0; // Hue variation\n    hslColor.y = 0.7 + turb * 0.3; // Saturation with noise\n    hslColor.z = 0.5 + radius * 0.5; // Lightness based on distance\n    \n    // Convert HSL to RGB and return\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_930.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying sine wave patterns with different frequencies\n    float t = iTime * 0.5;\n    \n    // Interweaving pattern using multiple sine waves\n    vec3 color1 = sin(uv.xyy * 8.0 + t * 4.0);\n    vec3 color2 = sin(uv.yxx * 6.0 + t * 3.0 + 2.0);\n    \n    // Mix colors with phase shifts for RGB transitions\n    vec3 mixedColor = mix(color1, color2, 0.5);\n    \n    // Add noise and turbulence to create dynamic movement\n    vec2 noisePos = uv * 4.0 + t;\n    float noiseVal = noise(noisePos) * 0.5 + 0.5;\n    \n    // Create HSL color transition effect\n    vec3 hslColor = vec3(\n        mod(t * 0.1, 1.0),   // Hue cycling over time\n        0.7,                 // Saturation\n        noiseVal             // Brightness modulation with noise\n    );\n    \n    // Convert HSL to RGB and mix with sine wave colors\n    vec3 finalColor = hsl2rgb(hslColor) * (mixedColor * 0.5 + 0.5);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_931.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 centered = uv * 2.0 - 1.0;\n    float theta = atan2(centered.y, centered.x);\n    float r = length(centered);\n    \n    // Create rotating effect by adding time to angle\n    theta += iTime * 0.5;\n    \n    // Create color gradient using HSL colors\n    vec3 color = hsl(theta / (pi * 2.0), 1.0, r);\n    \n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_932.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 pos = floor(uv * 10.0);\n    float time = iTime * 0.5;\n    \n    // Calculate cell position and distance from center\n    vec2 cellPos = pos + 0.5;\n    vec2 centerOffset = uv - (pos + 0.5);\n    float dist = length(centerOffset) * 10.0;\n    \n    // Pulsating color based on time and position\n    float hue = fract(time * 0.1 + pos.x * 0.2 + pos.y * 0.3) * PI * 2.0;\n    vec3 color = hsl(hue, 1.0, 0.5);\n    \n    // Add noise and turbulence for more dynamic effect\n    float noiseVal = noise(vec3(pos, time)) * 0.5 + 0.5;\n    float pulse = sin(time + pos.x + pos.y) * 0.5 + 0.5;\n    \n    // Combine effects\n    color *= hsl2rgb(vec3(hue, 1.0, noiseVal));\n    color *= smoothstep(0.0, 1.0, sin(time + dist) * 0.5 + 0.5);\n    \n    // Final output with pulsating alpha\n    return vec4(color, pulse);\n}"
  },
  "data_933.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create a grid of hexagons using polar coordinates\n    vec2 grid = floor(st);\n    vec2 center = fract(st) - 0.5;\n    \n    // Calculate rotation based on time\n    float angle = iTime * 0.2;\n    mat2 rot = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 rotated = rot * center;\n    \n    // Convert to polar coordinates for hexagonal shape\n    float radius = length(rotated);\n    float theta = atan2(rotated.y, rotated.x);\n    \n    // Create hexagonal pattern using trigonometric functions\n    float hex = abs(cos(theta * 6.0)) + turbulent(vec3(center, iTime));\n    vec3 color = hsl(hex * 0.5 + 0.5, 1.0, 0.5);\n    \n    // Add noise and turbulence for dynamic effects\n    float noiseValue = noise(vec2(grid.x, grid.y) + iTime);\n    radius += noiseValue * 0.3;\n    \n    // Create final color based on distance from center\n    vec3 finalColor = mix(color * 0.8, vec3(1.0), smoothstep(0.5, 1.0, radius));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_934.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create a rotating pattern using time\n    theta += sin(iTime * 0.5) * 0.5;\n    \n    // Generate fractal noise in polar coordinates\n    vec3 noiseParams = vec3(r * 10.0, theta * 2.0 + iTime, 0.0);\n    float turbulence = turbulent(noiseParams);\n    \n    // Create a radial gradient with color variations\n    vec3 color = hsl2rgb(vec3(\n        180.0 + sin(theta + iTime) * 60.0,\n        0.7 + abs(turbulence) * 0.3,\n        0.5 + sin(iTime * 0.2 + r * 4.0) * 0.5\n    ));\n    \n    // Add pulsing effect\n    float pulse = sin(iTime * 0.2) * 0.5 + 0.5;\n    color *= (1.0 - r * 0.5) * (1.0 + pulse);\n    \n    // Mix in noise for more dynamic texture\n    color += hsv2rgb(vec3(\n        theta * 180.0,\n        0.5,\n        abs(turbulent(vec3(r * 5.0, theta * 2.0, 0.0))) * 0.4\n    )) * (1.0 - r);\n    \n    // Add a soft glow effect\n    color *= smoothstep(0.8, 1.0, 1.0 - r);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_935.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Speed of movement\n    float speed = 0.3;\n    \n    // Create a time-based offset for movement\n    vec2 st = uv * 5.0 + vec2(sin(iTime * speed), cos(iTime * speed * 0.7));\n    \n    // Generate noise layers with different scales\n    float n1 = noise(st * 10.0) * 0.5;\n    float n2 = noise(st * 5.0 + vec2(1.0)) * 0.3;\n    \n    // Create a flowing movement pattern\n    vec2 flow = vec2(\n        sin(iTime * speed + st.x * 2.0),\n        cos(iTime * speed * 0.7 + st.y * 2.0)\n    );\n    \n    // Combine noise layers with turbulence for more complex patterns\n    float turb = turbulent(st * 3.0) * 0.5;\n    float pattern = (n1 + n2 + turb) * 0.5 + 0.5;\n    \n    // Create color shifts using HSL conversion\n    vec3 color1 = hsl2rgb(vec3(\n        sin(iTime * 0.2 + 1.0) * 0.5 + 0.5,\n        0.7,\n        0.8\n    ));\n    \n    vec3 color2 = hsl2rgb(vec3(\n        sin(iTime * 0.3 + 2.0) * 0.5 + 0.5,\n        0.6,\n        0.7\n    ));\n    \n    // Mix colors based on pattern and flow\n    vec3 finalColor = mix(color1, color2, pattern);\n    finalColor *= sin(flow.x * pi + iTime) * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_936.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime; // Add time-based rotation\n    \n    // Create pulsating color effect using sine waves and time\n    float hue = sin(a * 4.0 + iTime * 2.0) * 0.5 + 0.5;\n    vec3 color = hsl(hue, 1.0, 0.5);\n    \n    // Add geometric shape overlay with noise modulation\n    float pattern = sin(r * 8.0 - iTime * 4.0) * 0.5 + 0.5;\n    pattern += noise(vec3(uv * 10.0, iTime)) * 0.2;\n    \n    // Combine color and pattern with turbulence\n    float turb = turbulent(vec2(a * 2.0, r * 4.0 - iTime));\n    color *= pattern + turb * 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_937.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create time-varying waves\n    float wave1 = sin(uv.x * 10.0 + iTime) * 0.5;\n    float wave2 = sin(uv.y * 5.0 - iTime * 3.0) * 0.3;\n    \n    // Combine waves and add noise for texture\n    float value = (wave1 + wave2) * 0.5 + noise(vec2(uv.x*5.0, uv.y*5.0)) * 0.3;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl(\n        mod(iTime * 0.2 + value * 0.5, 1.0),  // Hue variation over time and space\n        0.7,                                   // Saturation\n        0.6                                    // Lightness\n    );\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_938.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color with time-based shift\n    vec3 baseColor = hsl2rgb(vec3(0.5 + 0.5*sin(iTime*0.1), 0.8, 0.3));\n    \n    // Create flowing noise patterns\n    float noise1 = noise(uv * 4.0 + vec2(sin(iTime)*0.5, cos(iTime)*0.5)) * 0.5;\n    float noise2 = noise(uv * 8.0 + vec2(cos(iTime*0.7)*0.3, sin(iTime*0.6)*0.3)) * 0.3;\n    \n    // Add turbulence for more dynamic movement\n    vec2 distortedUV = uv + turbulent(uv * 4.0 + vec2(sin(iTime), cos(iTime))) * 0.1;\n    \n    // Create shimmering effect using highlight and color shift\n    float highlight = sin(length(distortedUV) * 8.0 - iTime * 2.0) * 0.5 + 0.5;\n    vec3 finalColor = mix(baseColor, hsl2rgb(vec3(0.1 + noise(uv*16.0), 0.9, 0.4)), highlight);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_939.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV coordinates to center and scale appropriately\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Convert to polar coordinates\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create rotating pattern using time\n    theta += iTime * 3.0; // Speed up rotation\n    \n    // Add pulsing effect with sine wave\n    r *= sin(iTime) + 1.5;\n    \n    // Use noise to create turbulence in the pattern\n    float noiseVal = turbulent(vec2(theta, r));\n    \n    // Create color wheel using HSL colors\n    vec3 color = hsl2rgb(vec3(\n        theta * 0.5 + iTime * 0.1,\n        1.0,\n        0.5 + noiseVal * 0.5\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_94.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Remap UV from [0,1] to [-1,1]\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add some movement over time\n    float time = iTime * 0.5;\n    \n    // Create a rotating pattern\n    float angle = atan2(st.y, st.x) + time;\n    vec2 rotated = vec2(\n        cos(angle) * st.x - sin(angle) * st.y,\n        sin(angle) * st.x + cos(angle) * st.y\n    );\n    \n    // Add some noise and turbulence\n    float noise1 = turbulent(rotated * 4.0);\n    float noise2 = turbulent(vec3(rotated * 8.0, time));\n    \n    // Create color from HSL values\n    vec3 color = hsl(\n        fract(time + atan2(st.y, st.x) / (PI * 2.0)) * 360.0,\n        0.7 + noise1 * 0.3,\n        0.5 + noise2 * 0.5\n    );\n    \n    // Add some geometric patterns\n    float rad = length(st);\n    float circles = sin(rad * 8.0 + time) * 0.5 + 0.5;\n    color *= circles;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_940.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv + 0.5;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x);\n    // Create hexagonal grid pattern\n    vec2 grid = vec2(\n        floor(radius * 10.0),\n        floor(angle / (pi/3.0) + 6.0)\n    );\n    // Calculate unique identifier for each hexagon\n    float id = grid.x * 6.0 + grid.y;\n    \n    // Pulsing effect based on time and position\n    float pulse = sin(iTime + id * 0.5);\n    pulse = (pulse + 1.0) * 0.5; // Scale to 0-1 range\n    \n    // Calculate color based on hexagon position\n    vec3 hslColor = vec3(\n        angle / (2.0 * pi) * 360.0, // Hue based on angle\n        0.7 + pulse * 0.3,         // Saturation increases with pulse\n        0.5                       // Base lightness\n    );\n    \n    // Convert to RGB and apply pulsing effect\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor *= 0.8 + turbulent(uv * 10.0 + iTime) * 0.2; // Add noise\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_941.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale UV coordinates for grid pattern\n    vec2 st = uv * 10.0;\n    \n    // Get cell position using modular arithmetic\n    vec2 cellPos = mod(st, 1.0);\n    \n    // Calculate distance from center of cell\n    float dist = length(cellPos - 0.5);\n    \n    // Create rotating squares pattern\n    float angle = sin(iTime * 0.5 + cellPos.x * pi) * cos(iTime * 0.5 + cellPos.y * pi);\n    vec2 rotatedUV = vec2(\n        (cellPos.x - 0.5) * cos(angle) - (cellPos.y - 0.5) * sin(angle),\n        (cellPos.x - 0.5) * sin(angle) + (cellPos.y - 0.5) * cos(angle)\n    ) + 0.5;\n    \n    // Color transition based on time and noise\n    vec3 color = hsl2rgb(vec3(\n        mod(iTime * 0.1 + noise(cellPos * 10.0), 1.0),\n        0.7,\n        0.6\n    ));\n    \n    // Combine pattern with color\n    float squareMask = step(0.5, rotatedUV.x) * step(0.5, rotatedUV.y);\n    vec3 finalColor = mix(vec3(0.0), color, squareMask);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_942.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Moving sine wave pattern with time offset\n    float wave1 = sin(uv.x * 10.0 + iTime) * 0.5 + 0.5;\n    float wave2 = sin(uv.y * 10.0 + iTime * 0.5 + pi) * 0.5 + 0.5;\n    \n    // Create a base color with time-varying hue\n    vec3 baseColor = hsl2rgb(vec3(iTime * 0.1, 0.7, 0.6));\n    \n    // Add noise texture\n    float noiseX = noise(uv * 40.0 + iTime) * 0.3;\n    float noiseY = noise(uv * 40.0 + iTime + pi) * 0.3;\n    \n    // Combine waves and noise with color\n    vec3 finalColor = baseColor * (wave1 + wave2 + noiseX + noiseY) * 1.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_943.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV to center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Add rotation based on time\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    theta += iTime * 0.5; // Rotation speed\n    \n    // Create sine wave patterns with time offset\n    float wave1 = sin(r * 8.0 + theta * 4.0 + iTime) * 0.5 + 0.5;\n    float wave2 = sin(theta * 3.0 - r * 6.0 + iTime * 2.0) * 0.5 + 0.5;\n    \n    // Combine waves with turbulence\n    float noiseVal = turbulent(vec2(st.x * 4.0, st.y * 4.0)) * 0.5 + 0.5;\n    float pattern = (wave1 + wave2) * noiseVal;\n    \n    // Create color transitions using HSL\n    vec3 baseColor = hsl2rgb(vec3(iTime * 0.1, 1.0, 0.8));\n    vec3 noiseColor = hsl2rgb(vec3((iTime * 0.1 + noiseVal) * 2.0, 1.0, 0.6));\n    \n    // Mix colors based on pattern\n    vec3 finalColor = mix(baseColor, noiseColor, pattern);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_944.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset UV coordinates for grid pattern\n    vec2 st = uv * 10.0 + iTime;\n    \n    // Create a rotation matrix with time-based animation\n    mat2 rot = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    vec2 transformedUV = (st * rot) * 0.5;\n    \n    // Generate noise values for color variation\n    float noiseValue = noise(transformedUV);\n    float turbulenceValue = turbulent(transformedUV);\n    \n    // Create triangle pattern using barycentric coordinates\n    vec3 hslColor = vec3(\n        fract(iTime + transformedUV.x * 0.5),\n        1.0,\n        0.5 + 0.5 * noiseValue\n    );\n    \n    // Convert HSL to RGB and mix with turbulence for depth\n    vec3 rgbColor = hsl2rgb(hslColor) * (0.5 + 0.5 * turbulenceValue);\n    \n    // Create mosaic effect by tiling and offsetting patterns\n    vec2 cell = floor(uv * 10.0);\n    vec2 triangleUV = fract(uv * 10.0 + iTime);\n    \n    // Combine all elements for final color\n    return vec4(\n        rgbColor,\n        1.0\n    );\n}"
  },
  "data_945.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates and scale them\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create a rotating pattern using multiple layers of rotation\n    float time = iTime * 0.5;\n    \n    // Layer 1: Basic rotation\n    vec2 rotated1 = vec2(\n        cos(time) * st.x + sin(time) * st.y,\n        -sin(time) * st.x + cos(time) * st.y\n    );\n    \n    // Layer 2: Faster rotation\n    vec2 rotated2 = vec2(\n        cos(time * 2.0) * st.x + sin(time * 2.0) * st.y,\n        -sin(time * 2.0) * st.x + cos(time * 2.0) * st.y\n    );\n    \n    // Layer 3: Slow rotation\n    vec2 rotated3 = vec2(\n        cos(time * 0.5) * st.x + sin(time * 0.5) * st.y,\n        -sin(time * 0.5) * st.x + cos(time * 0.5) * st.y\n    );\n    \n    // Combine rotations with noise and turbulence\n    vec2 finalUV = rotated1 * 0.33 + rotated2 * 0.33 + rotated3 * 0.34;\n    finalUV += turbulent(finalUV * 8.0) * 0.1;\n    \n    // Create a triangular pattern\n    vec2 polar = vec2(length(finalUV), atan2(finalUV.y, finalUV.x));\n    float triangle = sin(polar.y * 6.0 + time) * 0.5 + 0.5;\n    \n    // Color transformation with shifting hues\n    vec3 color = hsl(triangle * 0.7 + 0.3, 1.0, 0.5);\n    color *= smoothstep(0.0, 1.0, sin(time) * 0.5 + 0.5);\n    \n    // Add noise to the final color\n    color += noise(finalUV * 8.0 + time) * 0.2;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_946.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a hexagonal grid pattern with animation\n    vec2 st = uv * 10.0;\n    vec2 iSt = floor(st);\n    vec2 fSt = fract(st);\n    \n    // Add some noise and movement to the grid points\n    float time = iTime * 0.5;\n    vec3 color = hsl2rgb(vec3(0.5 + 0.5*sin(time + iSt.x*0.1), 0.7, 0.8));\n    \n    // Create a flowing network pattern\n    vec2 offset = vec2(\n        sin(time + iSt.y * 0.1) * 0.3,\n        cos(time + iSt.x * 0.1) * 0.3\n    );\n    \n    // Calculate distance from the current point to the grid points\n    vec2 d = fSt - 0.5;\n    float dist = length(d);\n    \n    // Add some turbulence to create organic movement\n    float turb = turbulent(vec3(st + time, 0.0)) * 0.1;\n    dist += turb;\n    \n    // Create a pulsing effect\n    float pulse = sin(time) * 0.5 + 0.5;\n    float stroke = smoothstep(0.4 - pulse*0.2, 0.4 + pulse*0.2, dist);\n    \n    // Add some depth perception\n    vec3 finalColor = color * (1.0 - abs(pulse - 0.5)*0.5);\n    finalColor *= 1.0 - length(offset) * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_947.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float angle = 2.0 * pi * iTime / 10.0;\n    vec2 rotatedUv = vec2(\n        cos(angle)*uv.x - sin(angle)*uv.y,\n        sin(angle)*uv.x + cos(angle)*uv.y\n    );\n    \n    // Create sine wave pattern with time-based frequency\n    float freq = 5.0 + sin(iTime / 3.0) * 2.0;\n    vec2 st = rotatedUv * freq;\n    \n    // Add turbulence to create dynamic variations\n    float noiseVal = noise(st + iTime);\n    noiseVal = turbulent(vec3(st, iTime)) * 0.5 + 0.5;\n    \n    // Create RGB shifts with time-based phase differences\n    vec3 color = vec3(\n        sin(st.x * 2.0 + iTime) * 0.5 + 0.5,\n        cos(st.y * 2.0 - iTime/2.0) * 0.5 + 0.5,\n        sin((st.x + st.y)*1.5 + iTime*0.8) * 0.5 + 0.5\n    );\n    \n    // Mix noise with color and add brightness variation\n    vec3 finalColor = mix(color, vec3(noiseVal), 0.4);\n    finalColor *= sin(iTime / 2.0) * 0.5 + 0.7;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_948.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color transition using HSL\n    vec3 baseColor = hsl2rgb(vec3(0.5 * sin(iTime * 0.5) + 0.5, 0.7, 0.6));\n    \n    // Create flowing liquid effect using noise and turbulence\n    float flow1 = turbulent(uv * 4.0 + vec2(iTime)) * 0.5;\n    float flow2 = turbulent(uv * 8.0 + vec2(iTime * 0.7)) * 0.3;\n    float flow3 = turbulent(uv * 16.0 + vec2(iTime * 0.4)) * 0.2;\n    \n    // Combine flows with different scales and speeds\n    float liquidFlow = (flow1 + flow2 + flow3) * 0.5 + 0.5;\n    \n    // Create color transitions based on UV coordinates and time\n    vec3 finalColor = mix(\n        baseColor,\n        hsl2rgb(vec3(0.3 * sin(iTime * 0.3) + 0.6, 0.8, 0.7)),\n        liquidFlow\n    );\n    \n    // Add dynamic movement to the color transitions\n    finalColor *= 1.0 + 0.5 * sin(iTime + uv.x * 2.0);\n    finalColor = clamp(finalColor, 0.0, 1.0); // Ensure colors stay within valid range\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_949.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create hexagonal grid coordinates\n    vec2 q = uv * 0.7;\n    float r = sin(iTime * 0.5 + q.x * pi);\n    float s = cos(iTime * 0.5 + q.y * pi);\n    \n    // Pulsating effect using sine wave\n    float pulse = sin(iTime) * 0.5 + 0.5;\n    vec2 st = uv * (1.0 + pulse * 0.3);\n    \n    // Add noise and turbulence for dynamic patterns\n    float noiseVal = noise(st * 4.0 + iTime);\n    float turb = turbulent(st * 8.0 + iTime);\n    \n    // Calculate distance from center for radial gradient\n    vec2 center = st - vec2(0.5, 0.5);\n    float dist = length(center) * 1.5;\n    \n    // Create color shifts using HSL to RGB conversion\n    vec3 color = hsl(dist + iTime, 0.7, 0.6);\n    color = hsl2rgb(color);\n    \n    // Combine with noise and turbulence for final effect\n    color *= (1.0 - noiseVal * 0.5) + turb * 0.3;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_95.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a rotating polar coordinate system\n    vec2 st = uv * 5.0 - 2.5;\n    float r = length(st);\n    float a = atan2(st.y, st.x) + iTime * 0.1;\n    \n    // Add some turbulence to create organic patterns\n    float t = turbulent(vec3(r, a, iTime * 0.2));\n    \n    // Create flower-like pattern using sine waves\n    float petal = sin(r * 8.0 - a * 4.0 + iTime) * 0.5;\n    float ring = sin(r * 16.0 + iTime) * 0.3;\n    \n    // Combine patterns and add depth with noise\n    float pattern = (petal + ring + t) * 0.5;\n    pattern += noise(vec2(a, r)) * 0.2;\n    \n    // Create color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        a * 0.1 + iTime * 0.1,\n        0.7 + t * 0.3,\n        0.5 + pattern * 0.4\n    ));\n    \n    // Add depth and movement to the final output\n    color *= (1.0 - noise(vec2(r, a)) * 0.5);\n    color *= (1.0 - r * 0.2);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_950.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing sine wave pattern with time offset\n    float time = iTime * 0.5;\n    \n    // Base sine wave pattern\n    vec2 st = uv * 10.0 + vec2(time, 0.0);\n    float wave1 = sin(st.x) * 0.5;\n    \n    // Add noise and turbulence for more organic feel\n    vec3 noisePos = vec3(uv * 4.0, time);\n    float noiseVal = noise(noisePos) * 0.2;\n    float turb = turbulent(vec2(uv * 16.0)) * 0.1;\n    \n    // Combine patterns and add metallic color shifts\n    float pattern = wave1 + sin(wave1 * 4.0 + time) * 0.3 + noiseVal + turb;\n    \n    // Create metallic color using HSL\n    vec3 colorHSL = vec3(0.6, 0.8, 0.5 + abs(pattern) * 0.2);\n    vec3 rgbColor = hsl2rgb(colorHSL);\n    \n    // Add highlight/specular effect\n    vec2 lightDir = vec2(sin(time), cos(time)) * 0.5;\n    float light = max(0.0, dot(vec2(dFdx(pattern), dFdy(pattern)), lightDir));\n    \n    // Final color with metallic sheen\n    rgbColor *= (1.0 + light * 0.6);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_951.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float radius = length(st);\n    float angle = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Animate the center point with noise\n    vec2 centerOffset = vec2(sin(iTime * 0.7) * 0.3, cos(iTime * 0.6) * 0.3);\n    vec2 animatedUV = uv + centerOffset;\n    \n    // Create layered noise patterns\n    float noise1 = noise(vec3(uv * 4.0 + iTime, 0.0));\n    float noise2 = turbulent(vec2(uv * 8.0 - iTime * 2.0)) * 0.5;\n    float noise3 = turbulent(vec2(uv * 16.0 + iTime)) * 0.25;\n    \n    // Combine noises with color transitions\n    vec3 colorBase = hsl2rgb(vec3(angle * 0.1, 0.7, 0.8));\n    vec3 colorNoise = hsl2rgb(vec3((noise1 + noise2 + noise3) * 0.5 + 0.5, 0.6, 0.7));\n    \n    // Mix colors based on radius and time\n    float mixAmount = sin(radius * pi + iTime) * 0.5 + 0.5;\n    vec3 finalColor = mix(colorBase, colorNoise, mixAmount);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_952.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    vec2 st = uv;\n    \n    // Create polar coordinates\n    float radius = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create hexagonal pattern by multiplying angle by 6\n    theta *= 6.0;\n    \n    // Add time-based rotation\n    theta += iTime * 4.0;\n    \n    // Use sine of multiplied angle for pulsating effect\n    float pulse = sin(theta + radius * 10.0) * 0.5 + 0.5;\n    \n    // Create color transitions using HSL\n    vec3 hslColor = vec3(\n        radius * 360.0,  // Hue varies with distance from center\n        0.7,             // Saturation\n        pulse           // Lightness varies with pulsing effect\n    );\n    \n    // Convert to RGB and mix with white based on noise\n    vec3 color = hsl2rgb(hslColor) * (1.0 - turbulent(st * 4.0)) + vec3(1.0) * turbulent(st * 4.0);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_953.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern with time-varying scale\n    float scale = 10.0 + sin(iTime * 0.5) * 3.0;\n    vec2 st = uv * scale;\n    \n    // Add some rotation to create hexagonal lattice effect\n    float angle = iTime * 0.2;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    st = rot * st;\n    \n    // Create a grid pattern with turbulence\n    vec3 noisePos = vec3(st.x, st.y, iTime * 0.5);\n    float grid = turbulent(noisePos) * 0.5 + 0.5;\n    \n    // Convert to polar coordinates for color variation\n    vec2 toCenter = uv - vec2(0.5);\n    float dist = length(toCenter);\n    float anglePolar = atan2(toCenter.y, toCenter.x);\n    \n    // Create time-varying HSL color\n    vec3 hslColor;\n    hslColor.x = (iTime * 0.1 + anglePolar) * 0.5 + 0.5; // Hue variation\n    hslColor.y = 0.7 + grid * 0.3;                       // Saturation\n    hslColor.z = 0.5 + sin(dist * 8.0 + iTime) * 0.2;   // Lightness\n    \n    // Convert HSL to RGB and mix with noise pattern\n    vec3 rgbColor = hsl2rgb(hslColor);\n    vec3 finalColor = mix(vec3(0.1), rgbColor, grid);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_954.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base frequency for waves\n    float freq = 4.0;\n    \n    // Create two sine wave patterns moving in opposite directions\n    float wave1 = sin(uv.x * freq + iTime) * 0.5 + 0.5;\n    float wave2 = sin(-uv.y * freq - iTime) * 0.5 + 0.5;\n    \n    // Combine waves with some offset and scale\n    vec2 waves = vec2(wave1, wave2);\n    \n    // Create a color based on HSL values that shift over time\n    vec3 baseColor = hsl(\n        mod(iTime * 0.2 + uv.x * 2.0 + uv.y * 3.0, 1.0),  // Hue\n        0.7,  // Saturation\n        0.5   // Lightness\n    );\n    \n    // Mix colors based on wave patterns\n    vec3 finalColor = mix(\n        baseColor,\n        hsl(\n            mod(iTime * 0.2 + uv.x * 3.0 + uv.y * 2.0, 1.0),  // Hue\n            0.7,\n            0.5\n        ),\n        waves.x * waves.y * 0.8 + 0.2\n    );\n    \n    // Add some noise to create dynamic variations\n    vec2 noiseUV = uv * 20.0 + iTime;\n    float noiseVal = turbulent(noiseUV) * 0.3;\n    finalColor *= 1.0 + noiseVal;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_955.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base time factor\n    float time = iTime * 0.5;\n    \n    // Rotate UV coordinates over time\n    vec2 rotatedUv = vec2(\n        uv.x * cos(time) - uv.y * sin(time),\n        uv.x * sin(time) + uv.y * cos(time)\n    );\n    \n    // Create a base color using HSL to RGB conversion\n    vec3 baseColor = hsl2rgb(vec3(0.5 * time, 1.0, 0.5));\n    \n    // Add noise and turbulence patterns\n    float noisePattern = turbulent(rotatedUv * 4.0) * 0.5 + 0.5;\n    float noiseDetail = turbulent(vec3(rotatedUv * 8.0, time)) * 0.5 + 0.5;\n    \n    // Combine colors and patterns\n    vec3 finalColor = mix(\n        baseColor,\n        hsl2rgb(vec3(0.5 * time + noisePattern, 1.0, 0.5)),\n        noiseDetail * 0.7\n    );\n    \n    // Add flowing movement using sine functions\n    finalColor *= sin(time + uv.x * 4.0) * 0.5 + 0.5;\n    finalColor += vec3(sin(time + uv.y * 4.0)) * 0.2;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_956.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale factor for grid size\n    float scale = 10.0;\n    \n    // Create a grid pattern using floor and fract functions\n    vec2 gridPos = floor(uv * scale);\n    vec2 cellPos = fract(uv * scale);\n    \n    // Calculate triangle position within each grid cell\n    bool triangleA = (cellPos.x + cellPos.y) < 1.0;\n    \n    // Create animated color transitions using HSL colors\n    vec3 hslColor = vec3(\n        mod(gridPos.x + gridPos.y * 0.5 + iTime * 0.2, 1.0),  // Animated hue\n        0.7,  // Saturation\n        0.6   // Lightness\n    );\n    \n    // Convert HSL to RGB and add depth effect using noise\n    vec3 color = hsl2rgb(hslColor);\n    float depth = turbulent(vec3(cellPos * 10.0, iTime * 0.5)) * 0.5 + 0.5;\n    \n    // Mix colors based on triangle position and depth\n    if (triangleA) {\n        color *= mix(1.0, 0.8, depth);\n    } else {\n        color *= mix(0.8, 1.0, depth);\n    }\n    \n    return vec4(color, 0.9);\n}"
  },
  "data_957.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv - 0.5;\n    float theta = atan(st.y, st.x);\n    float r = length(st);\n    \n    // Add time-based rotation and noise\n    theta += iTime * 0.1 + turbulent(vec3(theta, r, iTime)) * 0.2;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        (theta / PI + 0.5) * 0.6 + iTime * 0.1,\n        0.7 + turbulent(vec2(r, iTime)) * 0.3,\n        0.5 + turbulent(vec2(theta, r)) * 0.2\n    ));\n    \n    // Add perspective distortion\n    float depth = 1.0 / (r + 1.0);\n    color *= depth;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_958.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for circular motion\n    vec2 st = uv * 2.0 - 1.0;\n    float angle = atan2(st.y, st.x);\n    float radius = length(st) * 0.5 + 0.5;\n    \n    // Create opening/closing effect using time\n    float mouthOpen = sin(iTime * 3.0) * 0.5 + 0.5;\n    float scaledRadius = radius * (1.0 - mouthOpen * 0.5);\n    \n    // Add noise for organic movement\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float noiseValue = turbulent(noiseUV) * 0.1;\n    \n    // Create color based on position and time\n    vec3 color = hsl(\n        (angle / PI + 1.0) * 0.5 + iTime * 0.2,\n        0.7 + noiseValue * 0.3,\n        0.6 + scaledRadius * 0.4\n    );\n    \n    // Add inner details\n    float innerDetail = smoothstep(0.8, 1.0, radius);\n    color += hsl(\n        (angle / PI + 1.0) * 0.5 + iTime * 0.3,\n        0.6,\n        0.4\n    ) * innerDetail;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_959.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using HSL with position and time\n    vec3 baseColor = hsl2rgb(vec3(uv.x * 5.0 + iTime, 0.5, 0.5));\n    \n    // Add dynamic noise-based variation\n    float noise1 = noise(uv * 4.0 + vec2(iTime));\n    float noise2 = noise((uv + vec2(iTime)) * 8.0);\n    float turbulence = (noise1 + noise2) * 0.5;\n    \n    // Combine colors with turbulence\n    vec3 finalColor = mix(baseColor, hsl2rgb(vec3(uv.y * 5.0 + iTime, 0.5, 0.5)), abs(turbulence));\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_96.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Create orbital pattern with noise modulation\n    float orbit = sin(theta * 4.0 + iTime) * 0.5 + 0.5;\n    orbit *= r * 10.0;\n    orbit += noise(vec2(theta, iTime)) * 0.3;\n    \n    // Add turbulence for chaotic effect\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float turb = turbulent(noiseUV);\n    \n    // Create color based on orbital position and noise\n    vec3 color = hsl2rgb(vec3(\n        (theta / pi + 0.5) * 360.0,\n        0.7 + turb * 0.3,\n        0.5 + sin(iTime * 0.5 + theta) * 0.5\n    ));\n    \n    // Add some orbital glow effect\n    float glow = smoothstep(0.8, 1.0, r);\n    color *= mix(vec3(1.0), vec3(0.2, 0.6, 1.0), glow);\n    \n    return vec4(color * (orbit + turb * 0.5), 1.0);\n}"
  },
  "data_960.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating color pattern using time and position\n    float hue = 0.5 + 0.5 * sin(iTime * 2.0 + uv.x * PI);\n    \n    // Add noise-based turbulence for dynamic patterns\n    vec3 baseColor = hsl2rgb(vec3(hue, 1.0, 0.5));\n    float turb = turbulent(uv * 10.0 + iTime);\n    \n    // Combine color and turbulence with layered noise\n    vec3 finalColor = mix(baseColor, hsl2rgb(vec3(hue + 0.3, 1.0, 0.5)), turb * 0.5 + 0.5);\n    finalColor += hsv2rgb(vec3(0.0, 0.0, turbulent(uv * 20.0 + iTime) * 0.5 + 0.5));\n    \n    return vec4(finalColor * 1.5, 1.0);\n}"
  },
  "data_961.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and translate UV coordinates\n    vec2 st = uv * 10.0 - 5.0;\n    \n    // Convert to polar coordinates\n    float angle = atan2(st.y, st.x) + iTime;\n    float radius = length(st);\n    \n    // Create hexagonal pattern\n    float hex = 0.0;\n    for(float a = 0.0; a < PI*2.0; a += PI/3.0) {\n        vec2 p = vec2(cos(a + angle), sin(a + angle)) * radius;\n        hex += abs(sin(p.x * 0.5 + iTime) + cos(p.y * 0.5 + iTime));\n    }\n    \n    // Create pulsating effect\n    float pulse = sin(iTime * 0.5 + radius * 0.2) * 0.5 + 0.5;\n    \n    // Calculate color based on hexagonal pattern and time\n    vec3 color = hsl2rgb(vec3(\n        fract(radius * 0.1 + iTime),\n        0.7,\n        pulse * 0.8 + 0.2\n    ));\n    \n    // Add mouse interaction\n    if(length(uv - 0.5) < 0.1) {\n        color = hsl2rgb(vec3(\n            fract(iTime * 0.2),\n            1.0,\n            0.5\n        ));\n    }\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_962.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and offset coordinates for better pattern distribution\n    vec2 st = uv * 8.0 - 4.0;\n    \n    // Add time-based movement to the coordinates\n    st.x += sin(iTime * 0.5 + st.y) * 0.5;\n    st.y += cos(iTime * 0.6 + st.x) * 0.5;\n    \n    // Create a color based on position and time\n    vec3 color = hsl2rgb(vec3(\n        (st.x + iTime) * 0.1,\n        sin(length(st) * 0.5 + iTime) * 0.5 + 0.5,\n        cos(iTime * 0.4) * 0.5 + 0.5\n    ));\n    \n    // Add noise for texture and movement\n    float noiseValue = noise(vec2(\n        st.x * 0.5 + iTime * 0.3,\n        st.y * 0.5 + iTime * 0.4\n    )) * 0.5 + 0.5;\n    \n    // Combine color with noise for final effect\n    vec3 finalColor = mix(\n        color,\n        hsl2rgb(vec3((iTime) * 0.1, 0.8, 0.6)),\n        noiseValue * 0.4\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_963.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a shifting pattern using time\n    vec2 st = uv + sin(uv * 10.0 + iTime) / 20.0;\n    \n    // Add turbulence to create flowing effect\n    float t = turbulent(st);\n    \n    // Create color variations using HSL\n    vec3 c1 = hsl2rgb(vec3(t * 0.5 + 0.5, 0.8, 0.8));\n    vec3 c2 = hsl2rgb(vec3(turbulent(st * 2.0) * 0.5 + 0.5, 0.6, 0.7));\n    \n    // Combine colors with noise\n    float mixVal = noise(vec3(uv * 10.0, iTime)) * 0.5 + 0.5;\n    vec3 finalColor = mix(c1, c2, mixVal);\n    \n    // Add some dynamic movement using sine waves\n    finalColor *= sin(iTime) * 0.5 + 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_964.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv - 0.5;\n    float radius = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Create rotating sine wave pattern\n    float time = iTime * 0.1;\n    float wave = sin(theta + time) * 4.0 + sin(3.0*(theta - time)) * 0.5;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        radius * 0.6 + time,   // Hue based on radius and time\n        0.7,                  // Saturation\n        0.5                   // Lightness\n    ));\n    \n    // Add noise for texture\n    float noise = turbulent(uv * 4.0) * 0.1;\n    color += vec3(noise);\n    \n    // Mix with black background\n    color *= sin(wave + time * 2.0) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_965.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 coord = uv * 2.0 - 1.0;\n    float r = length(coord);\n    float theta = atan2(coord.y, coord.x);\n    // Create rotating color wheel effect\n    const float numSpokes = 6.0;\n    const float rotationSpeed = 0.5;\n    \n    theta += iTime * rotationSpeed;\n    \n    // Calculate spoke position and create smooth transitions between colors\n    float spoke = mod(theta * numSpokes, 1.0);\n    spoke = smoothstep(0.0, 1.0, spoke);\n    \n    // Create color transition from red to green to blue\n    vec3 color = vec3(\n        smoothstep(0.5, 1.0, spoke),\n        smoothstep(0.0, 1.0, spoke) * (1.0 - smoothstep(0.5, 1.0, spoke)),\n        smoothstep(0.0, 0.5, spoke)\n    );\n    \n    // Add noise to create dynamic radius effect\n    float noiseValue = noise(vec2(iTime * 0.5, r));\n    color *= mix(r, abs(sin(iTime)) + 0.5, noiseValue);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_966.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a grid pattern using fract function\n    vec2 st = fract(uv * 100.0); // Scale up UV coordinates for smaller cells\n    \n    // Calculate distance from center of each cell\n    vec2 offset = abs(st - 0.5);\n    \n    // Use time to animate the colors\n    float time = iTime * 0.5;\n    \n    // Create color transitions using sine functions\n    vec3 color1 = sin(vec3(0.5, 0.7, 0.9) * time + vec3(0.0, 2.0, 4.0)) * 0.5 + 0.5;\n    vec3 color2 = sin(vec3(0.6, 0.8, 1.0) * time + vec3(1.0, 3.0, 5.0)) * 0.5 + 0.5;\n    \n    // Mix colors based on grid position\n    vec3 finalColor = mix(color1, color2, smoothstep(0.4, 0.6, max(offset.x, offset.y)));\n    \n    // Add noise for extra variation\n    float n = noise(st * 10.0 + time);\n    finalColor += n * 0.2;\n    \n    // Enhance grid lines using distance field\n    float distanceField = min(offset.x, offset.y) * 2.0;\n    finalColor *= smoothstep(0.0, 1.0, distanceField);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_967.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using HSL\n    vec3 c = hsl(0.5 + 0.2*sin(iTime*0.5 + uv.x * 10.), \n                 0.6, \n                 0.8);\n    \n    // Add noise to the color components\n    c += vec3(noise(uv * 400.0 + iTime), \n              noise(uv * 400.0 + iTime + 123.456),\n              noise(uv * 400.0 + iTime + 678.9));\n    \n    // Create a turbulent pattern\n    float t = turbulent(uv * 5.0 + vec2(sin(iTime), cos(iTime)));\n    \n    // Mix colors based on turbulence\n    c = mix(c, \n            hsl(0.1 + t*0.3, \n                0.7, \n                0.6),\n            max(t*2.0 - 0.5, 0.0));\n    \n    return vec4(c, 1.0);\n}"
  },
  "data_968.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a pulsating effect using time\n    float time = iTime * 0.5;\n    \n    // Add mouse movement influence (assuming mouse coordinates are normalized)\n    vec2 st = uv * 10.0 + time;\n    \n    // Use noise to create a dynamic pattern\n    float n = noise(st);\n    \n    // Create geometric patterns using polar coordinates\n    vec2 polar = vec2(length(uv), atan2(uv.y, uv.x));\n    \n    // Add turbulence for more complex movement\n    float turb = turbulent(polar * 0.5 + time);\n    \n    // Combine noise and turbulence with color transformations\n    vec3 color = hsl2rgb(vec3(\n        (n + turb) * 0.5 + 0.5,   // Hue\n        1.0 - abs(sin(time)),     // Saturation\n        0.5                       // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_969.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center and scale UV coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Create rotating pattern using polar coordinates\n    float angle = atan2(st.y, st.x) + iTime * 2.0;\n    float dist = length(st);\n    \n    // Use HSL color space for smooth transitions\n    vec3 hslColor = vec3(\n        fract(angle / (pi * 2.0)),  // Hue based on angle\n        sin(dist * 5.0 + iTime) * 0.5 + 0.5,  // Saturation varies with distance and time\n        0.5  // Lightness fixed at middle value\n    );\n    \n    // Convert to RGB and add noise for complexity\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor += noise(vec3(st * 5.0, iTime)) * 0.1;\n    rgbColor += turbulent(st * 10.0) * 0.1;\n    \n    // Mix colors with distance for smoother transitions\n    vec3 finalColor = mix(\n        rgbColor,\n        vec3(1.0),\n        smoothstep(0.8, 1.2, dist)\n    );\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_97.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create orbitron-style pattern with warping effects\n    vec2 center = vec2(0.5);\n    float radius = length(uv - center);\n    float angle = atan2(uv.y - center.y, uv.x - center.x);\n    \n    // Add time-based rotation and warping\n    angle += iTime * 0.5;\n    radius *= 1.0 + sin(iTime) * 0.5;\n    \n    // Convert back to cartesian coordinates\n    vec2 transformedUV = center + vec2(cos(angle), sin(angle)) * radius;\n    \n    // Add turbulence for warping effect\n    float warpAmount = turbulent(transformedUV * 4.0 + iTime);\n    transformedUV += transformedUV * warpAmount * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color = hsl2rgb(vec3(\n        mod(angle * 10.0 + iTime, 1.0),\n        0.7,\n        0.5 + turbulent(transformedUV * 8.0) * 0.5\n    ));\n    \n    // Add depth using noise\n    color *= noise(vec3(uv * 4.0, iTime)) * 0.5 + 0.5;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_970.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and rotate coordinates over time\n    vec2 st = uv * 5.0;\n    float time = iTime * 0.5;\n    \n    // Create a rotation matrix\n    mat2 rot = mat2(cos(time), -sin(time), sin(time), cos(time));\n    st = st * rot;\n    \n    // Compute noise layers with different scales\n    float n1 = noise(st * 0.5);\n    float n2 = noise(st + vec2(123.456, 789.123)) * 0.5;\n    float n3 = noise(vec3(st * 2.0, time)) * 0.25;\n    \n    // Combine noise values with time-based variation\n    float value = (n1 + n2 + n3) * 0.5 + 0.5;\n    value += sin(time * 2.0) * 0.2;\n    \n    // Create color shifts using HSL\n    vec3 color = hsl2rgb(vec3(\n        fract(value * 4.0 + time),  // Hue variation\n        0.7,                       // Saturation\n        0.5 + value * 0.5          // Value modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_971.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar coordinates\n    float r = length(uv);\n    float theta = atan2(uv.y, uv.x);\n    \n    // Add rotation over time\n    theta += iTime * 0.5f; // Rotate at 0.5 radians per second\n    \n    // Create color transitions using HSL colors\n    vec3 color1 = hsl(0.0, 0.7, 0.6);   // Red base color\n    vec3 color2 = hsl(pi, 0.7, 0.6);    // Cyan base color\n    \n    // Interpolate between colors based on radius and angle\n    float mixRatio = r * 0.5 + 0.5;\n    vec3 finalColor = mix(color1, color2, mixRatio);\n    \n    // Add noise for dynamic effect\n    float noiseValue = turbulent(uv * 5.0) * 0.2;\n    finalColor += noiseValue;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_972.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for circular patterns\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + sin(iTime) * 3.0;\n    \n    // Create multiple rotating layers using time-based sine functions\n    float layer1 = sin(theta + iTime * 0.5) * 0.5 + 0.5;\n    float layer2 = sin(theta + iTime * 0.7 + PI) * 0.5 + 0.5;\n    \n    // Combine layers with different frequencies\n    vec3 colorBase = hsl2rgb(vec3(\n        (theta / (2.0 * PI) + 0.5 * sin(iTime)) * 360.0, \n        1.0, \n        0.5\n    ));\n    \n    // Add noise and turbulence for more dynamic patterns\n    float noiseValue = turbulent(vec3(uv * 4.0, iTime));\n    colorBase *= mix(1.0, 0.8, abs(noiseValue));\n    \n    // Create a circular gradient effect\n    vec3 finalColor = mix(\n        colorBase,\n        hsl2rgb(vec3(\n            (theta / (2.0 * PI) + 0.5 * cos(iTime)) * 360.0,\n            1.0,\n            0.7\n        )),\n        smoothstep(0.8, 1.0, r)\n    );\n    \n    // Add some pulsing animation to the center\n    finalColor *= mix(1.0, 1.5, sin(iTime * 2.0 + theta) * 0.3 + 0.7);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_973.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5;\n    \n    // Create kaleidoscopic effect by mirroring angles\n    theta = mod(theta, pi/2.0) * 2.0;\n    theta = fract(theta / (pi*2.0)) * pi*2.0;\n    \n    // Generate pattern using trigonometric functions and noise\n    float pattern = sin(theta * 4.0 + iTime) * cos(r * 10.0 - iTime);\n    pattern += turbulent(vec3(theta, r, iTime * 0.5)) * 0.5;\n    \n    // Create vibrant color transitions using HSL\n    vec3 hslColor = vec3(\n        fract(iTime * 0.2 + theta / (pi*2.0)) * 360.0,\n        0.7 + 0.3 * sin(iTime * 0.5 + r * 10.0),\n        0.5 + 0.5 * pattern\n    );\n    \n    // Convert to RGB and output\n    vec3 color = hsl2rgb(hslColor);\n    return vec4(color, 1.0);\n}"
  },
  "data_974.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Animate based on time\n    float t = iTime * 0.5;\n    \n    // Create rotating pattern with UV coordinates\n    vec2 st = uv - 0.5;\n    float angle = length(st) * 10.0 + t * 2.0;\n    vec2 rotated = vec2(\n        cos(angle) * st.x - sin(angle) * st.y,\n        sin(angle) * st.x + cos(angle) * st.y\n    );\n    \n    // Create color gradient with HSL\n    vec3 color1 = hsl(length(rotated) * 0.5, 0.7, 0.6);\n    vec3 color2 = hsl(length(rotated) * 0.5 + 0.5, 0.7, 0.6);\n    \n    // Mix colors based on sine wave pattern\n    float mixAmount = sin(length(st) * 4.0 + t) * 0.5 + 0.5;\n    vec3 mixedColor = mix(color1, color2, mixAmount);\n    \n    // Add undulating noise effect\n    float noiseValue = noise(vec3(uv * 8.0 + t, t)) * 0.5;\n    mixedColor += noiseValue;\n    \n    // Create darkening effect towards edges\n    float edgeDarken = smoothstep(1.0, 0.0, length(uv - 0.5) * 2.0);\n    mixedColor *= edgeDarken;\n    \n    return vec4(mixedColor, 1.0);\n}"
  },
  "data_975.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a coordinate system centered at 0.5\n    vec2 st = uv - 0.5;\n    \n    // Add rotation based on time\n    float angle = sin(iTime * 0.5) + cos(iTime * 0.3);\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotated = rot * st;\n    \n    // Create a scaling factor that changes over time\n    float scale = 1.0 + 0.5 * sin(iTime * 0.7);\n    rotated *= scale;\n    \n    // Add noise to create organic movement\n    vec3 noisePos = vec3(rotated, iTime * 0.2);\n    float n = noise(noisePos) * 0.5 + 0.5;\n    \n    // Create color based on position and time\n    vec3 hslColor = vec3(\n        sin(iTime * 0.1 + rotated.x * 2.0) * 0.5 + 0.5,\n        0.7,\n        0.8\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Create a pattern using multiple layers of lines\n    float layer1 = sin(rotated.x * 4.0 + iTime) * 0.5;\n    float layer2 = cos(rotated.y * 4.0 + iTime * 0.7) * 0.5;\n    \n    // Combine layers and noise for final pattern\n    float pattern = (layer1 + layer2 + n) * 0.333;\n    \n    // Create the final color with alpha\n    vec4 finalColor = vec4(rgbColor, 1.0);\n    \n    return finalColor;\n}"
  },
  "data_976.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float t = iTime * 0.5;\n    \n    // Create shifting pattern using sine and noise\n    float pattern = sin(uv.x * 10.0 + t) * 0.5 + 0.5;\n    pattern += noise(vec2(uv.x * 5.0, t)) * 0.3;\n    pattern += turbulent(vec2(uv.x * 2.0, t)) * 0.2;\n    \n    // Create smooth color transitions\n    vec3 color = hsl2rgb(vec3(\n        (uv.y + sin(t) * 0.5 + 0.5) * 360.0,  // Hue\n        0.7,                                    // Saturation\n        0.5 + pattern * 0.5                     // Lightness\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_977.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates based on time\n    float t = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        cos(t)*uv.x - sin(t)*uv.y,\n        sin(t)*uv.x + cos(t)*uv.y\n    );\n    \n    // Create square grid pattern\n    vec2 st = rotatedUv * 10.0;\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    // Check if inside square\n    float square = step(0.5, min(fpos.x, fpos.y)) *\n                  step(0.5, max(fpos.x, fpos.y));\n    \n    // Calculate color based on position and time\n    vec3 color;\n    {\n        float hue = (ipos.x + ipos.y) * 0.1 + sin(t*2.0);\n        float sat = 0.7 + 0.3*sin(uv.x*5.0 + t*3.0);\n        float lig = 0.5 + 0.5*cos(uv.y*5.0 + t*4.0);\n        \n        color = hsl2rgb(vec3(hue, sat, lig));\n    }\n    \n    // Add noise effect\n    vec2 noisePos = rotatedUv * 5.0;\n    float n = noise(noisePos) * 0.1;\n    color *= 1.0 + n;\n    \n    // Create final output\n    return vec4(color * square, 1.0);\n}"
  },
  "data_978.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.25;\n    \n    // Create a grid of rotating squares\n    vec2 st = uv * 10.0 - 5.0;\n    st = fract(abs(st)) - 0.5;\n    \n    // Rotate each square based on time\n    float angle = sin(time) * 0.5 + 0.5;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotated = rot * st;\n    \n    // Create square mask\n    float square = max(abs(rotated.x), abs(rotated.y)) < 0.5 ? 1.0 : 0.0;\n    \n    // Add noise and color variations\n    vec3 color = vec3(\n        sin(time + uv.x * 2.0) * 0.5 + 0.5,\n        sin(time + uv.y * 2.0) * 0.5 + 0.5,\n        sin(time + (uv.x + uv.y) * 2.0) * 0.5 + 0.5\n    );\n    \n    // Mix in some HSL colors for vibrancy\n    vec3 hslColor = vec3(\n        time * 10.0,\n        0.7,\n        0.6\n    );\n    color += hsl2rgb(hslColor) * 0.5;\n    \n    // Add turbulence effect\n    float turb = turbulent(uv * 4.0 + time);\n    color *= square * (1.0 + turb * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_979.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the UV coordinates\n    vec2 st = uv - 0.5;\n    \n    // Create rotation matrix\n    float angle = sin(iTime * 0.5 + length(st)) * 0.5 + iTime * 0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    \n    // Apply rotation and create pulsating effect\n    vec2 rotated = rot * st * (0.5 + 0.5 * sin(iTime * 2.0 + length(st) * 10.0));\n    \n    // Add turbulence to position\n    vec2 pos = rotated + turbulent(rotated * 10.0 + iTime) * 0.1;\n    \n    // Create color transitions using HSL\n    float hue = fract(iTime * 0.2 + length(pos) * 5.0);\n    vec3 color1 = hsl(hue, 1.0, 0.5);\n    vec3 color2 = hsl(hue + 0.5, 1.0, 0.5);\n    \n    // Combine colors based on position\n    float blend = smoothstep(0.0, 1.0, sin(length(pos) * 5.0 + iTime * 2.0));\n    vec3 finalColor = mix(color1, color2, blend);\n    \n    // Add noise to create dynamic patterns\n    finalColor *= 1.0 + noise(vec3(pos * 10.0, iTime)) * 0.5;\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_98.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates around center\n    vec2 st = uv * 2.0 - 1.0;\n    float t = iTime * 0.5;\n    \n    // Apply rotation matrix\n    vec2 rotated = vec2(\n        st.x * cos(t) - st.y * sin(t),\n        st.x * sin(t) + st.y * cos(t)\n    );\n    \n    // Add noise and turbulence\n    float noiseVal = noise(rotated * 0.5 + iTime);\n    float turb = turbulent(rotated * 10.0);\n    \n    // Create orbital pattern using polar coordinates\n    vec2 polar = rotated;\n    float angle = atan2(polar.y, polar.x) + t;\n    float radius = length(polar) * 0.75;\n    \n    // Generate color using HSL to RGB conversion\n    vec3 color = hsl(angle * 0.1, 0.8, 0.6);\n    color *= (1.0 + turb * 0.5);\n    \n    // Add radial gradient\n    float dist = length(rotated) * 0.5;\n    color *= 1.0 - dist;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_980.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float theta = atan2(st.y, st.x);\n    \n    // Add time-based rotation\n    theta += iTime * 0.5 + turbulent(vec3(uv * 10.0, iTime)) * 0.2;\n    \n    // Create geometric pattern using trigonometric functions\n    float pattern = sin(theta * 6.0) * cos(r * 8.0 - iTime * 2.0);\n    pattern += sin(theta * 3.0 + iTime) * cos(r * 4.0);\n    \n    // Add noise and turbulence for more dynamic effect\n    vec2 noiseUV = uv * 10.0 + iTime;\n    float noiseValue = noise(noiseUV);\n    pattern = mix(pattern, turbulent(vec2(uv * 5.0)), noiseValue * 0.5);\n    \n    // Convert to color using HSL to RGB conversion\n    vec3 color = hsl2rgb(vec3(\n        fract(iTime * 0.1 + theta * 0.2),\n        0.7,\n        0.5 + pattern * 0.4\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_981.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Offset coordinates based on time for movement\n    vec2 st = uv + 0.5 * sin(iTime) * vec2(0.1);\n    \n    // Create shifting pattern using turbulence\n    float t = turbulent(st * 10.0 + vec2(sin(iTime), cos(iTime)) * 5.0);\n    \n    // Convert to HSL color space for dynamic coloring\n    vec3 hslColor = vec3(\n        sin(iTime * 2.0) * 0.5 + 0.5,   // Hue variation over time\n        1.0,                             // Full saturation\n        abs(t * 0.5 + 0.5)               // Lightness based on turbulence\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_982.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base pattern using time and position\n    float d = sin(uv.x * 10.0 + iTime) * 0.5 + 0.5;\n    \n    // Add noise variation\n    vec2 noisePos = uv * 5.0 + vec2(iTime);\n    float n = noise(noisePos);\n    \n    // Create turbulence effect\n    vec2 turbPos = uv * 10.0 + vec2(sin(iTime), cos(iTime));\n    float t = turbulent(turbPos);\n    \n    // Combine effects and create color\n    vec3 color = hsl(\n        sin(uv.y * 5.0 + iTime) * 0.5 + 0.5,   // Hue variation\n        0.7 + n * 0.3,                         // Saturation\n        0.5 + t * 0.5                          // Lightness\n    );\n    \n    // Create shifting lines effect\n    float line = sin(d * 10.0 + iTime) * 0.5 + 0.5;\n    color *= line;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_983.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create flowing pattern using sine waves and noise\n    float time = iTime * 0.5;\n    \n    // Combine position and time for dynamic patterns\n    vec2 st = uv * 10.0 + vec2(sin(time), cos(time));\n    \n    // Add turbulence to create complex flow\n    float turb = turbulent(st);\n    \n    // Create color variations using HSL\n    vec3 color = hsl(\n        sin(uv.x * 5.0 + time) * 0.5 + 0.5,   // Hue variation\n        0.7,                                    // Saturation\n        0.5 + turb * 0.2                       // Lightness with turbulence\n    );\n    \n    // Convert to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_984.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 st = uv * 5.0 + vec2(sin(iTime)*3.0, cos(iTime*0.7)*2.0);\n    \n    // Generate noise pattern with time variation\n    float turbulentValue = turbulent(st + iTime);\n    \n    // Create color from noise values\n    vec3 color = hsl2rgb(vec3(\n        (turbulentValue + iTime) * 0.5,   // Hue\n        0.7 + turbulentValue*0.3,         // Saturation\n        0.5 + turbulent(st*0.5)*0.5       // Lightness with additional turbulence\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_985.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create polar coordinates from UV\n    vec2 st = uv - 0.5;\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5;\n    \n    // Generate noise values with time offset\n    float n1 = noise(vec3(r * 10.0, theta * 10.0, iTime));\n    float n2 = noise(vec3(uv * 10.0 + iTime, 0.0));\n    \n    // Create color from HSL values\n    vec3 color = hsl2rgb(vec3(\n        (theta / PI) * 0.5 + 0.5,\n        abs(n1) * 0.7 + 0.3,\n        abs(n2) * 0.6 + 0.4\n    ));\n    \n    // Add turbulence effect\n    float turb = turbulent(vec3(uv * 10.0, iTime));\n    color = mix(color, vec3(0.5), abs(turb) * 0.3);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_986.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Center the coordinates\n    vec2 st = uv - 0.5;\n    \n    // Create polar coordinates\n    float angle = atan2(st.y, st.x);\n    float radius = length(st);\n    \n    // Add time-based rotation\n    angle += iTime * 0.1;\n    \n    // Create sine wave patterns with different frequencies and phases\n    float r = sin(radius * 8.0 + angle) * 0.5 + 0.5;\n    float g = sin(radius * 8.0 + angle + 2.094) * 0.5 + 0.5; // 120 degrees offset\n    float b = sin(radius * 8.0 + angle - 2.094) * 0.5 + 0.5; // 120 degrees offset\n    \n    // Add some noise for extra complexity\n    vec3 noise = vec3(turbulent(st * 4.0));\n    \n    // Combine colors and noise\n    vec3 color = vec3(r, g, b) * (0.7 + noise);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_987.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV to polar coordinates for rotation effect\n    float angle = atan2(uv.y, uv.x) + iTime * 2.0;\n    float radius = length(uv);\n    \n    // Create multiple rotating rings with pulsating effects\n    radius += sin(radius * 10.0 + iTime) * 0.2;\n    radius += sin(mod(angle, pi / 4.0)) * 0.3;\n    radius += sin(mod(angle * 8.0, pi)) * 0.15;\n    // Create pulsating color effect\n    vec3 color = hsl2rgb(vec3(\n        fract(radius * 0.1 + iTime) * pi,\n        0.8,   // Saturation\n        0.5    // Lightness\n    ));\n    return vec4(color * smoothstep(0.0, 1.0, 1.0 - length(uv)), 1.0);\n}"
  },
  "data_988.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a kaleidoscope effect by mirroring coordinates\n    vec2 st = uv * 5.0; // Scale up for more tiles\n    \n    // Add some rotation based on time\n    float angle = atan2(st.y, st.x);\n    angle += sin(iTime * 0.5) * 3.1416;\n    \n    // Convert back to cartesian coordinates\n    vec2 pos = vec2(\n        cos(angle) * length(st),\n        sin(angle) * length(st)\n    );\n    \n    // Apply turbulence for dynamic patterns\n    float turb = turbulent(pos * 0.5 + iTime);\n    \n    // Mirror coordinates multiple times\n    st.x = mod(abs(st.x), 1.0);\n    st.y = mod(abs(st.y), 1.0);\n    \n    // Create symmetry by reflecting across both axes\n    if (st.x > 0.5) st.x = 1.0 - st.x;\n    if (st.y > 0.5) st.y = 1.0 - st.y;\n    \n    // Add noise to create dynamic color variations\n    float n = noise(st * 4.0 + iTime);\n    vec3 col = hsl2rgb(vec3(\n        fract(iTime * 0.1 + pos.x),\n        0.7,\n        0.5 + 0.5 * sin(n * 3.1416)\n    ));\n    \n    // Mix colors based on turbulence\n    col *= vec3(0.5) + vec3(turb);\n    \n    return vec4(col, 1.0);\n}"
  },
  "data_989.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using polar coordinates\n    vec2 center = uv - 0.5;\n    float angle = atan(center.y, center.x);\n    float dist = length(center);\n    \n    // Add time-based rotation\n    angle += iTime * 0.5;\n    \n    // Create kaleidoscopic effect by mirroring\n    vec2 mirroredUV = fract(abs(sin(angle) * uv + cos(angle)));\n    \n    // Generate triangle pattern using distance field\n    float triangle = abs(mirroredUV.x - mirroredUV.y);\n    triangle = smoothstep(0.3, 0.7, triangle);\n    \n    // Add turbulence for dynamic effect\n    vec2 noiseUV = mirroredUV * 10.0;\n    float turbulence = turbulent(noiseUV + iTime);\n    \n    // Create vibrant colors using HSL\n    vec3 color = hsl(\n        fract(iTime * 0.2) * 360.0,   // Hue variation over time\n        0.7 + triangle * 0.3,         // Saturation\n        0.5 + turbulence * 0.5        // Lightness modulation\n    );\n    \n    // Combine effects and output\n    return vec4(color * (1.0 - triangle), 1.0);\n}"
  },
  "data_99.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating pattern using sine and cosine\n    float time = iTime * 0.5;\n    vec2 st = uv * 2.0 - 1.0;\n    \n    // Add noise and turbulence for sparkles\n    float n = noise(st + vec2(sin(time), cos(time))) * 0.5 + 0.5;\n    float t = turbulent(st * 4.0) * 0.5 + 0.5;\n    \n    // Create color from HSL values\n    vec3 color = hsl2rgb(vec3(\n        (st.x + st.y + time) * 0.5 + 0.5,\n        0.7,\n        n * t * 0.8 + 0.2\n    ));\n    \n    // Add lighting effect\n    float dist = length(st);\n    color *= smoothstep(1.0, 0.0, dist) * 2.0;\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_990.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create rotating coordinate system\n    float t = iTime * 0.5;\n    vec2 st = uv * 10.0;\n    \n    // Add rotation based on time\n    st = mat2(cos(t), sin(t), -sin(t), cos(t)) * (st - 5.0) + 5.0;\n    \n    // Create flowing pattern using noise and turbulence\n    float noiseVal = turbulent(st);\n    vec3 color = hsl2rgb(vec3(\n        mod(length(st) * 0.1 + t, 1.0),  // Hue variation\n        0.7,                              // Saturation\n        0.5 + noiseVal * 0.5              // Brightness modulation\n    ));\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_991.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Translate UV to center coordinates\n    vec2 st = uv - 0.5;\n    \n    // Add rotation based on time\n    float angle = atan2(st.y, st.x) + 0.5 * iTime;\n    \n    // Calculate radius with expansion over time\n    float r = length(st);\n    r += sin(iTime) * 0.5;\n    \n    // Create concentric circles pattern\n    float circleIndex = floor(r * 10.0); // Number of circles\n    float smoothTransition = fract(circleIndex / 10.0 + 0.5 * sin(iTime));\n    \n    // Generate color transitions using HSL\n    vec3 hslColor;\n    hslColor.x = (circleIndex / 10.0 + 0.5 * sin(iTime)) * PI; // Hue variation\n    hslColor.y = 0.7; // Saturation\n    hslColor.z = 0.5; // Lightness\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(hslColor), 1.0);\n}"
  },
  "data_992.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    float time = iTime * 0.5;\n    \n    // Create wave patterns using sine and cosine functions\n    vec2 st = uv * 8.0; // Scale coordinates for more detailed pattern\n    float waveX = sin(st.x + time) * 0.5 + 0.5;\n    float waveY = cos(st.y - time) * 0.5 + 0.5;\n    \n    // Combine waves and add pulsation effect\n    float intensity = (waveX + waveY) / 2.0;\n    intensity = mod(intensity + sin(time * 3.0), 1.0);\n    \n    // Create color transition using HSL to RGB conversion\n    vec3 colorA = hsl2rgb(vec3(0.0, 1.0, 0.5)); // Green base color\n    vec3 colorB = hsl2rgb(vec3(0.7, 1.0, 0.5)); // Purple transition color\n    \n    // Mix colors based on intensity and add pulsation\n    vec3 finalColor = mix(colorA, colorB, intensity);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_993.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to a polar system with rotation over time\n    vec2 center = vec2(0.5, 0.5);\n    vec2 st = uv - center;\n    float angle = iTime * 0.1;\n    mat2 rotMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 rotatedSt = rotMatrix * st;\n    // Create a grid pattern with cells\n    vec2 gridPos = floor(rotatedSt * 10.0);\n    vec2 cellCenter = (gridPos + 0.5) / 10.0;\n    \n    // Calculate turbulence for added complexity\n    float t2d = turbulent(cellCenter + iTime * 0.1);\n    float t3d = turbulent(vec3(cellCenter, iTime * 0.1));\n    \n    // Create pulsing color effect using HSV\n    vec3 hsvColor = vec3(180.0, 0.7, 0.5); // Base cyan color\n    hsvColor.z *= sin(iTime + gridPos.x * 2.0) * 0.5 + 0.5; // Pulsing intensity\n    \n    // Combine turbulence with color parameters\n    hsvColor.y += t3d * 0.3;\n    hsvColor.z += (t2d + t3d) * 0.2;\n    \n    // Convert to RGB and output\n    return vec4(hsv2rgb(hsvColor), 1.0);\n}"
  },
  "data_994.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base frequency modulation\n    float freq = sin(iTime * 0.5 + 3.1415926) * 50.0;\n    \n    // Dynamic color components using sine waves and noise\n    vec3 hslColor = vec3(\n        sin(freq * uv.x + iTime) * 0.5 + 0.5,\n        noise(vec2(uv.y * 10.0, iTime)) * 0.5 + 0.5,\n        sin(freq * uv.y - iTime) * 0.5 + 0.5\n    );\n    \n    // Convert HSL to RGB and add turbulence effect\n    vec3 rgbColor = hsl2rgb(hslColor);\n    rgbColor += vec3(\n        turbulent(vec2(uv.x * 10.0, uv.y * 10.0) + iTime),\n        turbulent(vec2(uv.x * 5.0, uv.y * 5.0) + iTime * 0.5),\n        turbulent(vec2(uv.x * 2.0, uv.y * 2.0) + iTime * 0.75)\n    ) * 0.3;\n    \n    // Add smooth sine wave transitions\n    float transition = sin(iTime * 0.2 + uv.x * 10.0) * 0.5 + 0.5;\n    rgbColor = mix(rgbColor, vec3(0.2), transition);\n    \n    return vec4(rgbColor, 1.0);\n}"
  },
  "data_995.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Create a base color using UV coordinates and time\n    vec3 baseColor = hsl(uv.x * 0.5 + 0.5, uv.y * 0.5 + 0.5, 0.5);\n    \n    // Add flowing movement using noise and turbulence\n    float flow1 = turbulent(uv * 10.0) * 0.5;\n    float flow2 = turbulent(vec3(uv * 5.0, iTime)) * 0.3;\n    \n    // Combine flows and create a shifting color pattern\n    vec3 color = hsl(\n        uv.x + iTime * 0.1 + flow1 + flow2,\n        0.7 + noise(uv * 8.0) * 0.3,\n        0.5 + turbulent(uv * 4.0) * 0.2\n    );\n    \n    // Convert HSL to RGB and output\n    return vec4(hsl2rgb(color), 1.0);\n}"
  },
  "data_996.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 10.0; // Scale up for grid effect\n    float r = length(st);\n    float theta = atan2(st.y, st.x) + iTime * 0.5; // Add time-based rotation\n    \n    // Create smooth color transitions using HSL\n    vec3 hslColor;\n    hslColor.x = (theta * 0.15 + iTime * 0.2) + 0.5; // Hue variation with time\n    hslColor.y = 0.7 + turbulent(vec2(r, theta)) * 0.3; // Saturation modulation\n    hslColor.z = 0.5 + sin(r * 0.1 - iTime) * 0.5; // Lightness variation\n    \n    // Add turbulence for dynamic noise effect\n    float turb = turbulent(vec2(r, theta));\n    vec3 color = hsl2rgb(hslColor);\n    \n    return vec4(color, 1.0);\n}"
  },
  "data_997.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Rotate coordinates over time\n    float angle = iTime * 0.5;\n    vec2 rotatedUv = vec2(\n        uv.x * cos(angle) - uv.y * sin(angle),\n        uv.x * sin(angle) + uv.y * cos(angle)\n    );\n    // Create grid pattern with triangles\n    vec2 gridPos = fract(rotatedUv * 10.0);\n    float triangle = step(0.5, gridPos.x + gridPos.y);\n    // Calculate color based on time and position\n    vec3 hslColor = vec3(\n        (iTime + gridPos.x * 2.0) * 0.1,\n        0.7,\n        0.5\n    );\n    vec3 rgbColor = hsl2rgb(hslColor);\n    // Add glowing edges using distance field\n    float edgeDistance = min(gridPos.x, gridPos.y);\n    edgeDistance = smoothstep(0.4, 0.6, edgeDistance);\n    \n    // Combine color and glow effect\n    vec3 finalColor = rgbColor * (1.0 + edgeDistance * 0.5);\n    return vec4(finalColor, 1.0);\n}"
  },
  "data_998.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Base color using HSL for easy hue manipulation\n    vec3 baseColor = hsl2rgb(vec3(0.5 + 0.5 * sin(iTime * 0.5), 1.0, 0.6));\n    \n    // Add turbulence to create flickering effect\n    float t = turbulent(uv * 0.5) * 0.5;\n    t += turbulent(uv * 0.25 + vec2(sin(iTime)) * 0.5) * 0.3;\n    \n    // Create sine wave modulation for flicker\n    float flicker = sin(iTime * 4.0 + uv.x * 10.0);\n    flicker = (flicker + 1.0) * 0.5; // Scale to 0-1\n    \n    // Combine colors and add noise\n    vec3 finalColor = baseColor * (t * 2.0 + 0.5);\n    finalColor += noise(vec3(uv, iTime)) * 0.3;\n    \n    // Add flicker effect\n    finalColor *= mix(1.0, 1.5, flicker);\n    \n    return vec4(finalColor, 1.0);\n}"
  },
  "data_999.json": {
    "src": "vec4 Effect2(vec2 uv) {\n    // Scale and animate UV coordinates\n    vec2 pos = uv * 10.0 + iTime;\n    \n    // Create a flowing wave pattern using turbulence\n    float wave1 = turbulent(pos);\n    \n    // Add another layer of waves with different scale and movement\n    vec2 pos2 = uv * 5.0 + vec2(iTime, iTime * 0.7);\n    float wave2 = turbulent(pos2);\n    \n    // Combine waves for more complex pattern\n    float finalWave = (wave1 + wave2) * 0.5;\n    \n    // Create color transitions using HSL\n    vec3 color1 = hsl(iTime * 0.1 + uv.x * 2.0, 0.7, 0.6);\n    vec3 color2 = hsl(iTime * 0.15 + uv.y * 2.0, 0.8, 0.5);\n    \n    // Mix colors based on wave pattern\n    vec3 finalColor = mix(color1, color2, sin(finalWave * pi + iTime));\n    \n    return vec4(finalColor, 1.0);\n}"
  }
}