{
  "src": "vec4 Effect2(vec2 uv) {\n    // code here\n}\nvec2 coord = uv - vec2(0.5);\nfloat r = length(coord);\nfloat theta = atan2(coord.y, coord.x);\ntheta += iTime * (1.0 + r * 2.0);\nfloat s = abs(sin(theta));\nfloat c = abs(cos(theta));\nfloat sc = (s + c) * 0.5;\ntheta += iTime * (1.0 + r * 2.0) * 2.5;\ns = abs(sin(theta));\nc = abs(cos(theta));\nfloat sc2 = (s + c) * 0.5;\nfloat pattern = sc * 3.0 + sc2;\nfloat color = (pattern + 0.5 * (1.0 - r)) * 0.5;\ncolor += length(uv) * 0.2;\nvec3 finalColor = hsl(color * 0.3 + 0.1, 0.8, 0.5);\nvec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form\n    vec2 coord = uv - vec2(0.5);\n    float r = length(coord);\n    float theta = atan2(coord.y, coord.x);\n    \n    // Create rotating pattern with increasing speed from center\n    theta += iTime * (1.0 + r * 2.0); // Speed increases with distance\n    \n    // Create square pattern using sine and cosine\n    float s = abs(sin(theta));\n    float c = abs(cos(theta));\n    float sc = (s + c) * 0.5;\n    \n    // Add another layer of squares for complexity\n    theta += iTime * (1.0 + r * 2.0) * 2.5; // Faster rotation\n    s = abs(sin(theta));\n    c = abs(cos(theta));\n    float sc2 = (s + c) * 0.5;\n    \n    // Combine patterns and create gradient fill\n    float pattern = sc * 3.0 + sc2;\n    float color = (pattern + 0.5 * (1.0 - r)) * 0.5; // Gradient based on distance\n    \n    // Add some depth to the pattern\n    color += length(uv) * 0.2;\n    \n    // Convert to RGB using HSL for better control over colors\n    vec3 finalColor = hsl(color * 0.3 + 0.1, 0.8, 0.5); // Greenish hue\n    \n    return vec4(finalColor, 1.0);\n}"
}