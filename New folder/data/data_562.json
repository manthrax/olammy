{
  "src": "vec4 Effect2(vec2 uv) {\n    // Parameters for circles\n    const int numCircles = 8;\n    const float sizeVariation = 0.15;\n    const float speed = 0.7;\n    const float rotationSpeed = 0.3;\n    vec3 finalColor = vec3(0.0);\n    \n    for (int i = 0; i < numCircles; i++) {\n        // Calculate circle center with rotation\n        float angle = (i * 0.5 + iTime * speed) * pi;\n        vec2 center = vec2(sin(angle) * 0.5, cos(angle * 0.7) * 0.5);\n        \n        // Circle properties\n        float radius = 0.3 + sin(iTime * rotationSpeed + i * 0.5) * sizeVariation;\n        float rotate = iTime * rotationSpeed + i * 0.5;\n        \n        // Calculate distance from current uv to circle center\n        vec2 offset = uv - center;\n        float dist = length(offset);\n        \n        // Create rotating color gradient\n        if (dist < radius) {\n            float angle = atan2(offset.y, offset.x) + rotate;\n            float hue = fract((angle * 0.5 + iTime * 0.1) / pi);\n            vec3 color = hsl2rgb(vec3(hue, 0.7, 0.6));\n            \n            // Add noise for dynamic effect\n            float noiseValue = turbulent(uv * 8.0 + iTime) * 0.1;\n            color *= 1.0 + noiseValue;\n            \n            finalColor += color * (radius - dist) / radius;\n        }\n    }\n    \n    // Add global turbulence effect\n    vec2 noiseUV = uv * 4.0 + iTime;\n    float globalTurbulence = turbulent(noiseUV) * 0.3;\n    finalColor *= 1.0 + globalTurbulence;\n    \n    return vec4(finalColor, 1.0);\n}"
}