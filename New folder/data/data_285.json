{
  "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal tiling\n    vec2 st = uv * 2.0 - 1.0;\n    float theta = atan2(st.y, st.x);\n    float r = length(st);\n    \n    // Create hexagonal grid by quantizing polar coordinates\n    float angleSteps = 6.0; // Number of angles for hexagons\n    float radiusSteps = 8.0; // Number of rings\n    \n    // Quantize angle and radius into discrete steps\n    float quantizedTheta = floor(theta / (pi * 2.0 / angleSteps)) * (pi * 2.0 / angleSteps);\n    float quantizedR = floor(r * radiusSteps) / radiusSteps;\n    \n    // Convert back to cartesian coordinates for hexagon centers\n    vec2 center = vec2(cos(quantizedTheta), sin(quantizedTheta)) * quantizedR;\n    \n    // Calculate pulsing values based on time and position\n    float pulse = sin(iTime + quantizedR * 10.0 + quantizedTheta * 5.0) * 0.5 + 0.5;\n    \n    // Create color based on hexagon position and pulsing\n    vec3 hslColor = vec3(\n        mod(quantizedTheta / (pi * 2.0) * 360.0, 360.0), // Hue based on angle\n        1.0, // Full saturation\n        pulse // Lightness based on time\n    );\n    \n    // Convert HSL to RGB and apply smooth gradient\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Create distance field for hexagons with smooth edges\n    float dist = length(st - center);\n    float edgeSmooth = smoothstep(0.1, 0.2, dist);\n    \n    // Final color with pulsing effect\n    vec3 finalColor = mix(vec3(0.0), rgbColor, edgeSmooth);\n    \n    return vec4(finalColor, 1.0);\n}"
}