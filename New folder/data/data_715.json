{
  "src": "vec4 Effect2(vec2 uv) {\n    vec3 finalColor = vec3(0.0);\n    \n    // Create 8 orbiting points with random parameters\n    for (int i = 0; i < 8; i++) {\n        float timeOffset = noise(vec3(i, 0.0, 0.0)) * 10.0;\n        float radius = 0.2 + noise(vec3(i, 1.0, 0.0)) * 0.1;\n        float orbitSpeed = 0.5 + noise(vec3(i, 2.0, 0.0)) * 0.3;\n        \n        // Calculate point position in polar coordinates\n        float angle = (iTime + timeOffset) * orbitSpeed;\n        vec2 pointPos = vec2(cos(angle), sin(angle)) * radius;\n        \n        // Convert UV to polar coordinates relative to point\n        vec2 offsetUV = uv - pointPos;\n        float dist = length(offsetUV);\n        float angleUV = atan2(offsetUV.y, offsetUV.x);\n        \n        // Create expanding rings effect\n        float ringWidth = 0.05 + turbulent(vec3(uv * 10.0, iTime)) * 0.03;\n        float ringFactor = mod(dist - iTime * 0.1, ringWidth) / ringWidth;\n        \n        // Calculate color based on distance and time\n        vec3 color = hsl2rgb(vec3(\n            fract((iTime + dist * 5.0) * 0.1) * 360.0,\n            0.7 + turbulent(vec2(uv * 10.0)) * 0.3,\n            0.8 + ringFactor * 0.4\n        ));\n        \n        // Add to final color with distance attenuation\n        float attenuation = smoothstep(radius, 0.0, dist);\n        finalColor += color * attenuation;\n    }\n    \n    // Blend with background color\n    vec3 bgColor = hsl2rgb(vec3(iTime * 0.1 * 360.0, 0.1, 0.2));\n    finalColor = mix(bgColor, finalColor, min(finalColor.r + finalColor.g + finalColor.b, 1.0));\n    \n    return vec4(finalColor, 1.0);\n}"
}