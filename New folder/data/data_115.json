{
  "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for rotation\n    vec2 st = uv * 2.0 - 1.0;\n    float r = length(st);\n    float a = atan(st.y, st.x) + iTime;\n    // Create multiple layers of rotating triangles\n    const int layers = 5;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < layers; i++) {\n        // Vary scale and rotation speed per layer\n        float scale = pow(0.5, float(i));\n        float rotateSpeed = 1.0 + float(i) * 0.2;\n        \n        // Calculate rotated coordinates\n        vec2 rotatedUv = vec2(\n            cos(a * rotateSpeed) * st.x - sin(a * rotateSpeed) * st.y,\n            sin(a * rotateSpeed) * st.x + cos(a * rotateSpeed) * st.y\n        );\n        \n        // Create triangle vertices\n        float angleStep = 60.0;\n        vec3 angles = a + vec3(0.0, angleStep, -angleStep);\n        \n        // Calculate distance to each vertex\n        vec2 v1 = rotatedUv - vec2(cos(angles.x), sin(angles.x)) * scale;\n        vec2 v2 = rotatedUv - vec2(cos(angles.y), sin(angles.y)) * scale;\n        vec2 v3 = rotatedUv - vec2(cos(angles.z), sin(angles.z)) * scale;\n        \n        // Find minimum distance to triangle edges\n        float d1 = length(v1);\n        float d2 = length(v2);\n        float d3 = length(v3);\n        float minD = min(min(d1, d2), d3);\n        \n        // Create triangle mask\n        float mask = smoothstep(0.4, 0.5, minD);\n        \n        // Generate color per layer with noise variation\n        vec3 c = hsl(\n            (iTime + float(i)) * 0.1,\n            0.7 + noise(vec2(a, iTime)) * 0.3,\n            0.5 + noise(vec2(r, a)) * 0.5\n        );\n        \n        // Accumulate color with mask\n        color += c * mask;\n    }\n    \n    return vec4(color, 1.0);\n}"
}