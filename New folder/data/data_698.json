{
  "src": "vec4 Effect2(vec2 uv) {\n    // Create a swarm of lights with circular paths and color trails\n    const int numLights = 8;\n    float time = iTime * 0.5;\n    \n    // Array of light parameters (radius, initial angle offset)\n    float radii[numLights] = float[](\n        0.4, 0.35, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05\n    );\n    \n    // Array of initial angle offsets for each light\n    float angles[numLights] = float[](\n        0.0, pi/4.0, pi/2.0, 3.0*pi/4.0,\n        pi, 5.0*pi/4.0, 3.0*pi/2.0, 7.0*pi/4.0\n    );\n    \n    vec3 color = vec3(0.0);\n    \n    // Additive blending of multiple lights with trails\n    for (int i = 0; i < numLights; i++) {\n        float radius = radii[i];\n        float angleOffset = angles[i];\n        \n        // Circular motion with varying speed based on noise\n        float angle = time * mod(noise(vec3(i, time, 0.0)), 2.0) + angleOffset;\n        \n        // Polar to cartesian coordinates\n        vec2 pos = radius * vec2(cos(angle), sin(angle));\n        \n        // Create trailing effect by sampling multiple past frames\n        for (float t = -1.0; t <= 0.0; t += 0.5) {\n            float mixAmount = smoothstep(0.0, 1.0, abs(t));\n            \n            // Calculate position at previous time step\n            vec2 prevPos = radius * vec2(cos(angle + t), sin(angle + t));\n            \n            // Color based on angle and trail length\n            vec3 lightColor = hsv2rgb(vec3(\n                (angleOffset + t) / (2.0*pi) + 0.5,\n                1.0,\n                mix(0.8, 0.3, mixAmount)\n            ));\n            \n            // Additive blending with distance attenuation\n            float dist = length(uv - prevPos);\n            float falloff = smoothstep(0.2, 0.0, dist);\n            \n            color += lightColor * falloff * (1.0 - mixAmount);\n        }\n    }\n    \n    // Post-process the final color\n    color = pow(color, vec3(0.7)); // Gamma correction\n    \n    return vec4(color, 1.0);\n}"
}