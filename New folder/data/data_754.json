{
  "src": "vec4 Effect2(vec2 uv) {\n    vec2 center = uv * 2.0 - 1.0;\n    float time = iTime * 0.5;\n    \n    // Create rotating square pattern\n    vec2 rotated = vec2(\n        cos(time) * center.x - sin(time) * center.y,\n        sin(time) * center.x + cos(time) * center.y\n    );\n    \n    // Add multiple layers of squares with different rotations and colors\n    float square1 = max(abs(rotated.x), abs(rotated.y)) < 0.5;\n    float square2 = max(abs((rotated + vec2(sin(time))) * 0.7), abs((rotated - vec2(cos(time))) * 0.7)) < 0.3;\n    float square3 = max(abs(rotated.x * 1.5), abs(rotated.y * 1.5)) < 0.4;\n    \n    // Color each layer differently\n    vec3 color1 = mod(gl_FragCoord.y, 3.0) < 1.0 ? vec3(1.0, 0.0, 0.0) : \n           mod(gl_FragCoord.y, 3.0) < 2.0 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    \n    vec3 color2 = mod(gl_FragCoord.x + time, 3.0) < 1.0 ? vec3(1.0, 0.0, 0.0) :\n           mod(gl_FragCoord.x + time, 3.0) < 2.0 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    \n    // Combine squares with noise for randomness\n    float noiseVal = noise(vec2(time * 0.5, time * 0.7));\n    float finalShape = square1 + square2 + square3;\n    \n    // Create color transitions using HSL to RGB conversion\n    vec3 hslColor = vec3(\n        (time + noiseVal) * 2.0,\n        sin(time * 0.5) * 0.7 + 0.3,\n        cos(time * 0.5) * 0.5 + 0.5\n    );\n    \n    vec3 rgbColor = hsl(hslColor.x, hslColor.y, hslColor.z);\n    \n    // Mix colors based on square layers\n    vec3 finalColor = mix(color1, color2, square2) * (finalShape > 0.0 ? 1.0 : 0.0);\n    finalColor = mix(finalColor, rgbColor, square3);\n    \n    return vec4(finalColor, max(square1, max(square2, square3)) * 0.8 + 0.2);\n}"
}