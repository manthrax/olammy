{
  "src": "vec4 Effect2(vec2 uv) {\n    // Camera position and time-based movement\n    vec3 cameraPos = vec3(0.0, 0.0, -5.0 + sin(iTime * 0.5));\n    \n    // Grid of cubes\n    const int gridSize = 4;\n    float cubeSize = 1.0;\n    \n    // Light direction\n    vec3 lightDir = normalize(vec3(sin(iTime) * 2.0, cos(iTime) * 2.0, 1.0));\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(int x = -gridSize; x <= gridSize; x++) {\n        for(int y = -gridSize; y <= gridSize; y++) {\n            // Cube position\n            vec3 cubePos = vec3(float(x), float(y), 0.0) * 2.0;\n            \n            // Time-based floating animation\n            float timeOffset = sin(iTime + float(x) + float(y)) * 0.5;\n            cubePos.y += timeOffset;\n            \n            // View direction\n            vec3 viewDir = normalize(cameraPos - cubePos);\n            \n            // Calculate distance from camera\n            float dist = length(cameraPos - cubePos);\n            \n            // Cube dimensions\n            vec3 cubeDimensions = vec3(cubeSize, cubeSize, cubeSize);\n            \n            // Transform UV to 3D space\n            vec3 pos = (uv.xxy * 2.0 - 1.0) * vec3(16.0, 9.0, 1.0);\n            \n            // Check if inside cube\n            vec3 cubeDist = abs(pos - cubePos) / cubeDimensions;\n            float isInside = min(min(cubeDist.x, cubeDist.y), cubeDist.z);\n            \n            // Color based on position and time\n            vec3 color = hsl2rgb(vec3(\n                fract(sin(dot(cubePos.xy, vec2(12.9898,78.233))) * 43758.5453123) + iTime * 0.1,\n                0.6,\n                0.8\n            ));\n            \n            // Add noise to color\n            color *= noise(vec3(pos.xy, iTime)) * 0.3 + 0.7;\n            \n            // Shadow calculation\n            float shadow = turbulent((cubePos - lightDir * 2.0) / 4.0);\n            shadow = max(shadow - 0.5, 0.0) * 2.0;\n            \n            // Combine color and shadow\n            vec3 finalCubeColor = mix(color, vec3(0.1), shadow);\n            \n            // Add to final color with distance attenuation\n            if(isInside < 1.0 && dist < 15.0) {\n                finalColor += finalCubeColor / pow(dist * 0.1 + 1.0, 2.0);\n            }\n        }\n    }\n    \n    return vec4(finalColor, 1.0);\n}"
}