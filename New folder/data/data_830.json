{
  "src": "vec4 Effect2(vec2 uv) {\n    // Time-based rotation\n    float time = iTime * 0.5;\n    \n    // Cube position and size\n    const float cubeSize = 0.8;\n    vec3 lightDir = normalize(vec3(1.0, -1.0, 1.0));\n    vec3 viewDir = normalize(vec3(uv.x*2.0-1.0, uv.y*2.0-1.0, 1.0));\n    \n    // Cube faces\n    float d = 0.5;\n    vec3 faceDistances = vec3(\n        abs(uv.x - d) < cubeSize ? abs(uv.y - d) : 999.0,\n        abs(uv.x - d) < cubeSize ? abs(uv.y + d) : 999.0,\n        abs(uv.y - d) < cubeSize ? abs(uv.x - d) : 999.0\n    );\n    \n    // Find closest face\n    float minDist = min(min(faceDistances.x, faceDistances.y), faceDistances.z);\n    vec3 color = vec3(0.0);\n    \n    if (minDist == faceDistances.x) {\n        // Front face\n        vec2 pos = uv - vec2(d, d);\n        float angle = time;\n        vec2 rotatedPos = vec2(\n            pos.x * cos(angle) - pos.y * sin(angle),\n            pos.x * sin(angle) + pos.y * cos(angle)\n        );\n        \n        // Calculate normals and specular highlights\n        vec3 normal = normalize(vec3(0.0, 0.0, 1.0));\n        vec3 reflectedLight = reflect(lightDir, normal);\n        float spec = pow(max(dot(reflectedLight, viewDir), 0.0), 32.0);\n        \n        // Color with time-based hue shift\n        vec3 hslColor = hsl((time + uv.x * 0.5) * 10.0, 0.7, 0.6);\n        color = hsl2rgb(hslColor) * (0.8 + spec * 0.4);\n    } else if (minDist == faceDistances.y) {\n        // Back face\n        vec2 pos = uv - vec2(d, -d);\n        float angle = time;\n        vec2 rotatedPos = vec2(\n            pos.x * cos(angle) - pos.y * sin(angle),\n            pos.x * sin(angle) + pos.y * cos(angle)\n        );\n        \n        // Calculate normals and specular highlights\n        vec3 normal = normalize(vec3(0.0, 0.0, -1.0));\n        vec3 reflectedLight = reflect(lightDir, normal);\n        float spec = pow(max(dot(reflectedLight, viewDir), 0.0), 32.0);\n        \n        // Color with time-based hue shift\n        vec3 hslColor = hsl((time + uv.x * 0.5) * 10.0, 0.7, 0.6);\n        color = hsl2rgb(hslColor) * (0.8 + spec * 0.4);\n    } else {\n        // Side faces\n        vec2 pos = uv - vec2(d, d);\n        float angle = time;\n        vec2 rotatedPos = vec2(\n            pos.x * cos(angle) - pos.y * sin(angle),\n            pos.x * sin(angle) + pos.y * cos(angle)\n        );\n        \n        // Calculate normals and specular highlights\n        vec3 normal = normalize(vec3(1.0, 0.0, 0.0));\n        vec3 reflectedLight = reflect(lightDir, normal);\n        float spec = pow(max(dot(reflectedLight, viewDir), 0.0), 32.0);\n        \n        // Color with time-based hue shift\n        vec3 hslColor = hsl((time + uv.y * 0.5) * 10.0, 0.7, 0.6);\n        color = hsl2rgb(hslColor) * (0.8 + spec * 0.4);\n    }\n    \n    // Add noise for extra detail\n    float noiseValue = noise(vec3(uv, time)) * 0.1;\n    color += noiseValue;\n    \n    return vec4(color, 1.0);\n}"
}