{
  "src": "vec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 polar = vec2(length(uv), atan2(uv.y, uv.x));\n    \n    // Multiply angle by 6 for hexagonal symmetry and add rotation over time\n    polar.y *= 6.0;\n    polar.y += sin(iTime) * 0.5;\n    \n    // Create a pulsating pattern based on radius and time\n    float pattern = sin(polar.x + iTime);\n    pattern = abs(pattern) * 0.5 + 0.5;\n    pattern = 1.0 - abs(fract(pattern * 2.0 - 0.5) - 0.5);\n    \n    // Generate HSL color based on UV coordinates and time\n    vec3 hslColor = vec3(length(uv) * 0.5 + 0.5, 1.0, 0.8);\n    hslColor.x += iTime;\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise for texture\n    float noiseValue = noise(uv * 100.0) * 0.1;\n    \n    // Combine pattern and color, add noise\n    vec3 finalColor = rgbColor * (pattern + noiseValue);\n    \n    return vec4(finalColor, 1.0);\n}\nvec4 Effect2(vec2 uv) {\n    // Convert UV coordinates to polar form for hexagonal symmetry\n    vec2 polar = vec2(length(uv), atan2(uv.y, uv.x));\n    \n    // Multiply angle by 6 for hexagonal symmetry and add rotation over time\n    polar.y *= 6.0;\n    polar.y += sin(iTime) * 0.5;\n    \n    // Create a pulsating pattern based on radius and time\n    float pattern = sin(polar.x + iTime);\n    pattern = abs(pattern) * 0.5 + 0.5;\n    pattern = 1.0 - abs(fract(pattern * 2.0 - 0.5) - 0.5);\n    \n    // Generate HSL color based on UV coordinates and time\n    vec3 hslColor = vec3(length(uv) * 0.5 + 0.5, 1.0, 0.8);\n    hslColor.x += iTime;\n    vec3 rgbColor = hsl2rgb(hslColor);\n    \n    // Add noise for texture\n    float noiseValue = noise(uv * 100.0) * 0.1;\n    \n    // Combine pattern and color, add noise\n    vec3 finalColor = rgbColor * (pattern + noiseValue);\n    \n    return vec4(finalColor, 1.0);\n}"
}